<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <link rel="stylesheet" href="/assets/css/style-custom.css?v=">
<script type="text/javascript" src="/assets/js/jquery-3.6.0.min.js" charset="utf-8"></script>
<script type="text/javascript" src="/assets/js/toc.js" charset="utf-8"></script>


<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Traversing nested lists with coroutines, Rosetta Code style | Kunshan Wang</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="Traversing nested lists with coroutines, Rosetta Code style" />
<meta name="author" content="Kunshan Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’ll try to use coroutines to traverse nested lists, Rosetta Code style. That means I’ll do it in many different programming languages and libraries, including Ruby, Lua, Python (including greenlets), JavaScript, Rust, C#, etc. This task shows the difference between symmetric vs asymmetric coroutines, and stackful vs stackless coroutines. Note that this post alone may not be enough to teach you how to use coroutines in all those languages. I’ll also provide basic information about coroutines, swap-stack, async/await, etc. in the appendices." />
<meta property="og:description" content="I’ll try to use coroutines to traverse nested lists, Rosetta Code style. That means I’ll do it in many different programming languages and libraries, including Ruby, Lua, Python (including greenlets), JavaScript, Rust, C#, etc. This task shows the difference between symmetric vs asymmetric coroutines, and stackful vs stackless coroutines. Note that this post alone may not be enough to teach you how to use coroutines in all those languages. I’ll also provide basic information about coroutines, swap-stack, async/await, etc. in the appendices." />
<link rel="canonical" href="/blog/2022/09/22/coroutine-flatten.html" />
<meta property="og:url" content="/blog/2022/09/22/coroutine-flatten.html" />
<meta property="og:site_name" content="Kunshan Wang" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Traversing nested lists with coroutines, Rosetta Code style" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kunshan Wang"},"dateModified":"2022-09-22T00:00:00+00:00","datePublished":"2022-09-22T00:00:00+00:00","description":"I’ll try to use coroutines to traverse nested lists, Rosetta Code style. That means I’ll do it in many different programming languages and libraries, including Ruby, Lua, Python (including greenlets), JavaScript, Rust, C#, etc. This task shows the difference between symmetric vs asymmetric coroutines, and stackful vs stackless coroutines. Note that this post alone may not be enough to teach you how to use coroutines in all those languages. I’ll also provide basic information about coroutines, swap-stack, async/await, etc. in the appendices.","headline":"Traversing nested lists with coroutines, Rosetta Code style","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2022/09/22/coroutine-flatten.html"},"url":"/blog/2022/09/22/coroutine-flatten.html"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <a id="a-title" href="/">
          <h1>Kunshan Wang</h1>
        </a>
        <h2>Kunshan Wang's Personal Web Site</h2>

        <section id="downloads">
          <a href="/blog/">Blog</a>
          <a href="https://github.com/wks" class="btn btn-github"><span class="icon"></span>My GitHub Profile</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <small>2022-09-22</small>
<h1>Traversing nested lists with coroutines, Rosetta Code style</h1>

<p class="view">by Kunshan Wang</p>

<div id="table-of-contents-box">
    <div class="toc-title">Table of contents <a id="toc-toggle" href="">[show/hide]</a></div>
    <div id="table-of-contents"></div>
</div>

<p>I’ll try to use <strong>coroutines</strong> to traverse nested lists, Rosetta Code style.
That means I’ll do it in many different programming languages and libraries,
including Ruby, Lua, Python (including greenlets), JavaScript, Rust, C#, etc.
This task shows the difference between <em>symmetric</em> vs <em>asymmetric</em> coroutines,
and <em>stackful</em> vs <em>stackless</em> coroutines.</p>

<p>Note that this post alone may not be enough to teach you how to use coroutines
in all those languages.</p>

<p>I’ll also provide basic information about coroutines, swap-stack, async/await,
etc. in the appendices.</p>

<!--more-->

<h1 id="the-task">The task</h1>

<p><strong>Input</strong>:</p>

<ul>
  <li>a nested list of numbers, such as <code class="language-plaintext highlighter-rouge">[1, [[2, 3], [4, 5]], [6, 7, 8]]</code></li>
</ul>

<p><strong>Output</strong>:</p>

<ul>
  <li>
    <p>recursively output all numbers in the list.  At each level, visit all
numbers in one element before visiting any subsequent elements.</p>

    <p>When given the list above, the output should be 1, 2, 3, 4, 5, 6, 7 and
8, in that order.</p>
  </li>
</ul>

<p><strong>Requirement</strong>:</p>

<ul>
  <li>Use coroutine(s) to enumerate a nested list, and yield elements to the
calling coroutine one at a time.</li>
</ul>

<p>I will try to do this task using as many programming languages as possible,
<a href="https://rosettacode.org/wiki/Rosetta_Code">Rosetta Code</a> style, to compare their coroutine syntax and API.
At the time of writing (2022), different programming languages still differ
greatly w.r.t. the design of coroutines.</p>

<h1 id="the-code">The code</h1>

<h2 id="ruby-fibers-stackful-both-asymmetric-and-symmetric">Ruby fibers (stackful, both asymmetric and symmetric)</h2>

<p><a href="https://docs.ruby-lang.org/en/3.1/Fiber.html">Fibers</a> are “primitives for implementing light weight cooperative
concurrency in Ruby”.</p>

<p>Ruby fibers are stackful.  According to the <a href="https://docs.ruby-lang.org/en/3.1/Fiber.html">documentation</a>:</p>

<blockquote>
  <p>As opposed to other stackless light weight concurrency models, each fiber
comes with a stack. This enables the fiber to be paused from deeply nested
function calls within the fiber block.</p>
</blockquote>

<p>Ruby fibers can operate in both asymmetric and symmetric mode.  I’ll demonstrate
the task in both modes below.</p>

<h3 id="asymmetric">Asymmetric</h3>

<p>The <a href="https://docs.ruby-lang.org/en/3.1/Fiber.html#method-i-resume"><code class="language-plaintext highlighter-rouge">Fiber#resume</code></a> instance method resumes a fiber, and a subsequent call to
the <a href="https://docs.ruby-lang.org/en/3.1/Fiber.html#method-c-yield"><code class="language-plaintext highlighter-rouge">Fiber.yield</code></a> class method jumps back to the resumer.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Array</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span>
      <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>      <span class="c1"># recursive call</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span> <span class="n">x</span>         <span class="c1"># can yield within recursive calls</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">fiber_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">StopIteration</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">fiber</span> <span class="o">=</span> <span class="n">fiber_traverse</span> <span class="no">DATA</span>

<span class="kp">loop</span> <span class="k">do</span>   <span class="c1"># Break if StopIteration is raised.</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">fiber</span><span class="p">.</span><span class="nf">resume</span>
  <span class="nb">puts</span> <span class="n">value</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <a href="https://docs.ruby-lang.org/en/3.1/Enumerator.html"><code class="language-plaintext highlighter-rouge">Enumerator</code></a> class can automatically transform
block-based visiting functions into fiber-based coroutine.  It uses fiber only
when necessary.  It uses fiber when used as external iterators (calling <code class="language-plaintext highlighter-rouge">e.next</code>
explicitly), but still uses call-back for internal iteration (<code class="language-plaintext highlighter-rouge">e.each { |v| ...
}</code>).</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Array</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span>
      <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># This is just a usual method call, not a coroutine yield.</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">enum_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="no">Enumerator</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">yielder</span><span class="o">|</span>   <span class="c1"># The yielder encapsulates how to yield.</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
      <span class="n">yielder</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>      <span class="c1"># This may or may not use coroutine yield.</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="c1"># We can do internal iteration</span>
<span class="n">enum_traverse</span><span class="p">(</span><span class="no">DATA</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>   <span class="c1"># use call-back</span>
  <span class="nb">puts</span> <span class="n">value</span>
<span class="k">end</span>

<span class="c1"># and external iteration too.</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">enum_traverse</span><span class="p">(</span><span class="no">DATA</span><span class="p">)</span>
<span class="kp">loop</span> <span class="k">do</span>           <span class="c1"># Break if StopIteration is raised.</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="nf">next</span>  <span class="c1"># This will use fiber.</span>
  <span class="nb">puts</span> <span class="n">value</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="symmetric">Symmetric</h3>

<p>The <a href="https://docs.ruby-lang.org/en/3.1/Fiber.html#method-i-transfer"><code class="language-plaintext highlighter-rouge">Fiber#transfer</code></a> method can switch to any fiber, but always needs an
explicit fiber to switch to.  We can pass the current fiber to the new fiber
when we create it, so it can remember which fiber to transfer back to.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="nb">require</span> <span class="s2">"fiber"</span> 

<span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Array</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span>
      <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>  <span class="c1"># always remember the parent</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">parent</span><span class="p">.</span><span class="nf">transfer</span> <span class="n">x</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">fiber_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">current</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">current</span>     <span class="c1"># get the current fiber</span>
  <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>      <span class="c1"># pass the fiber as parent</span>
    <span class="k">raise</span> <span class="no">StopIteration</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">fiber</span> <span class="o">=</span> <span class="n">fiber_traverse</span> <span class="no">DATA</span>
<span class="kp">loop</span> <span class="k">do</span>   <span class="c1"># Break if StopIteration is raised.</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">fiber</span><span class="p">.</span><span class="nf">transfer</span>
  <span class="nb">puts</span> <span class="n">value</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="lua-threads-stackful-asymmetric">Lua threads (stackful, asymmetric)</h2>

<p>Lua “threads” are stackful coroutines.  Lua has a stackless interpreter,
therefore it can easily implement stackful coroutines (Why? See
<a href="#apdx-sisc">appendix</a>).</p>

<p>Lua provides asymmetric coroutines (with limitations) for the sake of
<em>simplicity</em> and <em>portability</em>.</p>

<ul>
  <li>
    <p><strong>Simplicity</strong>: According to <a href="http://www.lua.org/doc/jucs04.pdf"><em>Coroutines in Lua</em></a>, asymmetric
coroutines may be easier to understand.</p>

    <blockquote>
      <p>On the other hand, asymmetric coroutines truly behave like routines, in
  the sense that control is always transferred back to their callers. Since
  even novice programmers are familiar with the concept of a routine,
  control sequencing with asymmetric coroutines seems much simpler to manage
  and understand, besides allowing the development of more structured
  programs</p>
    </blockquote>
  </li>
  <li>
    <p><strong>Portability</strong>: Supporting symmetric coroutines (or even proper stackful
asymmetric coroutines) will require C to have coroutine facilities, such as
<a href="#swap-stack">swap-stack</a>, which is not always available. According to <a href="http://www.lua.org/doc/jucs04.pdf"><em>Coroutines in
Lua</em></a>:</p>

    <blockquote>
      <p>Lua and C code can freely call each other; therefore, an application can
  create a chain of nested function calls wherein the languages are
  interleaved. Implementing a symmetric facility in this scenario imposes
  the preservation of C state when a Lua coroutine is suspended. This
  preservation is only possible if a coroutine facility is also provided for
  C; but a portable implementation of coroutines for C cannot be written.</p>
    </blockquote>

    <p>Lua also added a limitation: <em>a coroutine cannot yield while there are C
function frames on its stack</em>.  Otherwise, Lua would require a <a href="#swap-stack">swap-stack</a>
mechanism for C, making Lua less portable.</p>
  </li>
</ul>

<p>In Lua, the <a href="http://www.lua.org/manual/5.4/manual.html#pdf-coroutine.resume"><code class="language-plaintext highlighter-rouge">coroutine.resume</code></a> function continues the execution of a
coroutine, and <a href="http://www.lua.org/manual/5.4/manual.html#pdf-coroutine.yield"><code class="language-plaintext highlighter-rouge">coroutine.yield</code></a> jumps back to the calling coroutine.</p>

<figure class="highlight"><pre><code class="language-lua" data-lang="lua"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="k">function</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"table"</span> <span class="k">then</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="k">in</span> <span class="nb">ipairs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">traverse</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>         <span class="c1">-- recursive call</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>    <span class="c1">-- can yield within recursive calls</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">function</span> <span class="nf">coroutine_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">list</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="p">{{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}},</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}}</span>

<span class="kd">local</span> <span class="n">coro</span> <span class="o">=</span> <span class="n">coroutine_traverse</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>

<span class="k">while</span> <span class="kc">true</span> <span class="k">do</span>
  <span class="kd">local</span> <span class="n">_</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">nil</span> <span class="k">then</span>
    <span class="k">break</span>   <span class="c1">-- terminated</span>
  <span class="k">end</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <a href="http://www.lua.org/manual/5.4/manual.html#pdf-coroutine.wrap"><code class="language-plaintext highlighter-rouge">coroutine.wrap</code></a> function can wrap the coroutine into an iterator
function suitable for the <a href="http://www.lua.org/manual/5.4/manual.html#3.3.5">generic <code class="language-plaintext highlighter-rouge">for</code> statement</a>.</p>

<figure class="highlight"><pre><code class="language-lua" data-lang="lua"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">function</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"table"</span> <span class="k">then</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="k">in</span> <span class="nb">ipairs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">traverse</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">function</span> <span class="nf">coroutine_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">coroutine.wrap</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">list</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="p">{{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}},</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}}</span>

<span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">coroutine_traverse</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="k">do</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="python-generators-stackless-asymmetric">Python generators (stackless, asymmetric)</h2>

<p>Python generators are a built-in feature since Python 2.x.  They are
single-frame coroutines.</p>

<p>A function that contains a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-yield_expression"><code class="language-plaintext highlighter-rouge">yield</code></a> keyword is considered a
generator function.  Calling a generator function will create a new generator
object stopped at the beginning of the function, and can be resumed with the
<a href="https://docs.python.org/3/library/functions.html#next"><code class="language-plaintext highlighter-rouge">next(...)</code></a> built-in function.</p>

<p>Being stackless, each coroutine has only one frame, so it cannot yield while
calling another function.  To implement recursive traversal with stackless
coroutines, it is common to create one generator for each level of nested list,
and yield values from the innermost coroutine to the outer coroutine, level by
level.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">new_gen</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>    <span class="c1"># Create the next level of generator
</span>            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">new_gen</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">v</span>             <span class="c1"># Yield everything the inner generator yields
</span>            <span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>       <span class="c1"># until iteration stops.
</span>                <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>

<span class="n">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">gen</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>    <span class="c1"># The top-level generator
</span><span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>   <span class="c1"># Iterate through it
</span>        <span class="k">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>   <span class="c1"># until iteration stops.
</span>    <span class="k">pass</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Python’s <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement"><code class="language-plaintext highlighter-rouge">for</code></a> statement is a syntax sugar for calling <code class="language-plaintext highlighter-rouge">next(...)</code>
until the exception <a href="https://docs.python.org/3/library/exceptions.html#StopIteration"><code class="language-plaintext highlighter-rouge">StopIteration</code></a> is thrown.  The <a href="https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement"><code class="language-plaintext highlighter-rouge">yield
from</code></a> statement is a syntax sugar for yielding everything from
another generator.  Using all the syntax sugar, the code above will become the
following:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>   <span class="c1"># Use "yield from" to yield everything.
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>

<span class="n">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">traverse</span><span class="p">(</span><span class="n">DATA</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="python-coroutines-wtf">Python coroutines (WTF?)</h2>

<p>Python 3.5 attempts to introduce <a href="#async-await">async/await</a>-based asynchronous programming
mechanisms, but it used the word “<a href="https://docs.python.org/3/reference/compound_stmts.html#coroutines">coroutine</a>” to refer to
functions annotated with the <code class="language-plaintext highlighter-rouge">async</code> keyword, like <code class="language-plaintext highlighter-rouge">async def foo(...)</code>, which
is confusing.  Async functions may contain the new <a href="https://docs.python.org/3/reference/expressions.html#await"><code class="language-plaintext highlighter-rouge">await</code></a>
expression, but its semantics is <a href="https://docs.python.org/3/reference/expressions.html#await">very vaguely defined</a> as “suspend
the execution of coroutine on an awaitable object”, whatever “on an awaitable
object” means. That is in stark contrast to the highly detailed semantics of
<a href="https://timsong-cpp.github.io/cppwp/n4861/expr.await#5"><code class="language-plaintext highlighter-rouge">co_await</code> expression in C++20</a> and the <a href="https://doc.rust-lang.org/reference/expressions/await-expr.html"><code class="language-plaintext highlighter-rouge">.await</code> expression in
Rust</a>.</p>

<blockquote>
  <p>In the face of ambiguity, refuse the temptation to guess.</p>

  <p><em>– <a href="https://legacy.python.org/dev/peps/pep-0020/">Zen of Python</a></em></p>
</blockquote>

<p>Because it is so confusing, I am not going to do the task using Python
“coroutines”.</p>

<h2 id="python-greenlet-stackful-symmetric">Python greenlet (stackful, symmetric)</h2>

<h3 id="symmetric-1">Symmetric</h3>

<p>The <a href="https://greenlet.readthedocs.io/en/latest/index.html">greenlet</a> library provides stackful symmetric coroutines.</p>

<p>Greenlets are stackful.  According to the <a href="https://greenlet.readthedocs.io/en/latest/greenlet.html">documentation</a>:</p>

<blockquote>
  <p>A “greenlet” is a small independent pseudo-thread. Think about it as a small
stack of frames; the outermost (bottom) frame is the initial function you
called, and the innermost frame is the one in which the greenlet is currently
paused.</p>
</blockquote>

<p>Greenlets are symmetric.  One greenlet can switch to another using the
<a href="https://greenlet.readthedocs.io/en/latest/api.html#greenlet.greenlet.switch"><code class="language-plaintext highlighter-rouge">glet.switch()</code></a> method to pass a value, or
<a href="https://greenlet.readthedocs.io/en/latest/api.html#greenlet.greenlet.throw"><code class="language-plaintext highlighter-rouge">glet.throw()</code></a> to switch and immediately raise an exception.</p>

<p>There are implementations of Greenlets for both CPython and PyPy.</p>

<p>The official greenlet implementation for CPython uses platform-specific assembly
code (for <a href="https://github.com/python-greenlet/greenlet/blob/master/src/greenlet/platform/switch_amd64_unix.h">amd64</a>, <a href="https://github.com/python-greenlet/greenlet/blob/master/src/greenlet/platform/switch_aarch64_gcc.h">aarch64</a>,
<a href="https://github.com/python-greenlet/greenlet/blob/master/src/greenlet/platform/switch_riscv_unix.h">riscv</a>, etc.) to switch native stacks, similar to what
[Boost Context] does.</p>

<p>PyPy <a href="https://doc.pypy.org/en/latest/stackless.html#greenlets">implements the greenlet API</a> using
<a href="https://doc.pypy.org/en/latest/stackless.html#stacklets">stacklets</a>, which are PyPy’s own swap-stack mechanism.  Like
[Boost Context] and the official greenlet for CPython, PyPy also uses
platform-specific assembly code (for <a href="https://foss.heptapod.net/pypy/pypy/-/blob/branch/default/rpython/translator/c/src/stacklet/switch_x86_64_gcc.h">x86-64</a>,
<a href="https://foss.heptapod.net/pypy/pypy/-/blob/branch/default/rpython/translator/c/src/stacklet/switch_aarch64_gcc.h">aarch64</a>, <a href="https://foss.heptapod.net/pypy/pypy/-/blob/branch/default/rpython/translator/c/src/stacklet/switch_mips64_gcc.h">mips64</a>, etc.  Sorry,
RISC-V.) to switch between stacks.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">greenlet</span>

<span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>      <span class="c1"># recursive call
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="n">parent</span><span class="p">.</span><span class="n">switch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                <span class="c1"># can switch at any level of stack
</span>        
<span class="k">def</span> <span class="nf">greenlet_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">greenlet</span><span class="p">.</span><span class="n">getcurrent</span><span class="p">()</span>     <span class="c1"># remember the current coroutine
</span>    <span class="k">def</span> <span class="nf">_traverse_x</span><span class="p">():</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>            <span class="c1"># and pass it as the parent
</span>        <span class="n">current</span><span class="p">.</span><span class="n">throw</span><span class="p">(</span><span class="nb">StopIteration</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">greenlet</span><span class="p">.</span><span class="n">greenlet</span><span class="p">(</span><span class="n">_traverse_x</span><span class="p">)</span>

<span class="n">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">glet</span> <span class="o">=</span> <span class="n">greenlet_traverse</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">glet</span><span class="p">.</span><span class="n">switch</span><span class="p">()</span>   <span class="c1"># switch to the greenlet
</span>        <span class="k">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="emulate-asymmetric-coroutine-using-the-parent-field">Emulate asymmetric coroutine using the <code class="language-plaintext highlighter-rouge">parent</code> field</h3>

<p>We have just demonstrated that greenlets are symmetric.  However, each greenlet
has a <a href="https://greenlet.readthedocs.io/en/latest/greenlet.html#greenlet-parents">parent</a>.  It is the coroutine to switch to when the
current coroutine terminates, normally or by exception.  However, it doesn’t
mean greenlets are asymmetric because the parent can be changed at any time
during execution, and it is not wrong to explicitly <code class="language-plaintext highlighter-rouge">switch</code> to the parent.</p>

<p>We can rewrite our last example and use the <code class="language-plaintext highlighter-rouge">glet.parent</code> field instead of our
own <code class="language-plaintext highlighter-rouge">parent</code> variable to record the parent.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">greenlet</span>

<span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">greenlet</span><span class="p">.</span><span class="n">getcurrent</span><span class="p">().</span><span class="n">parent</span><span class="p">.</span><span class="n">switch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># switch to parent
</span>        
<span class="k">def</span> <span class="nf">greenlet_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_traverse_x</span><span class="p">():</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">raise</span> <span class="nb">StopIteration</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">greenlet</span><span class="p">.</span><span class="n">greenlet</span><span class="p">(</span><span class="n">_traverse_x</span><span class="p">)</span>  <span class="c1"># The parent is the current greenlet
</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">glet</span> <span class="o">=</span> <span class="n">greenlet_traverse</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">glet</span><span class="p">.</span><span class="n">switch</span><span class="p">()</span>   <span class="c1"># switch to the greenlet
</span>        <span class="k">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="javascript-generators-stackless-asymmetric">JavaScript generators (stackless, asymmetric)</h2>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*"><code class="language-plaintext highlighter-rouge">function*</code></a> declaration defines a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">generator
function</a>. Generator functions can have <code class="language-plaintext highlighter-rouge">yield</code> operator that
pauses the execution of the coroutine.</p>

<p>When a generator function called, it creates a generator object.  It can be used
like an iterator.  The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol"><code class="language-plaintext highlighter-rouge">next</code></a> method switches to the coroutine.</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="kd">function</span><span class="o">*</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">elem</span> <span class="k">of</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">y</span> <span class="k">of</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">elem</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="nx">y</span><span class="p">;</span>  <span class="c1">// Yield what the inner layer yields.</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]];</span>

<span class="kd">let</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">DATA</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Resumes the coroutine.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>And there are syntax sugars.  The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*"><code class="language-plaintext highlighter-rouge">yield*</code></a> operator yields
everything from another generator.  Because a generator behaves like an
iterator, the <code class="language-plaintext highlighter-rouge">for-of</code> statement can iterate through the values it yields.</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="kd">function</span><span class="o">*</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">elem</span> <span class="k">of</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span><span class="o">*</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">x</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">DATA</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="javascript-asyncawait-stackless-asymmetric-asynchronous">JavaScript async/await (stackless, asymmetric, asynchronous)</h2>

<p>JavaScript provides asynchronous programming facilities in the form of
<a href="#async-await">async/await</a> (see <a href="#async-await">appendix</a>).  An <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"><code class="language-plaintext highlighter-rouge">async</code>
function</a> always returns a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code class="language-plaintext highlighter-rouge">Promise</code></a> object which
can be settled (fulfilled or rejected) later.  An <code class="language-plaintext highlighter-rouge">async</code> function may contain
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await"><code class="language-plaintext highlighter-rouge">await</code> operators</a> which cause async function execution to pause
until its operand (a <code class="language-plaintext highlighter-rouge">Promise</code>) is settled, and resume execution after
fulfilment.</p>

<p>Asynchronous programming is more like cooperative multi-tasking than coroutines.</p>

<p><a id="async-await-example"></a></p>

<p>Despite the difference, I now give an example of traversing nested lists using
async/await.  I create two concurrent tasks, one traverses the nested list, and
the other prints the numbers, and they communicate through a “zero-capacity
queue”.  It is similar to multi-thread programming, except there is only one
thread executing both tasks in alternation, and the execution is scheduled by a
scheduler.</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="code"><pre><span class="c1">// A zero-capacity queue.</span>
<span class="c1">// `enqueue` will block until another task calls `dequeue`,</span>
<span class="c1">// and `dequeue` will block until another task calls `enqueue`.</span>
<span class="kd">class</span> <span class="nx">ZeroQueue</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">getter_resolver</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setter_resolver</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="p">}</span>

    <span class="k">async</span> <span class="nx">enqueue</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getter_resolver</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If a consumer came before, we satisfy it.</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">getter_resolver</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">getter_resolver</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// If we come first, we leave the value and wait until consumed.</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">num</span>
            <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">setter_resolver</span> <span class="o">=</span> <span class="nx">resolve</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">async</span> <span class="nx">dequeue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">setter_resolver</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If a producer already came, we take the value and let it continue.</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setter_resolver</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setter_resolver</span> <span class="o">=</span> <span class="kc">null</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// If we come first, we wait for the producer.</span>
            <span class="k">return</span> <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">getter_resolver</span> <span class="o">=</span> <span class="nx">resolve</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ZeroQueue</span><span class="p">()</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">elem</span> <span class="k">of</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">await</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// await may potentially yield,</span>
        <span class="c1">// giving the user an impression of block-waiting.</span>
        <span class="k">await</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">print_all</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="c1">// await may potentially yield,</span>
        <span class="c1">// giving the user an impression of block-waiting.</span>
        <span class="kd">const</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">dequeue</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">end</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="c1">// The first task traverses the list and signal termination.</span>
<span class="nx">traverse</span><span class="p">(</span><span class="nx">DATA</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="dl">"</span><span class="s2">end</span><span class="dl">"</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// The second task keep polling till the end.</span>
<span class="nx">print_all</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="javascript-async-generators-stackless-asymmetric-asynchronous">JavaScript async generators (stackless, asymmetric, asynchronous)</h2>

<p>Functions annotated with <code class="language-plaintext highlighter-rouge">async function*</code> defines an async generator function.
An <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator">async generator</a> is like a generator, but the <code class="language-plaintext highlighter-rouge">.next()</code>
method returns a <code class="language-plaintext highlighter-rouge">Promise</code> so it can be awaited.  This allows the generator to
use <code class="language-plaintext highlighter-rouge">await</code> while iterating.  It can also use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of"><code class="language-plaintext highlighter-rouge">for await ... of</code>
statement</a> as a syntax sugar.</p>

<p>This practice is like building coroutine on top of async/await on top of
coroutine, which looks ugly to me.  Anyway, here is the code:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">async</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">elem</span> <span class="k">of</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span><span class="o">*</span> <span class="k">await</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">x</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="k">await</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">DATA</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">main</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="rust-asyncawait-stackless-asymmetric-asynchronous">Rust async/await (stackless, asymmetric, asynchronous)</h2>

<p>Rust’s <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code> keywords provides support for <a href="#async-await">asynchronous
programming</a> (see <a href="#async-await">appendix</a>) based on stackless asymmetric
coroutines.  There is <a href="https://rust-lang.github.io/async-book/">a dedicated book</a> that covers
asynchronous programming in Rust.</p>

<p>An <a href="https://doc.rust-lang.org/reference/items/functions.html#async-functions"><code class="language-plaintext highlighter-rouge">async</code> function</a> or an <a href="https://doc.rust-lang.org/reference/expressions/block-expr.html#async-blocks"><code class="language-plaintext highlighter-rouge">async</code> block</a>,
when executed, do not execute their bodies immediately, but creates an object
that holds the execution context of that function or block.  Each async function
or block is represented to the user as a <code class="language-plaintext highlighter-rouge">Future</code>.  The <code class="language-plaintext highlighter-rouge">Future::poll</code> method
will resume the async thing until it yields (on an <code class="language-plaintext highlighter-rouge">await</code> site) or finishes.</p>

<p>The <a href="https://doc.rust-lang.org/reference/expressions/await-expr.html"><code class="language-plaintext highlighter-rouge">await</code> expression</a> can only be used in <code class="language-plaintext highlighter-rouge">async</code> functions or
blocks.  Its semantics is complicated but <a href="https://doc.rust-lang.org/reference/expressions/await-expr.html">well-documented</a>. It
calls <code class="language-plaintext highlighter-rouge">Future::poll</code> on a <code class="language-plaintext highlighter-rouge">Future</code> object and, if the <code class="language-plaintext highlighter-rouge">Future</code> is ready, it
grabs its value continues without yielding; otherwise, it yields from the
current <code class="language-plaintext highlighter-rouge">async</code> function or block.  When resumed, it will poll the <code class="language-plaintext highlighter-rouge">Future</code>
again and may or may not yield depending on whether the <code class="language-plaintext highlighter-rouge">Future</code> is ready.</p>

<p>Implementation-wise, <a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">the documentation suggests</a> that
Rust decomposes an <code class="language-plaintext highlighter-rouge">async</code> function (or block) into a state machine (see
<a href="#function-to-state-machine">appendix</a>) where each state represents an <code class="language-plaintext highlighter-rouge">await</code> site.</p>

<p>Async/await is not supposed to be used like coroutines.  In fact, the book
Asynchronous Programming in Rust <a href="https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html#async-vs-other-concurrency-models">contrasts async/await against
coroutines</a>.  I have given an example in JavaScript
that traverses nested list using async/await using two tasks and a channel.  It
is possible to do the same in Rust, but that’ll need a scheduler.  Since I am
too lazy to write a scheduler or introduce a third-party scheduler, I’ll try a
different approach here.</p>

<p>I’ll abuse the async/await mechanism to exploit its underlying coroutine and
make it behave like a generator.</p>

<ul>
  <li>
    <p><em>Resume</em>: We know that <code class="language-plaintext highlighter-rouge">Future::poll</code> resumes the coroutine.  We call
<code class="language-plaintext highlighter-rouge">Future::poll</code> directly, which is seldom done in usual async/await-based
programs unless we are implementing the “executor” (i.e. scheduler).</p>
  </li>
  <li>
    <p><em>Yield</em>: Each <code class="language-plaintext highlighter-rouge">.await</code> corresponds to a yield site.  We customise the
behaviour of our <code class="language-plaintext highlighter-rouge">Future</code> object (i.e. <code class="language-plaintext highlighter-rouge">WaitUntilResultTaken</code>) so that the
<code class="language-plaintext highlighter-rouge">.await</code> always yields (<code class="language-plaintext highlighter-rouge">Pending</code>) when reached from within the coroutine,
but will continue (<code class="language-plaintext highlighter-rouge">Ready</code>) when resumed from the main function.  The
behaviour is controlled by the <code class="language-plaintext highlighter-rouge">result_taken</code> variable.</p>
  </li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">async fn traverse</code> will recursively call itself in the <code class="language-plaintext highlighter-rouge">.await</code> expression,
and will yield level by level through all the <code class="language-plaintext highlighter-rouge">.await</code> sites to the main
function.</p>

<p>Then we have a problem.  Whenever it yields, the value yielded to the <code class="language-plaintext highlighter-rouge">.poll()</code>
call site in <code class="language-plaintext highlighter-rouge">main</code> is always <code class="language-plaintext highlighter-rouge">Poll::Pending</code>.  Then how do we pass the
traversed numbers to <code class="language-plaintext highlighter-rouge">main</code>?  To work around this, the coroutine writes the
number in a shared variable <code class="language-plaintext highlighter-rouge">result_reporter.num</code> before it yields. This makes
the <code class="language-plaintext highlighter-rouge">ResultReporter</code> struct effectively behave like a “zero-capacity queue” in
our <a href="#async-await-example">previous example</a>, but it connects the generator and
the main function instead of two tasks.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">async_recursion</span><span class="p">::</span><span class="n">async_recursion</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="n">Future</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">pin</span><span class="p">::</span><span class="nb">Pin</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">atomic</span><span class="p">::{</span><span class="n">AtomicBool</span><span class="p">,</span> <span class="n">AtomicI32</span><span class="p">,</span> <span class="n">Ordering</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Poll</span><span class="p">};</span>

<span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="n">ResultReporter</span> <span class="p">{</span>
    <span class="n">num</span><span class="p">:</span> <span class="n">AtomicI32</span><span class="p">,</span> <span class="c1">// Rust is having problem figuring out whether the coroutine races with main,</span>
    <span class="n">result_taken</span><span class="p">:</span> <span class="n">AtomicBool</span><span class="p">,</span> <span class="c1">// so we just use atomic variables here.</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ResultReporter</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">report_result</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WaitUntilResultTaken</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.num</span><span class="nf">.store</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.result_taken</span><span class="nf">.store</span><span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">);</span>
        <span class="n">WaitUntilResultTaken</span> <span class="p">{</span>
            <span class="n">result_taken</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.result_taken</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">take_result</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="k">self</span><span class="py">.num</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.result_taken</span><span class="nf">.store</span><span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">);</span>
        <span class="n">num</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">WaitUntilResultTaken</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">result_taken</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">AtomicBool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Future</span> <span class="k">for</span> <span class="n">WaitUntilResultTaken</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="p">();</span>

    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.result_taken</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">)</span> <span class="p">{</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">NestedList</span> <span class="p">{</span>
    <span class="nf">Leaf</span><span class="p">(</span><span class="nb">i32</span><span class="p">),</span>
    <span class="nf">Nested</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">NestedList</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[async_recursion]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">NestedList</span><span class="p">,</span> <span class="n">reporter</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ResultReporter</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">list</span> <span class="p">{</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// This `await` expression will call `WaitUntilResultTaken::poll()` twice.</span>
            <span class="c1">// The first time is when we reach the `await` here.  It returns `Poll::Pending` so we yield.</span>
            <span class="c1">// The second time is when `main` calls `poll`.  It returns `Poll::Ready(())` so we continue.</span>
            <span class="n">reporter</span><span class="nf">.report_result</span><span class="p">(</span><span class="o">*</span><span class="n">num</span><span class="p">)</span><span class="k">.await</span>
        <span class="p">}</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="k">in</span> <span class="n">lists</span> <span class="p">{</span>
                <span class="c1">// This `await` will pass the `Poll::Pending` to the caller level by level until it reaches `main`.</span>
                <span class="nf">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">reporter</span><span class="p">)</span><span class="k">.await</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
    <span class="k">let</span> <span class="n">nested_list</span> <span class="o">=</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">3</span><span class="p">)]),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">5</span><span class="p">)]),</span>
        <span class="p">]),</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
        <span class="p">]),</span>
    <span class="p">]);</span>

    <span class="k">let</span> <span class="n">result_reporter</span> <span class="o">=</span> <span class="nn">ResultReporter</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">coro</span> <span class="o">=</span> <span class="nf">traverse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nested_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result_reporter</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">null_ctx</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nn">null_mut</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Context</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">coro_p</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">coro</span><span class="p">)</span> <span class="p">};</span>
        <span class="k">let</span> <span class="n">poll_result</span> <span class="o">=</span> <span class="n">coro_p</span><span class="nf">.poll</span><span class="p">(</span><span class="n">null_ctx</span><span class="p">);</span> <span class="c1">// Let the coroutine run.</span>
        <span class="k">match</span> <span class="n">poll_result</span> <span class="p">{</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// When pausing (at `await` sites) during execution, we get the result.</span>
                <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="n">result_reporter</span><span class="nf">.take_result</span><span class="p">();</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// When finished, we just quit.</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="rust-coroutine-crate-stackful-asymmetric">Rust coroutine crate (stackful, asymmetric)</h2>

<p>The third-part crate <a href="https://docs.rs/coroutine/latest/coroutine/"><code class="language-plaintext highlighter-rouge">coroutine</code></a> provides stackful asymmetric
coroutines.  It is built upon the <code class="language-plaintext highlighter-rouge">context</code> crate (see below).</p>

<p>It looks like this crate has not been maintained for quite some time and it
won’t compile. I’ll not do the task using the <code class="language-plaintext highlighter-rouge">coroutine</code> crate.  If you are
interested, their documentation contains some examples.</p>

<h2 id="rust-context-crate-stackful-symmetric">Rust context crate (stackful, symmetric)</h2>

<p>The third-part crate <a href="https://docs.rs/context/latest/context/index.html"><code class="language-plaintext highlighter-rouge">context</code></a> is similar to [Boost Context]. It
provides the abstraction of stackful symmetric coroutines.</p>

<p>It implements swap-stack using machine-specific assembly code
(<a href="https://github.com/zonyitoo/context-rs/blob/master/src/asm/jump_x86_64_sysv_elf_gas.S">x86-64</a>, <a href="https://github.com/zonyitoo/context-rs/blob/master/src/asm/make_arm64_aapcs_elf_gas.S">AArch64</a>,
<a href="https://github.com/zonyitoo/context-rs/blob/master/src/asm/jump_ppc64_sysv_elf_gas.S">ppc64</a>, sorry RISC-V).</p>

<p>The <a href="https://docs.rs/context/latest/context/context/struct.Context.html#method.resume"><code class="language-plaintext highlighter-rouge">Context::resume</code></a> method switches the thread to the
other coroutine, and pass the context of the original coroutine so the thread
can switch back.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">context</span><span class="p">::</span><span class="nn">stack</span><span class="p">::</span><span class="n">ProtectedFixedSizeStack</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">context</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Transfer</span><span class="p">};</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">enum</span> <span class="n">NestedList</span> <span class="p">{</span>
    <span class="nf">Leaf</span><span class="p">(</span><span class="nb">i32</span><span class="p">),</span>
    <span class="nf">Nested</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">NestedList</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">NestedList</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Transfer</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">list</span> <span class="p">{</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Context-switching consumes the `Context` object.  We have to take and replace it.</span>
            <span class="k">let</span> <span class="n">old_t</span> <span class="o">=</span> <span class="n">t</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">new_t</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">old_t</span><span class="py">.context</span><span class="nf">.resume</span><span class="p">(</span><span class="o">*</span><span class="n">num</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">};</span>
            <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">new_t</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="k">in</span> <span class="n">lists</span> <span class="p">{</span>
                <span class="c1">// This is stackful coroutine.  We can do recursive function call.</span>
                <span class="nf">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
    <span class="k">let</span> <span class="n">nested_list</span> <span class="o">=</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">3</span><span class="p">)]),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">5</span><span class="p">)]),</span>
        <span class="p">]),</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
        <span class="p">]),</span>
    <span class="p">]);</span>

    <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">context_function</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Transfer</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span>
        <span class="c1">// The initial Transfer carries the pointer to the list as `data`.</span>
        <span class="k">let</span> <span class="n">list</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">t</span><span class="py">.data</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">NestedList</span><span class="p">)</span> <span class="p">};</span>

        <span class="c1">// From now on, we'll frequently take and replace the Transfer. Use Option.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">t_holder</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">t_holder</span><span class="p">);</span>

        <span class="c1">// Send a special value to indicate the end of traversal.</span>
        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_holder</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">t</span><span class="py">.context</span><span class="nf">.resume</span><span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span><span class="p">)</span> <span class="p">};</span>
        <span class="nd">unreachable!</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">stack</span> <span class="o">=</span> <span class="nn">ProtectedFixedSizeStack</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">Transfer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Context</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">,</span> <span class="n">context_function</span><span class="p">)</span> <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// The initial `resume` sends the list reference as a usize.</span>
    <span class="n">t</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">t</span><span class="py">.context</span><span class="nf">.resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nested_list</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">NestedList</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">};</span>

    <span class="c1">// Use this special value to indicate end of traversal.</span>
    <span class="k">while</span> <span class="n">t</span><span class="py">.data</span> <span class="o">!=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">t</span><span class="py">.data</span><span class="p">);</span>

        <span class="c1">// Subsequent `resume` doesn't need to carry values.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">t</span><span class="py">.context</span><span class="nf">.resume</span><span class="p">(</span><span class="mi">0usize</span><span class="p">)</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="c-iterators-stackless-asymmetric">C# iterators (stackless, asymmetric)</h2>

<p>C# can implement iterators using the <code class="language-plaintext highlighter-rouge">yield return</code> or <code class="language-plaintext highlighter-rouge">yield break</code> statements.
A function that contains <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield"><code class="language-plaintext highlighter-rouge">yield</code></a> returns an <code class="language-plaintext highlighter-rouge">Enumerable&lt;T&gt;</code> or
<code class="language-plaintext highlighter-rouge">Enumerator&lt;T&gt;</code> which is resumed every time an item is requested.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td><td class="code"><pre><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">interface</span> <span class="nc">NestedList</span>
<span class="p">{</span>
    <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">Traverse</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Leaf</span> <span class="p">:</span> <span class="n">NestedList</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Leaf</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">num</span> <span class="p">=</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">Traverse</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Branch</span> <span class="p">:</span> <span class="n">NestedList</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">NestedList</span><span class="p">&gt;</span> <span class="n">children</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Branch</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">children</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">NestedList</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">Branch</span> <span class="nf">Add</span><span class="p">(</span><span class="n">NestedList</span> <span class="n">child</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">children</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">Traverse</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// It is stackless.  We need to yield from the inner iterators.</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">y</span> <span class="k">in</span> <span class="n">child</span><span class="p">.</span><span class="nf">Traverse</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="k">yield</span> <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">IteratorTraversal</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
        <span class="kt">var</span> <span class="n">nestedList</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Branch</span><span class="p">()</span>
            <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
            <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Branch</span><span class="p">()</span>
                    <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Branch</span><span class="p">()</span>
                        <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">2</span><span class="p">))</span>
                        <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">3</span><span class="p">)))</span>
                    <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Branch</span><span class="p">()</span>
                        <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">4</span><span class="p">))</span>
                        <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">5</span><span class="p">))))</span>
            <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Branch</span><span class="p">()</span>
                    <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">6</span><span class="p">))</span>
                    <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">7</span><span class="p">))</span>
                    <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">8</span><span class="p">)));</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">n</span> <span class="k">in</span> <span class="n">nestedList</span><span class="p">.</span><span class="nf">Traverse</span><span class="p">())</span> <span class="c1">// Create the iterator</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="c-asyncawait-stackless-asymmetric-asynchronous">C# async/await (stackless, asymmetric, asynchronous)</h2>

<p>C# <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">supports asynchronous programming</a> (see
<a href="#async-await">appendix</a>).  Like async/await in any other language, its
programming model is more like cooperative multi-task programming than
coroutines.  It is possible to implement asynchronous traversal using an
<a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.threading.asyncqueue-1?view=visualstudiosdk-2022">AsyncQueue</a> to communicate between the traversal task and a
consumer task that consumes the visited values. I am not going to give an
example here.</p>

<h2 id="c-swapcontext-stackful-symmetric">C swapcontext (stackful, symmetric)</h2>

<p>The C programming language itself doesn’t have any support for coroutines or
<a href="#swap-stack">swap-stack</a>.</p>

<p>The POSIX function <a href="https://linux.die.net/man/3/makecontext"><code class="language-plaintext highlighter-rouge">makecontext</code></a> can create a “context” for a
function on a given stack so that when a subsequent invocation of
<a href="https://linux.die.net/man/3/swapcontext"><code class="language-plaintext highlighter-rouge">swapcontext</code></a> swaps to that context, it will continue
execution from the beginning of the given function on the given stack.  This
effectively provides a <a href="#swap-stack">swap-stack</a> mechanism, and can be used to implement
symmetric coroutines.</p>

<p>One design flaw of <code class="language-plaintext highlighter-rouge">makecontext</code> is that it only supports passing <code class="language-plaintext highlighter-rouge">int</code>
arguments to the given function.  Because the size of <code class="language-plaintext highlighter-rouge">int</code> is
platform-specific, it is hard to pass pointers across <code class="language-plaintext highlighter-rouge">makecontext</code>.  According
to the <a href="https://linux.die.net/man/3/makecontext">man page</a>, POSIX 2008 removed <code class="language-plaintext highlighter-rouge">makecontext</code> and
<code class="language-plaintext highlighter-rouge">swapcontext</code>, citing portability issues, and recommended the use of POSIX
threads.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ucontext.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">first_child</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next_sibling</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node8</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node7</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node8</span>    <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node6</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node7</span>    <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node678</span>      <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node6</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node5</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node4</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node5</span>    <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node45</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node4</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node3</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node2</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node3</span>    <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node23</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node45</span>   <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node2345</span>     <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node23</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node678</span>  <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node1</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2345</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node12345678</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>

<span class="n">ucontext_t</span> <span class="n">main_context</span><span class="p">;</span>
<span class="n">ucontext_t</span> <span class="n">coro_context</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">current_value</span><span class="p">;</span>
<span class="n">bool</span> <span class="n">finished</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">do_yield</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">current_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">swapcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coro_context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">main_context</span><span class="p">);</span>  <span class="c1">// switch back to main</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">visit_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_sibling</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">do_yield</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">visit_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">);</span>   <span class="c1">// recursive call</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">traverse</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">visit_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node12345678</span><span class="p">);</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coro_context</span><span class="p">);</span>

    <span class="c1">// Obviously, it is stackful.</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">65536</span><span class="p">);</span>    <span class="c1">// Not sure if 65536 is enough, though.</span>
                                    <span class="c1">// If we are careful enough, we should use mprotect</span>
                                    <span class="c1">// to create a PROT_NONE region to protect against</span>
                                    <span class="c1">// stack overflow.</span>
    <span class="n">coro_context</span><span class="p">.</span><span class="n">uc_stack</span> <span class="o">=</span> <span class="p">(</span><span class="n">stack_t</span><span class="p">){</span> <span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="n">stack</span><span class="p">,</span> <span class="p">.</span><span class="n">ss_size</span> <span class="o">=</span> <span class="mi">4096</span> <span class="p">};</span>
    <span class="n">coro_context</span><span class="p">.</span><span class="n">uc_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">main_context</span><span class="p">;</span>
    <span class="n">makecontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coro_context</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">traverse</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swapcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">main_context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">coro_context</span><span class="p">);</span>  <span class="c1">// switch to coroutine</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current_value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="c-coroutine-stackless-asymmetric-asynchronous">C++ coroutine (stackless, asymmetric, asynchronous)</h2>

<p>C++20 introduced “coroutines”.  More precisely, it introduced mechanisms so that
libraries can implement <a href="#async-await">asynchronous programming</a> on top of them.</p>

<p>Any function that contains <code class="language-plaintext highlighter-rouge">co_await</code>, <code class="language-plaintext highlighter-rouge">co_yield</code> and/or <code class="language-plaintext highlighter-rouge">co_return</code> are
coroutine functions.</p>

<p>Calling a coroutine function behaves like the pseudo-code defined in
<a href="https://timsong-cpp.github.io/cppwp/n4861/dcl.fct.def.coroutine#5">Section 9.5.4 (dcl.fct.def.coroutine) paragraph 5</a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="n">promise</span><span class="o">-</span><span class="n">type</span> <span class="n">promise</span> <span class="n">promise</span><span class="o">-</span><span class="n">constructor</span><span class="o">-</span><span class="n">arguments</span> <span class="p">;</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">()</span> <span class="p">;</span>
        <span class="n">function</span><span class="o">-</span><span class="n">body</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">initial</span><span class="o">-</span><span class="n">await</span><span class="o">-</span><span class="n">resume</span><span class="o">-</span><span class="n">called</span><span class="p">)</span>
            <span class="k">throw</span> <span class="p">;</span>
        <span class="n">promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">()</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="k">final</span><span class="o">-</span><span class="n">suspend</span> <span class="o">:</span>
    <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Basically, it implicitly creates a “promise object” which is called (awaited) at
different points of the coroutine execution, like “hooks” or aspect-oriented
programming.  The compiler will generate those <code class="language-plaintext highlighter-rouge">promise.xxxx()</code> method calls,
and it is the programmer’s (or library writer’s) responsibility to define the
“promise type” and the <code class="language-plaintext highlighter-rouge">.initial_suspend()</code>, <code class="language-plaintext highlighter-rouge">.unhandled_exception()</code>, and
<code class="language-plaintext highlighter-rouge">.final_suspend()</code> methods to make the generated calls meaningful.</p>

<p>And evaluation a <code class="language-plaintext highlighter-rouge">co_await</code> expression behaves as defined in <a href="https://timsong-cpp.github.io/cppwp/n4861/expr.await#5">Section 7.6.2.3
(expr.await) paragraph 5</a>.  It takes an “awaiter” (more
precisely, anything that can be converted to an “awaiter”) as operand, and</p>

<ul>
  <li>It calls <code class="language-plaintext highlighter-rouge">awaiter.await_ready()</code>.
    <ul>
      <li>If it returns true, it calls <code class="language-plaintext highlighter-rouge">awaiter.await_resume()</code>, and that’s the
value of the <code class="language-plaintext highlighter-rouge">co_await</code> expression.</li>
      <li>If it returns false, it calls <code class="language-plaintext highlighter-rouge">awaiter.await_suspend()</code>, and depending
on its result, it may suspend the execution of the coroutine, or suspend
and switch to another coroutine, or just continue execution.</li>
    </ul>
  </li>
</ul>

<p>It’s the “conditionally yielding” behaviour of common <a href="#async-await">async/await</a>-based
programming.  Again the compiler generates the above method calls, and it is
again the programmer’s (or library writer’s) responsibility to implement the
<code class="language-plaintext highlighter-rouge">.await_ready()</code>, <code class="language-plaintext highlighter-rouge">.await_resume()</code> and <code class="language-plaintext highlighter-rouge">.await_suspend()</code> methods to make those
generated calls meaningful.</p>

<p>The <a href="https://timsong-cpp.github.io/cppwp/n4861/expr.yield"><code class="language-plaintext highlighter-rouge">co_yield</code></a> expression calls <code class="language-plaintext highlighter-rouge">promise.yield_value(x)</code>,
and programmer (or library writer) shall implement the promise object to make
<code class="language-plaintext highlighter-rouge">.yield_value</code> method meaningful.</p>

<p>And the <a href="https://timsong-cpp.github.io/cppwp/n4861/stmt.return.coroutine"><code class="language-plaintext highlighter-rouge">co_return</code></a> statement calls
<code class="language-plaintext highlighter-rouge">promise.return_void()</code>, and the programmer (or library writer) shall implement
the promise object to make <code class="language-plaintext highlighter-rouge">.return_void</code> method meaningful.</p>

<p>And the standard library function <code class="language-plaintext highlighter-rouge">coroutine_handle::resume()</code> resumes a paused
“coroutine”.</p>

<p>As we can see</p>

<ul>
  <li>the specification defines the semantics of coroutine functions, the
<code class="language-plaintext highlighter-rouge">co_await</code>, <code class="language-plaintext highlighter-rouge">co_yield</code> and <code class="language-plaintext highlighter-rouge">co_return</code> expressions/statements, and the
<code class="language-plaintext highlighter-rouge">coroutine_handle</code> library object and its <code class="language-plaintext highlighter-rouge">.resume()</code> method, and</li>
  <li>the compiler (GCC, Clang, etc.) generate code for the <code class="language-plaintext highlighter-rouge">co_xxx</code>
expression/statements, and</li>
  <li>the programmer defines the promise type and (optionally) “awaiter” types and
fills in lots and lots of methods to customise the behaviour.</li>
</ul>

<p>How complicated C++20 “coroutines” are!</p>

<p>It is complicated enough to <a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html">confuse a C++ programmer with 25-years’
experience</a>.</p>

<p>And I admit I am not smart enough to use C++20 coroutines.</p>

<p>If you are not smart enough, either, but want to learn about C++20 coroutines, I
recommend starting with another language, such as Ruby or Lua, and come back to
C++20 when the idea of coroutines don’t scare you.</p>

<p>Anyway, here is the code.  The following code tries to use C++20 coroutines as
generators.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;coroutine&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">first_child</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next_sibling</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
<span class="n">Node</span> <span class="n">node8</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node7</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node8</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node6</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node7</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node678</span>      <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node6</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node5</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node4</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node5</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node45</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node4</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node3</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node3</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node23</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node45</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2345</span>     <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node23</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node678</span>  <span class="p">};</span>
<span class="n">Node</span> <span class="n">node1</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2345</span> <span class="p">};</span>
<span class="n">Node</span> <span class="n">node12345678</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>

<span class="k">struct</span> <span class="nc">Traverser</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">promise_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">handle_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">promise_type</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">current_value_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">finished_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="c1">// This is executed when the "coroutine" is created.</span>
        <span class="n">Traverser</span> <span class="n">get_return_object</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">Traverser</span><span class="p">(</span><span class="n">handle_type</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// Called at the beginning of the coroutine.</span>
        <span class="c1">// We let it stop there to mimic Python generator behaviour.</span>
        <span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">initial_suspend</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{};</span>
        <span class="p">}</span>

        <span class="c1">// Called when the coroutine finished execution.</span>
        <span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">final_suspend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="c1">// We set a variable so the main function knows it finished.</span>
            <span class="n">finished_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">{};</span>
        <span class="p">}</span>

        <span class="c1">// Called when a co_yield expression is evaluated.</span>
        <span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">yield_value</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">current_value_</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">{};</span>
        <span class="p">}</span>

        <span class="c1">// Called when an exception is thrown.</span>
        <span class="kt">void</span> <span class="n">unhandled_exception</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">terminate</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">handle_type</span> <span class="n">handle_</span><span class="p">;</span>

    <span class="n">Traverser</span><span class="p">(</span><span class="n">handle_type</span> <span class="n">handle</span><span class="p">)</span> <span class="o">:</span> <span class="n">handle_</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">resume</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">handle_</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">finished</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">handle_</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">finished_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">get_value</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">handle_</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">current_value_</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">Traverser</span> <span class="n">visit_node</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_sibling</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Yield.</span>
            <span class="k">co_yield</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// It is stackless.  We need multiple levels of coroutines.</span>
            <span class="k">auto</span> <span class="n">sub_traverser</span> <span class="o">=</span> <span class="n">visit_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">);</span>
            <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sub_traverser</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sub_traverser</span><span class="p">.</span><span class="n">finished</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// Yield from sub-coroutine.</span>
                <span class="k">co_yield</span> <span class="n">sub_traverser</span><span class="p">.</span><span class="n">get_value</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">visit_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node12345678</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverser</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">traverser</span><span class="p">.</span><span class="n">finished</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">traverser</span><span class="p">.</span><span class="n">get_value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="c-boostcoroutine2-stackful-asymmetric">C++ Boost.Coroutine2 (stackful, asymmetric)</h2>

<p>Note: Boost.Coroutine is deprecated in favour for Boost.Coroutine2.</p>

<p><a href="https://www.boost.org/doc/libs/1_80_0/libs/coroutine2/doc/html/index.html">Boost.Coroutine2</a> provides stackful asymmetric coroutines.  It is implemented
on top of <a href="https://www.boost.org/doc/libs/1_80_0/libs/context/doc/html/index.html">Boost.Context</a> (see below).</p>

<p>A <code class="language-plaintext highlighter-rouge">boost::coroutines2::coroutine&lt;T&gt;</code> has two members: <code class="language-plaintext highlighter-rouge">pull_type</code> and
<code class="language-plaintext highlighter-rouge">push_type</code>.  A coroutine can be created by instantiating either of them.  In
this task, we will create a <code class="language-plaintext highlighter-rouge">pull_type</code> so that the main function can pull data
from the coroutine.  It will create a coroutine which receives a <code class="language-plaintext highlighter-rouge">&amp;push_type</code> so
that it can yield and push data back to the main function.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/coroutine2/coroutine.hpp&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">first_child</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next_sibling</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
<span class="n">Node</span> <span class="n">node8</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node7</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node8</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node6</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node7</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node678</span>      <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node6</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node5</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node4</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node5</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node45</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node4</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node3</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node3</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node23</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node45</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2345</span>     <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node23</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node678</span>  <span class="p">};</span>
<span class="n">Node</span> <span class="n">node1</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2345</span> <span class="p">};</span>
<span class="n">Node</span> <span class="n">node12345678</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>

<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">coroutines2</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">coro_t</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">visit_node</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">coro_t</span><span class="o">::</span><span class="n">push_type</span> <span class="o">&amp;</span><span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_sibling</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sink</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>   <span class="c1">// Yield at any level.  It's stackful!</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">visit_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">,</span> <span class="n">sink</span><span class="p">);</span>   <span class="c1">// Recursive call.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">coro_t</span><span class="o">::</span><span class="n">pull_type</span><span class="p">([](</span><span class="n">coro_t</span><span class="o">::</span><span class="n">push_type</span> <span class="o">&amp;</span><span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">visit_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node12345678</span><span class="p">,</span> <span class="n">sink</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">value</span> <span class="o">:</span> <span class="n">traverser</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Can be used as iterator using begin() and end().</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="c-boostcontext-stackful-symmetric">C++ Boost.Context (stackful, symmetric)</h2>

<p><a href="https://www.boost.org/doc/libs/1_80_0/libs/context/doc/html/index.html">Boost.Context</a> implements a <a href="#swap-stack">swap-stack</a> mechanism using machine-dependent
assembly language(<a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_x86_64_sysv_elf_gas.S">x86-64</a>, <a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_arm64_aapcs_elf_gas.S">ARM64</a>,
<a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_riscv64_sysv_elf_gas.S">RISCV64</a>, etc.).  We can also implement symmetric coroutines
using its C++ API.  A <code class="language-plaintext highlighter-rouge">boost::coroutine::fiber</code> represents a coroutine, and
<code class="language-plaintext highlighter-rouge">fiber::resume()</code> switches to that coroutine.  Because <code class="language-plaintext highlighter-rouge">fiber::resume()</code> doesn’t
pass values, we need to use a side channel (the shared <code class="language-plaintext highlighter-rouge">State</code> object) to pass
the value and indicate that the traversal has finished.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/coroutine2/coroutine.hpp&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">first_child</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next_sibling</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
<span class="n">Node</span> <span class="n">node8</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node7</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node8</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node6</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node7</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node678</span>      <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node6</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node5</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node4</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node5</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node45</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node4</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node3</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node3</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node23</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node45</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2345</span>     <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node23</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node678</span>  <span class="p">};</span>
<span class="n">Node</span> <span class="n">node1</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2345</span> <span class="p">};</span>
<span class="n">Node</span> <span class="n">node12345678</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>

<span class="k">struct</span> <span class="nc">State</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">current_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">finished</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">visit_node</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">State</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">fiber</span> <span class="o">&amp;</span><span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_sibling</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">state</span><span class="p">.</span><span class="n">current_value</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
            <span class="n">sink</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sink</span><span class="p">).</span><span class="n">resume</span><span class="p">();</span>   <span class="c1">// Yield at any level.  It's stackful!</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">visit_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">sink</span><span class="p">);</span>   <span class="c1">// Recursive call.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">State</span> <span class="n">state</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">fiber</span><span class="p">([</span><span class="o">&amp;</span><span class="n">state</span><span class="p">](</span><span class="n">boost</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">fiber</span> <span class="o">&amp;&amp;</span><span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">visit_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node12345678</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">sink</span><span class="p">);</span>
        <span class="n">state</span><span class="p">.</span><span class="n">finished</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sink</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverser</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">traverser</span><span class="p">).</span><span class="n">resume</span><span class="p">();</span>  <span class="c1">// Resume the coroutine.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">state</span><span class="p">.</span><span class="n">current_value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h1 id="appendices">Appendices</h1>

<h2 id="why-this-task">Why this task?</h2>

<p>The purpose of this task is to compare <em>symmetric</em>, <em>asymmetric</em>, <em>stackful</em> and
<em>stackless</em> coroutines.</p>

<p>This task is natural to implement with coroutines, because the traversal of a
data structure is relatively independent from the consumption of the values.</p>

<p>This task is also much easier with stackful coroutines than stackless
coroutines.  Because the data structure (nested lists) is recursive, it is
easier to traverse it using a recursive algorithm, and recursion needs a stack.
Stackful coroutines can handle recursive calls quite trivially. But when using
stackless coroutines, we have to do some hack and chain up multiple coroutines
to form a stack of coroutines, and yield values from the innermost coroutine
through multiple layers of coroutines to the consumer.</p>

<p>From the code examples above, we can clearly see the difference between
different kinds of coroutines.</p>

<h2 id="what-are-coroutines-anyway">What are coroutines anyway?</h2>

<p>According to <a href="https://dl.acm.org/doi/10.1145/366663.366704">Conway</a>, a <strong>coroutine</strong> is “<em>an autonomous program
which communicates with adjacent modules as if they were input or output
subroutines</em>”.  Coroutines are subroutines all at the same level, each acting as
if it were the master program when in fact there is no master program.</p>

<p>Coroutines has the following characteristics. (See <a href="http://www.lua.org/doc/jucs04.pdf"><em>Coroutines in
Lua</em></a>)</p>

<ol>
  <li>The values of data local to a coroutine persist between successive calls.</li>
  <li>The execution of a coroutine is suspended as control leaves it, only to
carry on where it left off when control re-enters the coroutine at some
later stage.</li>
</ol>

<p>The first characteristic means coroutines can be resumed from where it paused.</p>

<p>In the second characteristic, “as control leaves it” means it is the programmer
that decides <em>where</em> to pause a coroutine, not the implicit scheduler.  Control
flow is part of a program, not the runtime.</p>

<p>For this reason, the “fibers” in Ruby, the “generators” in Python, the
“threads” in Lua, and the “user contexts” in the <code class="language-plaintext highlighter-rouge">swapcontext</code> POSIX API are all
coroutines, despite not being called “coroutines”.  The programmer explicitly
transfers control from one to another.</p>

<p>On the other hand, a “goroutine” in the Go programming language is not a
coroutine, despite the similar name.  In fact, <a href="https://golang.google.cn/ref/spec#Go_statements">the official document</a>
defines a “goroutine” as “an independent concurrent thread of control”, i.e. a
thread.</p>

<p><small>Note: Goroutine is a threading mechanism implemented in the user space,
an “M × N” green thread system. The Go runtime schedules M goroutines on N native
threads. It is the scheduler that switches a native thread between different
goroutines at unspecified time and locations, usually when IO operations may
block, or when queues are full or empty.  To the programmer, a goroutine is just
like a thread: it keeps going forward.  It may block, but not because the
programmer asked it to yield, but because some requests cannot be satisfied,
such as queues and IO. </small></p>

<p>Coroutines are not mutually exclusive with threads.  Each thread is executing
one coroutine at a time, and each thread may jump from one coroutine to another
according to the control flow in the program.</p>

<h2 id="symmetric-and-asymmetric-coroutines">Symmetric and asymmetric coroutines.</h2>

<p>With <em>symmetric</em> coroutines, all coroutines are equal.  A thread can jump from
any coroutine to any other coroutine.  When switching, the programmer always
needs to specify which coroutine to jump to, i.e. destination.</p>

<p>With <em>asymmetric</em> coroutines, coroutines have a parent-child relation.  There
are two different operations that jumps between coroutines, namely <code class="language-plaintext highlighter-rouge">resume</code> and
<code class="language-plaintext highlighter-rouge">yield</code>.  When a thread “resumes” a coroutine, the destination becomes the child
of the source coroutine, until it “yields”, when the thread jumps back from the
child to the parent coroutine.  A coroutine cannot be resumed when it already
has a parent.  When yielding, the programmer doesn’t need to specify the
destination, because the destination is always implicitly the parent coroutine.</p>

<p>Symmetric and asymmetric coroutines have equal expressive power, and they can
implement each other.  See <a href="http://www.lua.org/doc/jucs04.pdf">Coroutines in Lua</a> for more details.</p>

<h2 id="stackful-and-stackless-coroutines">Stackful and stackless coroutines.</h2>

<p>A <em>stackful</em> coroutine has its own execution stack.  A thread can switch
coroutine when the current coroutine has any number of frames on its stack. When
switching, the thread saves the entire stack and switches to a whole new stack
(implementation-wise, it only needs to save registers, change the stack pointer,
and restore registers from the new stack).</p>

<p>A <em>stackless</em> coroutine has only one frame.  Therefore, a coroutine is usually
defined by a “coroutine function”. From my knowledge, all stackless coroutines
are asymmetric.  A coroutine function can only yield within the coroutine
function itself.  That means when a coroutine C1 calls another function F2, the
thread cannot yield from C1 while executing F2;  when a coroutine C1 resumes
another coroutine C2, the thread can only yield from C2 back to C1, but not
directly from C2 to C1’s parent.</p>

<p>Stackful coroutines are more powerful, but need some kind of “swap-stack”
mechanism (see below) to implement.  Stackless coroutines are more restricted,
but does not require swap-stack.</p>

<h2 id="swap-stack">The swap-stack mechanism</h2>

<p>Conceptually, the context of nested function calls is a stack, a
last-in-first-out data structure, called the <em>control stack</em>, often simply
called a <em>stack</em>.</p>

<p>A control stack has many <em>frames</em>.  Each frame contains the execution context of
a function activation, (and this is why a frame is also known as an <em>activation
record</em>).  The context includes the program counter (PC) as well as the values
of local variables.  The top frame is the context of the most recently entered
function, and is the only frame on a stack that is active.  All other frames are
paused at a call site, waiting for the called function (the frame above it) to
return.</p>

<p>In most programming languages, a thread is always bound to one stack. But more
generally, a thread can switch among different stacks.  When a thread switches
from one stack to another, it pauses the top frame as well making the whole
stack paused.  Then it switches its stack pointer to the new stack, and resume
the top frame of the new stack, therefore continue from where that frame was
paused.</p>

<p>This is basically what <em>stackful coroutine</em> does.  Each coroutine has a stack,
which can be paused and resumed.  When resumed, it continues from where it was
paused.</p>

<h3 id="implementing-swap-stack-with-compiler">Implementing swap-stack with compiler</h3>

<p>Implementation-wise, if the language is compiled, it needs a special instruction
sequence that does the following things:</p>

<ol>
  <li>Save live registers on the top of the current stack, and</li>
  <li>set the stack pointer (SP) register to the destination stack, and</li>
  <li>restore the saved registers from the top of the destination stack.</li>
</ol>

<p>The C and C++ programming languages themselves do not have support for
swap-stack.  In practice, we usually rely on libraries or compiler extensions to
do that in C or C++.</p>

<p>Here I give two examples of implementations of swap-stack for compiled code.</p>

<ol>
  <li>
    <p>One is from <a href="https://www.boost.org/doc/libs/1_80_0/libs/context/doc/html/index.html">Boost.Context</a>.  It is implemented as a library in the assembly
language, therefore it has to be platform-specific. Here are the code for
<a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_x86_64_sysv_elf_gas.S">x86-64</a>, <a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_arm64_aapcs_elf_gas.S">ARM64</a> and
<a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_riscv64_sysv_elf_gas.S">RISCV64</a>.  Because it is implemented as a library, it can
only depend on the application binary interface (ABI) of the platform.  In
this case, the assembly code has to conservatively save all callee-saved
registers no matter whether they are still in use or not, because as a
library, it does not have the liveness information the compiler has.</p>
  </li>
  <li>
    <p>The other is an LLVM extension created by <a href="http://dx.doi.org/10.1145/2400682.2400695">Dolan et al.</a>.  As part of
a compiler framework, it can identify and save only live registers, making
it much more efficient than library-based approaches.</p>
  </li>
</ol>

<h3 id="implementing-swap-stack-with-interpreter">Implementing swap-stack with interpreter</h3>

<p>If the language is interpreted, it depends.  An interpreter can be stackful or
stackless, and even stackless interpreters can allow the interpreted functions
to call foreign C functions.</p>

<p>A stackful interpreter uses the native (C) stack to implement function
invocation.  Such interpreters usually has the following form:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">interpret_function</span><span class="p">(</span><span class="n">Frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">current_instruction</span><span class="p">().</span><span class="n">type</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">...:</span>
            <span class="p">...</span>
        <span class="k">case</span> <span class="n">CALL</span><span class="p">:</span>
            <span class="p">...</span>
            <span class="n">Frame</span> <span class="o">*</span><span class="n">new_frame</span> <span class="o">=</span> <span class="n">create_frame</span><span class="p">(</span><span class="n">called_function</span><span class="p">);</span>
            <span class="n">interpret_function</span><span class="p">(</span><span class="n">new_frame</span><span class="p">);</span>  <span class="c1">// Recursive call</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Because a language-level function call corresponds to an interpreter-level
(C-level) function call, each frame in the interpreted language corresponds to a
C frame.  It is difficult to implement swap-stack with stackful interpreter
because it needs to swap out the C stack (which has C frames) in order to swap
out the interpreted language stack.  As we have discussed before, C does not
have native support for swap-stack, and it needs libraries written in assembly
language or compiler extensions to do so.</p>

<p><a id="apdx-sisc"></a></p>

<p>What about stackless interpreters?</p>

<p>A stackless interpreter does not turn language-level function calls into C-level
function calls.  A stackless interpreter usually has the following form:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">interpret_function</span><span class="p">(</span><span class="n">Frame</span> <span class="o">*</span><span class="n">initial_frame</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Frame</span> <span class="o">*</span><span class="n">current_frame</span> <span class="o">=</span> <span class="n">initial_frame</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">current_instruction</span><span class="p">().</span><span class="n">type</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">...:</span>
            <span class="p">...</span>
        <span class="k">case</span> <span class="n">CALL</span><span class="p">:</span>
            <span class="p">...</span>
            <span class="n">Frame</span> <span class="o">*</span><span class="n">new_frame</span> <span class="o">=</span> <span class="n">create_frame</span><span class="p">(</span><span class="n">called_function</span><span class="p">);</span>
            <span class="n">new_frame</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">;</span>
            <span class="n">current_frame</span> <span class="o">=</span> <span class="n">new_frame</span><span class="p">;</span>  <span class="c1">// Only replace the frame pointer</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A stackless interpreter always remains in the single <code class="language-plaintext highlighter-rouge">interpret_function</code>
function activation even when the interpreted language program makes a call.
Swap-stack is relatively easier to implement with stackless interpreter,
because it does not need to swap out any C frames…</p>

<p>… unless it allows foreign function calls.  If the stackless interpreter
allows the interpreted language to call foreign C functions, then C functions
must have frames on some stack.  Then we face the same problem as implementing
swap-stack for compiled languages.</p>

<h3 id="the-mu-micro-virtual-machine">The Mu micro virtual machine</h3>

<p>I designed the <a href="https://microvm.github.io/">Mu micro virtual machine</a>, and it is the main part of <a href="https://wks.github.io/downloads/pdf/wang-thesis-2018.pdf">my
PhD thesis</a>.  Swap-stack is a very important mechanism of the Mu
micro VM, and it is designed to be supported by the JIT compiler.  It enables
the implementation of symmetric stackful coroutines, and it is the foundation of
other VM mechanisms, such as trapping and <a href="https://wks.github.io/downloads/pdf/osr-vee-2018.pdf">on-stack replacement
(OSR)</a>.  If you are interested, read
<a href="https://wks.github.io/downloads/pdf/wang-thesis-2018.pdf#subsection.5.3.6">Section 5.3.6</a> of <a href="https://wks.github.io/downloads/pdf/wang-thesis-2018.pdf">my thesis</a>.</p>

<h2 id="function-to-state-machine">Decomposing a function into a state machine</h2>

<p>Interpreters usually have no problem saving the frame of a function at a <code class="language-plaintext highlighter-rouge">yield</code>
point so that it can be resumed later.  The interpreter can implement the layout
of stack frames and the behaviour of function calls / coroutine resumption in
any way it wants.  They may even allocate frames in the heap so that they can
temporarily remove a frame from the stack and put it back later. For compilers,
if swap-stack is available, one thread can just save the register states on one
stack and restore them from another stack. Without swap-stack, however, it may
be a challenge.</p>

<p>One way to implement pause-able and resume-able functions is decomposing a
function into a state machine.  Each <code class="language-plaintext highlighter-rouge">yield</code> point becomes a state, and a
function starts by matching the state and jumping to the right place.</p>

<p>For example, assume the <code class="language-plaintext highlighter-rouge">yield()</code> call represents a coroutine yield in the
following C pseudo-code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Long</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">yield</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"time</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">yield</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"no</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">yield</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"see</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Such a function can be transformed into a function that takes a state when
called, and returns a new state when yielding or returning.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">State</span> <span class="p">{</span>
    <span class="n">START</span><span class="p">,</span> <span class="n">STATE1</span><span class="p">,</span> <span class="n">STATE2</span><span class="p">,</span> <span class="n">STATE3</span><span class="p">,</span> <span class="n">END</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">State</span> <span class="nf">foo</span><span class="p">(</span><span class="k">enum</span> <span class="n">State</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">START</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Long</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">STATE1</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">STATE1</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"time</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">STATE2</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">STATE2</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"no</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">STATE3</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">STATE3</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"see</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">END</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">State</span> <span class="n">state</span> <span class="o">=</span> <span class="n">START</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">END</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Resuming foo()...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"foo() paused</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>What about local variables?  Local variables can be packed into the states, too.
C programmers may use the <code class="language-plaintext highlighter-rouge">union</code> type, but it is easier with tagged unions or
object-oriented programming.</p>

<p>Suppose we have a (pseudo) Rust function where <code class="language-plaintext highlighter-rouge">yield!()</code> represents a coroutine
yield.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">square_sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Future</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"a * a = {}"</span><span class="p">,</span> <span class="n">a2</span><span class="p">);</span>
    <span class="k">yield</span><span class="o">!</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"b * b = {}"</span><span class="p">,</span> <span class="n">b2</span><span class="p">);</span>
    <span class="k">yield</span><span class="o">!</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a2</span> <span class="o">+</span> <span class="n">b2</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"result = {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can use an <code class="language-plaintext highlighter-rouge">enum</code> to hold <em>live</em> (will be used later) local variables at each
<code class="language-plaintext highlighter-rouge">yield!()</code> point.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre><span class="cd">/// Note: each state holds the live local variables.</span>
<span class="k">enum</span> <span class="n">State</span> <span class="p">{</span>
    <span class="n">Start</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
    <span class="n">State1</span> <span class="p">{</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">a2</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>  <span class="c1">// Note: a is no longer useful.</span>
    <span class="n">State2</span> <span class="p">{</span> <span class="n">a2</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b2</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span> <span class="c1">// Note: neither a nor b are useful now.</span>
    <span class="n">End</span> <span class="p">{</span> <span class="n">result</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
<span class="p">}</span>

<span class="cd">/// Calling this function merely gets the initial state.</span>
<span class="cd">/// It doesn't actually execute the body of the original function.</span>
<span class="k">fn</span> <span class="nf">square_sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">State</span> <span class="p">{</span>
    <span class="nn">State</span><span class="p">::</span><span class="n">Start</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Call this for each step.</span>
<span class="k">fn</span> <span class="nf">square_sum_step</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">State</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">State</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">state</span> <span class="p">{</span>
        <span class="nn">State</span><span class="p">::</span><span class="n">Start</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="c1">// Restore local variables from the state.</span>
            <span class="k">let</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"a * a = {}"</span><span class="p">,</span> <span class="n">a2</span><span class="p">);</span>
            <span class="nn">State</span><span class="p">::</span><span class="n">State1</span> <span class="p">{</span> <span class="n">b</span><span class="p">,</span> <span class="n">a2</span> <span class="p">}</span> <span class="c1">// Save useful local variables into state.</span>
        <span class="p">}</span>

        <span class="nn">State</span><span class="p">::</span><span class="n">State1</span> <span class="p">{</span> <span class="n">b</span><span class="p">,</span> <span class="n">a2</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="c1">// restore</span>
            <span class="k">let</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"b * b = {}"</span><span class="p">,</span> <span class="n">b2</span><span class="p">);</span>
            <span class="nn">State</span><span class="p">::</span><span class="n">State2</span> <span class="p">{</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span> <span class="p">}</span> <span class="c1">// save</span>
        <span class="p">}</span>

        <span class="nn">State</span><span class="p">::</span><span class="n">State2</span> <span class="p">{</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="c1">// restore</span>
            <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a2</span> <span class="o">+</span> <span class="n">b2</span><span class="p">;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"result = {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
            <span class="nn">State</span><span class="p">::</span><span class="n">End</span> <span class="p">{</span> <span class="n">result</span> <span class="p">}</span> <span class="c1">// save</span>
        <span class="p">}</span>

        <span class="nn">State</span><span class="p">::</span><span class="n">End</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Coroutine already finished!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">state</span> <span class="o">=</span> <span class="nf">square_sum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">state</span> <span class="p">{</span>
            <span class="nn">State</span><span class="p">::</span><span class="n">End</span> <span class="p">{</span> <span class="n">result</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Execution finished. Result is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Resuming..."</span><span class="p">);</span>
                <span class="n">state</span> <span class="o">=</span> <span class="nf">square_sum_step</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Yielded."</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="async-await">Asynchronous programming (async/await) and coroutines</h2>

<p>In asynchronous programming, a program consists of many tasks that can be
completed in the future, and one task can wait for other tasks to complete
before continuing.  There are many ways to implement asynchronous programming.
It can be trivially executed inline (e.g. the X10 compiler is <a href="https://x10.sourceforge.net/documentation/intro/latest/html/node4.html#SECTION00410000000000000000">allowed to
inline</a> an async activity), executed sequentially, using threads, or
using coroutines.</p>

<p>The notion of “Future” and its friend “Promise” are well-known in multi-thread
programming (<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/Future.html">C++</a>, <a href="https://en.cppreference.com/w/cpp/thread/future">Java</a>, <a href="https://learn.microsoft.com/en-us/cpp/standard-library/future-class">C#</a> and
<a href="https://docs.python.org/3/library/concurrent.futures.html#future-objects">Python</a>).  A pair of Future and Promise represents a value yet
to be produced.  The Future waits for the value to be produced, and the Promise
is a place to store the value to be acquired via the Future.  C++ even has the
<a href="https://en.cppreference.com/w/cpp/thread/async"><code class="language-plaintext highlighter-rouge">std::async</code></a> function in the standard library to launch an
asynchronous task in a new thread.</p>

<p>Recently many programming languages employed a style of asynchronous programming
language based on coroutines in the form of async/await.  I guess the reason
behind its gaining popularity is two fold:</p>

<ol>
  <li>
    <p>Native, OS-provided threads are too heavy-weight, but not many programming
languages support light-weight “M × N” green threads, that is, M OS threads
are multiplexed to run N application-level threads and N ≫ M.  AFAIK, only
Erlang and Go supports such light-weight threads.</p>
  </li>
  <li>
    <p>Not many languages support stackful coroutines.  As we discussed before,
stackful coroutines are only practical with swap-stack. Some languages (such
as Kotlin) are targeted to runtimes (such as JVM) that don’t support
swap-stack.</p>
  </li>
</ol>

<p>As a compromise, some languages resorted to coroutines.  They attempted to
implement cooperative multi-tasking using coroutines that yield when they are
about to block, and a scheduler that decides which coroutine can continue
without blocking.  And there is async/await.</p>

<p>A function can be annotated with the <code class="language-plaintext highlighter-rouge">async</code> keyword.  An async function is
like a Python generator.  When called, it doesn’t execute the body of the
function immediately, but will create an object that holds the execution context
of the function, like a frame.  An async function may contain <code class="language-plaintext highlighter-rouge">await</code>
expressions.  An <code class="language-plaintext highlighter-rouge">await</code> is like a conditional <code class="language-plaintext highlighter-rouge">yield</code>.  If a given <code class="language-plaintext highlighter-rouge">Future</code> is
ready, then grab the value and continue; otherwise, suspend the execution and
give control to the scheduler so that it can find something else to execute.</p>

<p>Async and await gives the programmer the feeling of multi-thread programming
except that the programmer must explicitly annotate places that may
<em>potentially</em> yield with <code class="language-plaintext highlighter-rouge">await</code>.</p>

<p>You can find an async/await example in JavaScript earlier in this post.  It
looks pretty like two threads communicating with each other using a channel.</p>

<h3 id="consequence-of-being-stackless">Consequence of being stackless</h3>

<p>Without proper swap-stack support, the compiler has to implement coroutines by
decomposing <code class="language-plaintext highlighter-rouge">async</code> functions into state machines.  <code class="language-plaintext highlighter-rouge">await</code> expressions are
places the function may yield, and each <code class="language-plaintext highlighter-rouge">await</code> represents a state in the state
machine.</p>

<p>However, async/await is not the only way to implement cooperative multi-task
programming on top of coroutines.  <a href="http://www.gevent.org/index.html">gevent</a> is a Python framework based on
<a href="https://greenlet.readthedocs.io/en/latest/index.html">Greenlets</a> which implement symmetric coroutines.  With the ability to
switch coroutine at any level of stack, each coroutine can yield to the
scheduler as part of potentially blocking functions (such as sleeping, IO
operations, etc.), and programmers do not need to annotate any expression with
<code class="language-plaintext highlighter-rouge">await</code>.</p>

<!--
vim: tw=80
-->



  <small>tags: <em>coroutine,rosettacode</em></small>


<script type="text/javascript">
$(document).ready(function() {
    $('#table-of-contents').toc({
        title: "",
        showEffect: 'none'
    });

    $('#toc-toggle').click(function() {
        $('#table-of-contents').toggle();
        return false;
    });
});
</script>

      </section>
    </div>
  </body>
</html>
