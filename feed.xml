<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-02-11T07:23:29+00:00</updated><id>/feed.xml</id><title type="html">Kunshan Wang</title><subtitle>Kunshan Wang&apos;s Personal Web Site</subtitle><author><name>Kunshan Wang</name></author><entry><title type="html">MMTk in An Ancient Wuxia World</title><link href="/blog/2023/01/28/lspgdx-with-mmtk.html" rel="alternate" type="text/html" title="MMTk in An Ancient Wuxia World" /><published>2023-01-28T00:00:00+00:00</published><updated>2023-01-28T00:00:00+00:00</updated><id>/blog/2023/01/28/lspgdx-with-mmtk</id><content type="html" xml:base="/blog/2023/01/28/lspgdx-with-mmtk.html"><![CDATA[<p>TL;DR: During last Christmas, I tried to run <a href="https://gitlab.com/m210/LSPGDX">LSPGDX</a>, a 3D FPS game implemented
in Java using OpenJDK with the MMTk binding.  It worked, but not perfectly.  GC
pauses are still a problem.</p>

<p><em>Disclaimer: This is not part of the research of the <a href="https://www.mmtk.io/">MMTk</a> project, and is not
sponsored by the Australian National University or Shopify.</em></p>

<h1 id="the-first-fps-game-i-played">The first FPS game I played</h1>

<p>When I was nine or ten years old, I played a PC game named
“摇滚少林系列之七侠五义3D”, or “Rock’n’Shaolin: Legend of the Seven Paladins 3D”
(abbreviated as “L7P” or “LSP”).  That was the first first-person shooting (FPS)
game I played.  That was an unusual FPS game because of its Chinese <a href="https://en.wikipedia.org/wiki/Wuxia">Wuxia</a>
theme.  Instead of using guns, the player fights using ancient Chinese weapons
and “qigong”, a powerful martial art that launches fireballs at the enemies.</p>

<p><img src="/assets/img/l7p-title.png" alt="Title screen" />
<img src="/assets/img/l7p-gameplay.png" alt="L7P Game Play (melee)" />
<img src="/assets/img/l7p-gameplay3.png" alt="L7P Game Play (qigong)" /></p>

<p>The game was released in 1990s and, like many games of that era, it ran on DOS.
However, many games of that era (such as Doom and Duke Nukem 3D) also released
the source code of their game engines so that developers could port the games to
modern platforms.  Such ports are called <a href="https://en.wikipedia.org/wiki/Source_port">source ports</a>.  For
example, <a href="https://www.zdoom.org/index">zdoom</a> is a port of Doom’s “id Tech 1” engine, and <a href="https://www.eduke32.com/">eduke32</a> is a port
of Duke3D’s “Build” engine.  Those ports allow us to play those 1990s games on
modern GNU/Linux, MacOS, Windows, and many operating systems and hardwares you
can imagine.</p>

<p>I wondered if there is a source port for the Legend of the Seven Paladins 3D,
too.  Fortunately, there is.</p>

<p>During Christmas last year, I found the <a href="https://gitlab.com/m210/BuildGDX">BuildGDX</a> project and <a href="https://m210.duke4.net/">many other
projects developed by M210</a>.  <a href="https://gitlab.com/m210/BuildGDX">BuildGDX</a> is a port of the Build
engine written in Java, and there are also ports of many Build engine games,
such as DukeGDX for Duke Nukem 3D, WangGDX for Shadow Warrior, BloodGDX for
Blood, and <a href="https://gitlab.com/m210/LSPGDX">LSPGDX</a> for L7P.  It ended up that L7P was also built on the Build
engine, and it was surprisingly the first game based on (an unreleased version
of) the Build engine!</p>

<p>I cloned the repositories, converted the Eclipse projects to Idea projects,
worked around some issues, and I managed to run it on my laptop, with ArchLinux
and OpenJDK 19.  Here is a screenshot.  Note that LSPGDX changed the HUD a
little bit to adapt to modern high-resolution displays.  The game window was a
bit small, though, because I hadn’t figured out how to change the window size by
then.</p>

<p><img src="/assets/img/lspgdx-gameplay.png" alt="LSPGDX game play" /></p>

<h1 id="can-it-run-with-mmtk">Can it run with MMTk?</h1>

<p>Since it ran on OpenJDK, an immediate question came to my mind: “Does it run
with MMTk?”  My colleagues and I have been actively maintaining <a href="https://github.com/mmtk/mmtk-openjdk/">mmtk-openjdk</a>,
the OpenJDK VM binding of MMTk.  In version 10, OpenJDK refactored its GC
framework and introduced a GC interface, making it easy to plug in new GC
algorithms.  Our MMTk binding implements that interface and allows OpenJDK to
use any GC algorithms MMTk provides.  It should be a drop-in replacement for its
GC.</p>

<p>And it actually worked.  After fixing some <a href="https://github.com/mmtk/mmtk-openjdk/pull/191">issues about soft
references</a>, LSPGDX ran on OpenJDK 11 with the MMTk
binding.</p>

<p><img src="/assets/img/lspgdx-mmtk-1.png" alt="LSPGDX title screen with MMTk" /></p>

<p>Pay attention to the log output <code class="language-plaintext highlighter-rouge">[...  INFO mmtk::plan::global] User triggering
collection</code>. That was produced by MMTk core, and that meant the VM was actually
using MMTk.</p>

<p>I gave it a 128MB heap.  (That was way too generous.  Back in the DOS era, that
game ran with 4MB of total memory!)  The game manually triggers a GC during
start-up and another time when loading a saved game.</p>

<p><img src="/assets/img/lspgdx-mmtk-2.png" alt="LSPGDX game play with MMTk" /></p>

<p>As the player walked in the corridors, it only triggered GC once every half
minutes.  The game lagged a little bit when GC happens, but was hardly
noticeable.</p>

<p>However, when entering an area with a lot of enemies, like this one…</p>

<p><img src="/assets/img/lspgdx-fight.png" alt="Fighting many enemies" /></p>

<p>… it started to trigger GC once every several seconds.  What was worse, every
GC froze the game for about 3 seconds.  Note the timestamp of the log messages
“Triggering collection” and “End of GC” in the following screenshot.</p>

<p><img src="/assets/img/lspgdx-mmtk-3.png" alt="MMTk sometimes has very long GC pause" /></p>

<p>I stopped the game because the frequent GC pauses made the game unplayable.</p>

<p>The GC algorithm I chose was Immix, a high-throughput but non-generational
non-concurrent GC. There was a bug by then that prevented Generational Immix
from running.  But even if the GC was generational, once a full-heap GC
happened, it would just take as long as this one.</p>

<p>This experiment showed that GC latency matters for game applications.  And MMTk
does have a concurrent GC algorithm.  The concurrent <a href="https://users.cecs.anu.edu.au/~steveb/pubs/papers/lxr-pldi-2022.pdf">LXR</a> GC algorithm was
published last year, but has not been merged into the mainline MMTk core, yet.
I’ll probably try playing LSPGDX with MMTk again when LXR stablises.</p>

<h1 id="my-forks">My forks</h1>

<p>Since then, I have been hacking BuildGDX and LSPGDX to fix bugs and enhance the
gameplay.  If you are interested, you can clone my repositories on GitLab.</p>

<ul>
  <li>BuildGDX: <a href="https://gitlab.com/wks/BuildGDX">https://gitlab.com/wks/BuildGDX</a></li>
  <li>LSPGDX: <a href="https://gitlab.com/wks/LSPGDX">https://gitlab.com/wks/LSPGDX</a></li>
</ul>

<!--
vim: tw=80
-->]]></content><author><name>Kunshan Wang</name></author><category term="blog" /><category term="mmtk" /><category term="l7p" /><summary type="html"><![CDATA[TL;DR: During last Christmas, I tried to run LSPGDX, a 3D FPS game implemented in Java using OpenJDK with the MMTk binding. It worked, but not perfectly. GC pauses are still a problem.]]></summary></entry><entry><title type="html">Chris Seaton passed away</title><link href="/blog/2022/12/08/chris-seaton-passed-away.html" rel="alternate" type="text/html" title="Chris Seaton passed away" /><published>2022-12-08T00:00:00+00:00</published><updated>2022-12-08T00:00:00+00:00</updated><id>/blog/2022/12/08/chris-seaton-passed-away</id><content type="html" xml:base="/blog/2022/12/08/chris-seaton-passed-away.html"><![CDATA[<p>I am very sad to heard about the death of <a href="https://chrisseaton.com/">Chris Seaton</a>, our collaborator.</p>

<p><a href="https://www.shopify.com">Shopify</a> generously sponsored the <a href="https://www.mmtk.io/">MMTk</a> project to develop <a href="https://github.com/mmtk/mmtk-ruby">mmtk-ruby</a>, a VM
binding that enables <a href="https://www.ruby-lang.org/">Ruby</a> to use MMTk as its garbage collector, and Chris has
been the person actively working with us.  Over the past few years, he has
provided support for Angus Atkinson, the initial developer of mmtk-ruby, and me
who continued the development of mmtk-ruby after Angus.  Although we never met
in person, I received great help from him during regular online meetings. He
helped me getting familiar with the Ruby runtime with which I had no prior
experience, and provided suggestions handling impedance mismatches between MMTk
and Ruby.  While I focused on getting MMTk to work, he helped with adding
MMTk-related version flags, command-line options and other ergonomics.  He fixed
tests and set up a nightly build server.  He helped identifying bugs in MMTk and
its API.  He also helped promoting our project, letting the community know our
effort of improving Ruby with a powerful GC framework.</p>

<p>Sadly, Chris is no longer with us.  It is a great loss for the MMTk project as
well as the whole programming language and virtual machine community.</p>

<!--
vim: tw=80
-->]]></content><author><name>Kunshan Wang</name></author><category term="blog" /><category term="mmtk" /><category term="ruby" /><summary type="html"><![CDATA[I am very sad to heard about the death of Chris Seaton, our collaborator.]]></summary></entry><entry><title type="html">Traversing nested lists with coroutines, Rosetta Code style</title><link href="/blog/2022/09/22/coroutine-flatten.html" rel="alternate" type="text/html" title="Traversing nested lists with coroutines, Rosetta Code style" /><published>2022-09-22T00:00:00+00:00</published><updated>2022-09-22T00:00:00+00:00</updated><id>/blog/2022/09/22/coroutine-flatten</id><content type="html" xml:base="/blog/2022/09/22/coroutine-flatten.html"><![CDATA[<p>I’ll try to use <strong>coroutines</strong> to traverse nested lists, Rosetta Code style.
That means I’ll do it in many different programming languages and libraries,
including Ruby, Lua, Python (including greenlets), JavaScript, Rust, C#, etc.
This task shows the difference between <em>symmetric</em> vs <em>asymmetric</em> coroutines,
and <em>stackful</em> vs <em>stackless</em> coroutines.</p>

<p>Note that this post alone may not be enough to teach you how to use coroutines
in all those languages.</p>

<p>I’ll also provide basic information about coroutines, swap-stack, async/await,
etc. in the appendices.</p>

<!--more-->

<h1 id="the-task">The task</h1>

<p><strong>Input</strong>:</p>

<ul>
  <li>a nested list of numbers, such as <code class="language-plaintext highlighter-rouge">[1, [[2, 3], [4, 5]], [6, 7, 8]]</code></li>
</ul>

<p><strong>Output</strong>:</p>

<ul>
  <li>
    <p>recursively output all numbers in the list.  At each level, visit all
numbers in one element before visiting any subsequent elements.</p>

    <p>When given the list above, the output should be 1, 2, 3, 4, 5, 6, 7 and
8, in that order.</p>
  </li>
</ul>

<p><strong>Requirement</strong>:</p>

<ul>
  <li>Use coroutine(s) to enumerate a nested list, and yield elements to the
calling coroutine one at a time.</li>
</ul>

<p>I will try to do this task using as many programming languages as possible,
<a href="https://rosettacode.org/wiki/Rosetta_Code">Rosetta Code</a> style, to compare their coroutine syntax and API.
At the time of writing (2022), different programming languages still differ
greatly w.r.t. the design of coroutines.</p>

<h1 id="the-code">The code</h1>

<h2 id="ruby-fibers-stackful-both-asymmetric-and-symmetric">Ruby fibers (stackful, both asymmetric and symmetric)</h2>

<p><a href="https://docs.ruby-lang.org/en/3.1/Fiber.html">Fibers</a> are “primitives for implementing light weight cooperative
concurrency in Ruby”.</p>

<p>Ruby fibers are stackful.  According to the <a href="https://docs.ruby-lang.org/en/3.1/Fiber.html">documentation</a>:</p>

<blockquote>
  <p>As opposed to other stackless light weight concurrency models, each fiber
comes with a stack. This enables the fiber to be paused from deeply nested
function calls within the fiber block.</p>
</blockquote>

<p>Ruby fibers can operate in both asymmetric and symmetric mode.  I’ll demonstrate
the task in both modes below.</p>

<h3 id="asymmetric">Asymmetric</h3>

<p>The <a href="https://docs.ruby-lang.org/en/3.1/Fiber.html#method-i-resume"><code class="language-plaintext highlighter-rouge">Fiber#resume</code></a> instance method resumes a fiber, and a subsequent call to
the <a href="https://docs.ruby-lang.org/en/3.1/Fiber.html#method-c-yield"><code class="language-plaintext highlighter-rouge">Fiber.yield</code></a> class method jumps back to the resumer.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Array</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span>
      <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>      <span class="c1"># recursive call</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span> <span class="n">x</span>         <span class="c1"># can yield within recursive calls</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">fiber_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">StopIteration</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">fiber</span> <span class="o">=</span> <span class="n">fiber_traverse</span> <span class="no">DATA</span>

<span class="kp">loop</span> <span class="k">do</span>   <span class="c1"># Break if StopIteration is raised.</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">fiber</span><span class="p">.</span><span class="nf">resume</span>
  <span class="nb">puts</span> <span class="n">value</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <a href="https://docs.ruby-lang.org/en/3.1/Enumerator.html"><code class="language-plaintext highlighter-rouge">Enumerator</code></a> class can automatically transform
block-based visiting functions into fiber-based coroutine.  It uses fiber only
when necessary.  It uses fiber when used as external iterators (calling <code class="language-plaintext highlighter-rouge">e.next</code>
explicitly), but still uses call-back for internal iteration (<code class="language-plaintext highlighter-rouge">e.each { |v| ...
}</code>).</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Array</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span>
      <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># This is just a usual method call, not a coroutine yield.</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">enum_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="no">Enumerator</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">yielder</span><span class="o">|</span>   <span class="c1"># The yielder encapsulates how to yield.</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
      <span class="n">yielder</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>      <span class="c1"># This may or may not use coroutine yield.</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="c1"># We can do internal iteration</span>
<span class="n">enum_traverse</span><span class="p">(</span><span class="no">DATA</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>   <span class="c1"># use call-back</span>
  <span class="nb">puts</span> <span class="n">value</span>
<span class="k">end</span>

<span class="c1"># and external iteration too.</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">enum_traverse</span><span class="p">(</span><span class="no">DATA</span><span class="p">)</span>
<span class="kp">loop</span> <span class="k">do</span>           <span class="c1"># Break if StopIteration is raised.</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="nf">next</span>  <span class="c1"># This will use fiber.</span>
  <span class="nb">puts</span> <span class="n">value</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="symmetric">Symmetric</h3>

<p>The <a href="https://docs.ruby-lang.org/en/3.1/Fiber.html#method-i-transfer"><code class="language-plaintext highlighter-rouge">Fiber#transfer</code></a> method can switch to any fiber, but always needs an
explicit fiber to switch to.  We can pass the current fiber to the new fiber
when we create it, so it can remember which fiber to transfer back to.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="nb">require</span> <span class="s2">"fiber"</span> 

<span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Array</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span>
      <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>  <span class="c1"># always remember the parent</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">parent</span><span class="p">.</span><span class="nf">transfer</span> <span class="n">x</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">fiber_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">current</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">current</span>     <span class="c1"># get the current fiber</span>
  <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>      <span class="c1"># pass the fiber as parent</span>
    <span class="k">raise</span> <span class="no">StopIteration</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">fiber</span> <span class="o">=</span> <span class="n">fiber_traverse</span> <span class="no">DATA</span>
<span class="kp">loop</span> <span class="k">do</span>   <span class="c1"># Break if StopIteration is raised.</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">fiber</span><span class="p">.</span><span class="nf">transfer</span>
  <span class="nb">puts</span> <span class="n">value</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="lua-threads-stackful-asymmetric">Lua threads (stackful, asymmetric)</h2>

<p>Lua “threads” are stackful coroutines.  Lua has a stackless interpreter,
therefore it can easily implement stackful coroutines (Why? See
<a href="#apdx-sisc">appendix</a>).</p>

<p>Lua provides asymmetric coroutines (with limitations) for the sake of
<em>simplicity</em> and <em>portability</em>.</p>

<ul>
  <li>
    <p><strong>Simplicity</strong>: According to <a href="http://www.lua.org/doc/jucs04.pdf"><em>Coroutines in Lua</em></a>, asymmetric
coroutines may be easier to understand.</p>

    <blockquote>
      <p>On the other hand, asymmetric coroutines truly behave like routines, in
  the sense that control is always transferred back to their callers. Since
  even novice programmers are familiar with the concept of a routine,
  control sequencing with asymmetric coroutines seems much simpler to manage
  and understand, besides allowing the development of more structured
  programs</p>
    </blockquote>
  </li>
  <li>
    <p><strong>Portability</strong>: Supporting symmetric coroutines (or even proper stackful
asymmetric coroutines) will require C to have coroutine facilities, such as
<a href="#swap-stack">swap-stack</a>, which is not always available. According to <a href="http://www.lua.org/doc/jucs04.pdf"><em>Coroutines in
Lua</em></a>:</p>

    <blockquote>
      <p>Lua and C code can freely call each other; therefore, an application can
  create a chain of nested function calls wherein the languages are
  interleaved. Implementing a symmetric facility in this scenario imposes
  the preservation of C state when a Lua coroutine is suspended. This
  preservation is only possible if a coroutine facility is also provided for
  C; but a portable implementation of coroutines for C cannot be written.</p>
    </blockquote>

    <p>Lua also added a limitation: <em>a coroutine cannot yield while there are C
function frames on its stack</em>.  Otherwise, Lua would require a <a href="#swap-stack">swap-stack</a>
mechanism for C, making Lua less portable.</p>
  </li>
</ul>

<p>In Lua, the <a href="http://www.lua.org/manual/5.4/manual.html#pdf-coroutine.resume"><code class="language-plaintext highlighter-rouge">coroutine.resume</code></a> function continues the execution of a
coroutine, and <a href="http://www.lua.org/manual/5.4/manual.html#pdf-coroutine.yield"><code class="language-plaintext highlighter-rouge">coroutine.yield</code></a> jumps back to the calling coroutine.</p>

<figure class="highlight"><pre><code class="language-lua" data-lang="lua"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="k">function</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"table"</span> <span class="k">then</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="k">in</span> <span class="nb">ipairs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">traverse</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>         <span class="c1">-- recursive call</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>    <span class="c1">-- can yield within recursive calls</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">function</span> <span class="nf">coroutine_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">list</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="p">{{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}},</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}}</span>

<span class="kd">local</span> <span class="n">coro</span> <span class="o">=</span> <span class="n">coroutine_traverse</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>

<span class="k">while</span> <span class="kc">true</span> <span class="k">do</span>
  <span class="kd">local</span> <span class="n">_</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">nil</span> <span class="k">then</span>
    <span class="k">break</span>   <span class="c1">-- terminated</span>
  <span class="k">end</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <a href="http://www.lua.org/manual/5.4/manual.html#pdf-coroutine.wrap"><code class="language-plaintext highlighter-rouge">coroutine.wrap</code></a> function can wrap the coroutine into an iterator
function suitable for the <a href="http://www.lua.org/manual/5.4/manual.html#3.3.5">generic <code class="language-plaintext highlighter-rouge">for</code> statement</a>.</p>

<figure class="highlight"><pre><code class="language-lua" data-lang="lua"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">function</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"table"</span> <span class="k">then</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="k">in</span> <span class="nb">ipairs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">traverse</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">function</span> <span class="nf">coroutine_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">coroutine.wrap</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">list</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="p">{{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}},</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}}</span>

<span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">coroutine_traverse</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="k">do</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="python-generators-stackless-asymmetric">Python generators (stackless, asymmetric)</h2>

<p>Python generators are a built-in feature since Python 2.x.  They are
single-frame coroutines.</p>

<p>A function that contains a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-yield_expression"><code class="language-plaintext highlighter-rouge">yield</code></a> keyword is considered a
generator function.  Calling a generator function will create a new generator
object stopped at the beginning of the function, and can be resumed with the
<a href="https://docs.python.org/3/library/functions.html#next"><code class="language-plaintext highlighter-rouge">next(...)</code></a> built-in function.</p>

<p>Being stackless, each coroutine has only one frame, so it cannot yield while
calling another function.  To implement recursive traversal with stackless
coroutines, it is common to create one generator for each level of nested list,
and yield values from the innermost coroutine to the outer coroutine, level by
level.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">new_gen</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>    <span class="c1"># Create the next level of generator
</span>            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">new_gen</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">v</span>             <span class="c1"># Yield everything the inner generator yields
</span>            <span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>       <span class="c1"># until iteration stops.
</span>                <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>

<span class="n">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">gen</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>    <span class="c1"># The top-level generator
</span><span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>   <span class="c1"># Iterate through it
</span>        <span class="k">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>   <span class="c1"># until iteration stops.
</span>    <span class="k">pass</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Python’s <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement"><code class="language-plaintext highlighter-rouge">for</code></a> statement is a syntax sugar for calling <code class="language-plaintext highlighter-rouge">next(...)</code>
until the exception <a href="https://docs.python.org/3/library/exceptions.html#StopIteration"><code class="language-plaintext highlighter-rouge">StopIteration</code></a> is thrown.  The <a href="https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement"><code class="language-plaintext highlighter-rouge">yield
from</code></a> statement is a syntax sugar for yielding everything from
another generator.  Using all the syntax sugar, the code above will become the
following:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>   <span class="c1"># Use "yield from" to yield everything.
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>

<span class="n">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">traverse</span><span class="p">(</span><span class="n">DATA</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="python-coroutines-wtf">Python coroutines (WTF?)</h2>

<p>Python 3.5 attempts to introduce <a href="#async-await">async/await</a>-based asynchronous programming
mechanisms, but it used the word “<a href="https://docs.python.org/3/reference/compound_stmts.html#coroutines">coroutine</a>” to refer to
functions annotated with the <code class="language-plaintext highlighter-rouge">async</code> keyword, like <code class="language-plaintext highlighter-rouge">async def foo(...)</code>, which
is confusing.  Async functions may contain the new <a href="https://docs.python.org/3/reference/expressions.html#await"><code class="language-plaintext highlighter-rouge">await</code></a>
expression, but its semantics is <a href="https://docs.python.org/3/reference/expressions.html#await">very vaguely defined</a> as “suspend
the execution of coroutine on an awaitable object”, whatever “on an awaitable
object” means. That is in stark contrast to the highly detailed semantics of
<a href="https://timsong-cpp.github.io/cppwp/n4861/expr.await#5"><code class="language-plaintext highlighter-rouge">co_await</code> expression in C++20</a> and the <a href="https://doc.rust-lang.org/reference/expressions/await-expr.html"><code class="language-plaintext highlighter-rouge">.await</code> expression in
Rust</a>.</p>

<blockquote>
  <p>In the face of ambiguity, refuse the temptation to guess.</p>

  <p><em>– <a href="https://legacy.python.org/dev/peps/pep-0020/">Zen of Python</a></em></p>
</blockquote>

<p>Because it is so confusing, I am not going to do the task using Python
“coroutines”.</p>

<h2 id="python-greenlet-stackful-symmetric">Python greenlet (stackful, symmetric)</h2>

<h3 id="symmetric-1">Symmetric</h3>

<p>The <a href="https://greenlet.readthedocs.io/en/latest/index.html">greenlet</a> library provides stackful symmetric coroutines.</p>

<p>Greenlets are stackful.  According to the <a href="https://greenlet.readthedocs.io/en/latest/greenlet.html">documentation</a>:</p>

<blockquote>
  <p>A “greenlet” is a small independent pseudo-thread. Think about it as a small
stack of frames; the outermost (bottom) frame is the initial function you
called, and the innermost frame is the one in which the greenlet is currently
paused.</p>
</blockquote>

<p>Greenlets are symmetric.  One greenlet can switch to another using the
<a href="https://greenlet.readthedocs.io/en/latest/api.html#greenlet.greenlet.switch"><code class="language-plaintext highlighter-rouge">glet.switch()</code></a> method to pass a value, or
<a href="https://greenlet.readthedocs.io/en/latest/api.html#greenlet.greenlet.throw"><code class="language-plaintext highlighter-rouge">glet.throw()</code></a> to switch and immediately raise an exception.</p>

<p>There are implementations of Greenlets for both CPython and PyPy.</p>

<p>The official greenlet implementation for CPython uses platform-specific assembly
code (for <a href="https://github.com/python-greenlet/greenlet/blob/master/src/greenlet/platform/switch_amd64_unix.h">amd64</a>, <a href="https://github.com/python-greenlet/greenlet/blob/master/src/greenlet/platform/switch_aarch64_gcc.h">aarch64</a>,
<a href="https://github.com/python-greenlet/greenlet/blob/master/src/greenlet/platform/switch_riscv_unix.h">riscv</a>, etc.) to switch native stacks, similar to what
[Boost Context] does.</p>

<p>PyPy <a href="https://doc.pypy.org/en/latest/stackless.html#greenlets">implements the greenlet API</a> using
<a href="https://doc.pypy.org/en/latest/stackless.html#stacklets">stacklets</a>, which are PyPy’s own swap-stack mechanism.  Like
[Boost Context] and the official greenlet for CPython, PyPy also uses
platform-specific assembly code (for <a href="https://foss.heptapod.net/pypy/pypy/-/blob/branch/default/rpython/translator/c/src/stacklet/switch_x86_64_gcc.h">x86-64</a>,
<a href="https://foss.heptapod.net/pypy/pypy/-/blob/branch/default/rpython/translator/c/src/stacklet/switch_aarch64_gcc.h">aarch64</a>, <a href="https://foss.heptapod.net/pypy/pypy/-/blob/branch/default/rpython/translator/c/src/stacklet/switch_mips64_gcc.h">mips64</a>, etc.  Sorry,
RISC-V.) to switch between stacks.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">greenlet</span>

<span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>      <span class="c1"># recursive call
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="n">parent</span><span class="p">.</span><span class="n">switch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                <span class="c1"># can switch at any level of stack
</span>        
<span class="k">def</span> <span class="nf">greenlet_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">greenlet</span><span class="p">.</span><span class="n">getcurrent</span><span class="p">()</span>     <span class="c1"># remember the current coroutine
</span>    <span class="k">def</span> <span class="nf">_traverse_x</span><span class="p">():</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>            <span class="c1"># and pass it as the parent
</span>        <span class="n">current</span><span class="p">.</span><span class="n">throw</span><span class="p">(</span><span class="nb">StopIteration</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">greenlet</span><span class="p">.</span><span class="n">greenlet</span><span class="p">(</span><span class="n">_traverse_x</span><span class="p">)</span>

<span class="n">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">glet</span> <span class="o">=</span> <span class="n">greenlet_traverse</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">glet</span><span class="p">.</span><span class="n">switch</span><span class="p">()</span>   <span class="c1"># switch to the greenlet
</span>        <span class="k">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="emulate-asymmetric-coroutine-using-the-parent-field">Emulate asymmetric coroutine using the <code class="language-plaintext highlighter-rouge">parent</code> field</h3>

<p>We have just demonstrated that greenlets are symmetric.  However, each greenlet
has a <a href="https://greenlet.readthedocs.io/en/latest/greenlet.html#greenlet-parents">parent</a>.  It is the coroutine to switch to when the
current coroutine terminates, normally or by exception.  However, it doesn’t
mean greenlets are asymmetric because the parent can be changed at any time
during execution, and it is not wrong to explicitly <code class="language-plaintext highlighter-rouge">switch</code> to the parent.</p>

<p>We can rewrite our last example and use the <code class="language-plaintext highlighter-rouge">glet.parent</code> field instead of our
own <code class="language-plaintext highlighter-rouge">parent</code> variable to record the parent.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">greenlet</span>

<span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">greenlet</span><span class="p">.</span><span class="n">getcurrent</span><span class="p">().</span><span class="n">parent</span><span class="p">.</span><span class="n">switch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># switch to parent
</span>        
<span class="k">def</span> <span class="nf">greenlet_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_traverse_x</span><span class="p">():</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">raise</span> <span class="nb">StopIteration</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">greenlet</span><span class="p">.</span><span class="n">greenlet</span><span class="p">(</span><span class="n">_traverse_x</span><span class="p">)</span>  <span class="c1"># The parent is the current greenlet
</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">glet</span> <span class="o">=</span> <span class="n">greenlet_traverse</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">glet</span><span class="p">.</span><span class="n">switch</span><span class="p">()</span>   <span class="c1"># switch to the greenlet
</span>        <span class="k">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="javascript-generators-stackless-asymmetric">JavaScript generators (stackless, asymmetric)</h2>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*"><code class="language-plaintext highlighter-rouge">function*</code></a> declaration defines a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">generator
function</a>. Generator functions can have <code class="language-plaintext highlighter-rouge">yield</code> operator that
pauses the execution of the coroutine.</p>

<p>When a generator function called, it creates a generator object.  It can be used
like an iterator.  The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol"><code class="language-plaintext highlighter-rouge">next</code></a> method switches to the coroutine.</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="kd">function</span><span class="o">*</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">elem</span> <span class="k">of</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">y</span> <span class="k">of</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">elem</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="nx">y</span><span class="p">;</span>  <span class="c1">// Yield what the inner layer yields.</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]];</span>

<span class="kd">let</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">DATA</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Resumes the coroutine.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>And there are syntax sugars.  The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*"><code class="language-plaintext highlighter-rouge">yield*</code></a> operator yields
everything from another generator.  Because a generator behaves like an
iterator, the <code class="language-plaintext highlighter-rouge">for-of</code> statement can iterate through the values it yields.</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="kd">function</span><span class="o">*</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">elem</span> <span class="k">of</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span><span class="o">*</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">x</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">DATA</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="javascript-asyncawait-stackless-asymmetric-asynchronous">JavaScript async/await (stackless, asymmetric, asynchronous)</h2>

<p>JavaScript provides asynchronous programming facilities in the form of
<a href="#async-await">async/await</a> (see <a href="#async-await">appendix</a>).  An <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"><code class="language-plaintext highlighter-rouge">async</code>
function</a> always returns a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code class="language-plaintext highlighter-rouge">Promise</code></a> object which
can be settled (fulfilled or rejected) later.  An <code class="language-plaintext highlighter-rouge">async</code> function may contain
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await"><code class="language-plaintext highlighter-rouge">await</code> operators</a> which cause async function execution to pause
until its operand (a <code class="language-plaintext highlighter-rouge">Promise</code>) is settled, and resume execution after
fulfilment.</p>

<p>Asynchronous programming is more like cooperative multi-tasking than coroutines.</p>

<p><a id="async-await-example"></a></p>

<p>Despite the difference, I now give an example of traversing nested lists using
async/await.  I create two concurrent tasks, one traverses the nested list, and
the other prints the numbers, and they communicate through a “zero-capacity
queue”.  It is similar to multi-thread programming, except there is only one
thread executing both tasks in alternation, and the execution is scheduled by a
scheduler.</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="code"><pre><span class="c1">// A zero-capacity queue.</span>
<span class="c1">// `enqueue` will block until another task calls `dequeue`,</span>
<span class="c1">// and `dequeue` will block until another task calls `enqueue`.</span>
<span class="kd">class</span> <span class="nx">ZeroQueue</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">getter_resolver</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setter_resolver</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="p">}</span>

    <span class="k">async</span> <span class="nx">enqueue</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getter_resolver</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If a consumer came before, we satisfy it.</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">getter_resolver</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">getter_resolver</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// If we come first, we leave the value and wait until consumed.</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">num</span>
            <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">setter_resolver</span> <span class="o">=</span> <span class="nx">resolve</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">async</span> <span class="nx">dequeue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">setter_resolver</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If a producer already came, we take the value and let it continue.</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setter_resolver</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setter_resolver</span> <span class="o">=</span> <span class="kc">null</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// If we come first, we wait for the producer.</span>
            <span class="k">return</span> <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">getter_resolver</span> <span class="o">=</span> <span class="nx">resolve</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ZeroQueue</span><span class="p">()</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">elem</span> <span class="k">of</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">await</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// await may potentially yield,</span>
        <span class="c1">// giving the user an impression of block-waiting.</span>
        <span class="k">await</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">print_all</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="c1">// await may potentially yield,</span>
        <span class="c1">// giving the user an impression of block-waiting.</span>
        <span class="kd">const</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">dequeue</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">end</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="c1">// The first task traverses the list and signal termination.</span>
<span class="nx">traverse</span><span class="p">(</span><span class="nx">DATA</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="dl">"</span><span class="s2">end</span><span class="dl">"</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// The second task keep polling till the end.</span>
<span class="nx">print_all</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="javascript-async-generators-stackless-asymmetric-asynchronous">JavaScript async generators (stackless, asymmetric, asynchronous)</h2>

<p>Functions annotated with <code class="language-plaintext highlighter-rouge">async function*</code> defines an async generator function.
An <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator">async generator</a> is like a generator, but the <code class="language-plaintext highlighter-rouge">.next()</code>
method returns a <code class="language-plaintext highlighter-rouge">Promise</code> so it can be awaited.  This allows the generator to
use <code class="language-plaintext highlighter-rouge">await</code> while iterating.  It can also use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of"><code class="language-plaintext highlighter-rouge">for await ... of</code>
statement</a> as a syntax sugar.</p>

<p>This practice is like building coroutine on top of async/await on top of
coroutine, which looks ugly to me.  Anyway, here is the code:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">async</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">elem</span> <span class="k">of</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span><span class="o">*</span> <span class="k">await</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">x</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">DATA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="k">await</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">DATA</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">main</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="rust-asyncawait-stackless-asymmetric-asynchronous">Rust async/await (stackless, asymmetric, asynchronous)</h2>

<p>Rust’s <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code> keywords provides support for <a href="#async-await">asynchronous
programming</a> (see <a href="#async-await">appendix</a>) based on stackless asymmetric
coroutines.  There is <a href="https://rust-lang.github.io/async-book/">a dedicated book</a> that covers
asynchronous programming in Rust.</p>

<p>An <a href="https://doc.rust-lang.org/reference/items/functions.html#async-functions"><code class="language-plaintext highlighter-rouge">async</code> function</a> or an <a href="https://doc.rust-lang.org/reference/expressions/block-expr.html#async-blocks"><code class="language-plaintext highlighter-rouge">async</code> block</a>,
when executed, do not execute their bodies immediately, but creates an object
that holds the execution context of that function or block.  Each async function
or block is represented to the user as a <code class="language-plaintext highlighter-rouge">Future</code>.  The <code class="language-plaintext highlighter-rouge">Future::poll</code> method
will resume the async thing until it yields (on an <code class="language-plaintext highlighter-rouge">await</code> site) or finishes.</p>

<p>The <a href="https://doc.rust-lang.org/reference/expressions/await-expr.html"><code class="language-plaintext highlighter-rouge">await</code> expression</a> can only be used in <code class="language-plaintext highlighter-rouge">async</code> functions or
blocks.  Its semantics is complicated but <a href="https://doc.rust-lang.org/reference/expressions/await-expr.html">well-documented</a>. It
calls <code class="language-plaintext highlighter-rouge">Future::poll</code> on a <code class="language-plaintext highlighter-rouge">Future</code> object and, if the <code class="language-plaintext highlighter-rouge">Future</code> is ready, it
grabs its value continues without yielding; otherwise, it yields from the
current <code class="language-plaintext highlighter-rouge">async</code> function or block.  When resumed, it will poll the <code class="language-plaintext highlighter-rouge">Future</code>
again and may or may not yield depending on whether the <code class="language-plaintext highlighter-rouge">Future</code> is ready.</p>

<p>Implementation-wise, <a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">the documentation suggests</a> that
Rust decomposes an <code class="language-plaintext highlighter-rouge">async</code> function (or block) into a state machine (see
<a href="#function-to-state-machine">appendix</a>) where each state represents an <code class="language-plaintext highlighter-rouge">await</code> site.</p>

<p>Async/await is not supposed to be used like coroutines.  In fact, the book
Asynchronous Programming in Rust <a href="https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html#async-vs-other-concurrency-models">contrasts async/await against
coroutines</a>.  I have given an example in JavaScript
that traverses nested list using async/await using two tasks and a channel.  It
is possible to do the same in Rust, but that’ll need a scheduler.  Since I am
too lazy to write a scheduler or introduce a third-party scheduler, I’ll try a
different approach here.</p>

<p>I’ll abuse the async/await mechanism to exploit its underlying coroutine and
make it behave like a generator.</p>

<ul>
  <li>
    <p><em>Resume</em>: We know that <code class="language-plaintext highlighter-rouge">Future::poll</code> resumes the coroutine.  We call
<code class="language-plaintext highlighter-rouge">Future::poll</code> directly, which is seldom done in usual async/await-based
programs unless we are implementing the “executor” (i.e. scheduler).</p>
  </li>
  <li>
    <p><em>Yield</em>: Each <code class="language-plaintext highlighter-rouge">.await</code> corresponds to a yield site.  We customise the
behaviour of our <code class="language-plaintext highlighter-rouge">Future</code> object (i.e. <code class="language-plaintext highlighter-rouge">WaitUntilResultTaken</code>) so that the
<code class="language-plaintext highlighter-rouge">.await</code> always yields (<code class="language-plaintext highlighter-rouge">Pending</code>) when reached from within the coroutine,
but will continue (<code class="language-plaintext highlighter-rouge">Ready</code>) when resumed from the main function.  The
behaviour is controlled by the <code class="language-plaintext highlighter-rouge">result_taken</code> variable.</p>
  </li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">async fn traverse</code> will recursively call itself in the <code class="language-plaintext highlighter-rouge">.await</code> expression,
and will yield level by level through all the <code class="language-plaintext highlighter-rouge">.await</code> sites to the main
function.</p>

<p>Then we have a problem.  Whenever it yields, the value yielded to the <code class="language-plaintext highlighter-rouge">.poll()</code>
call site in <code class="language-plaintext highlighter-rouge">main</code> is always <code class="language-plaintext highlighter-rouge">Poll::Pending</code>.  Then how do we pass the
traversed numbers to <code class="language-plaintext highlighter-rouge">main</code>?  To work around this, the coroutine writes the
number in a shared variable <code class="language-plaintext highlighter-rouge">result_reporter.num</code> before it yields. This makes
the <code class="language-plaintext highlighter-rouge">ResultReporter</code> struct effectively behave like a “zero-capacity queue” in
our <a href="#async-await-example">previous example</a>, but it connects the generator and
the main function instead of two tasks.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">async_recursion</span><span class="p">::</span><span class="n">async_recursion</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="n">Future</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">pin</span><span class="p">::</span><span class="nb">Pin</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">atomic</span><span class="p">::{</span><span class="n">AtomicBool</span><span class="p">,</span> <span class="n">AtomicI32</span><span class="p">,</span> <span class="n">Ordering</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Poll</span><span class="p">};</span>

<span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="n">ResultReporter</span> <span class="p">{</span>
    <span class="n">num</span><span class="p">:</span> <span class="n">AtomicI32</span><span class="p">,</span> <span class="c1">// Rust is having problem figuring out whether the coroutine races with main,</span>
    <span class="n">result_taken</span><span class="p">:</span> <span class="n">AtomicBool</span><span class="p">,</span> <span class="c1">// so we just use atomic variables here.</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ResultReporter</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">report_result</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WaitUntilResultTaken</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.num</span><span class="nf">.store</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.result_taken</span><span class="nf">.store</span><span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">);</span>
        <span class="n">WaitUntilResultTaken</span> <span class="p">{</span>
            <span class="n">result_taken</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.result_taken</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">take_result</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="k">self</span><span class="py">.num</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.result_taken</span><span class="nf">.store</span><span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">);</span>
        <span class="n">num</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">WaitUntilResultTaken</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">result_taken</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">AtomicBool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Future</span> <span class="k">for</span> <span class="n">WaitUntilResultTaken</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="p">();</span>

    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.result_taken</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">)</span> <span class="p">{</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">NestedList</span> <span class="p">{</span>
    <span class="nf">Leaf</span><span class="p">(</span><span class="nb">i32</span><span class="p">),</span>
    <span class="nf">Nested</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">NestedList</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[async_recursion]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">NestedList</span><span class="p">,</span> <span class="n">reporter</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ResultReporter</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">list</span> <span class="p">{</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// This `await` expression will call `WaitUntilResultTaken::poll()` twice.</span>
            <span class="c1">// The first time is when we reach the `await` here.  It returns `Poll::Pending` so we yield.</span>
            <span class="c1">// The second time is when `main` calls `poll`.  It returns `Poll::Ready(())` so we continue.</span>
            <span class="n">reporter</span><span class="nf">.report_result</span><span class="p">(</span><span class="o">*</span><span class="n">num</span><span class="p">)</span><span class="k">.await</span>
        <span class="p">}</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="k">in</span> <span class="n">lists</span> <span class="p">{</span>
                <span class="c1">// This `await` will pass the `Poll::Pending` to the caller level by level until it reaches `main`.</span>
                <span class="nf">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">reporter</span><span class="p">)</span><span class="k">.await</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
    <span class="k">let</span> <span class="n">nested_list</span> <span class="o">=</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">3</span><span class="p">)]),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">5</span><span class="p">)]),</span>
        <span class="p">]),</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
        <span class="p">]),</span>
    <span class="p">]);</span>

    <span class="k">let</span> <span class="n">result_reporter</span> <span class="o">=</span> <span class="nn">ResultReporter</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">coro</span> <span class="o">=</span> <span class="nf">traverse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nested_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result_reporter</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">null_ctx</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nn">null_mut</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Context</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">coro_p</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">coro</span><span class="p">)</span> <span class="p">};</span>
        <span class="k">let</span> <span class="n">poll_result</span> <span class="o">=</span> <span class="n">coro_p</span><span class="nf">.poll</span><span class="p">(</span><span class="n">null_ctx</span><span class="p">);</span> <span class="c1">// Let the coroutine run.</span>
        <span class="k">match</span> <span class="n">poll_result</span> <span class="p">{</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// When pausing (at `await` sites) during execution, we get the result.</span>
                <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="n">result_reporter</span><span class="nf">.take_result</span><span class="p">();</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// When finished, we just quit.</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="rust-coroutine-crate-stackful-asymmetric">Rust coroutine crate (stackful, asymmetric)</h2>

<p>The third-part crate <a href="https://docs.rs/coroutine/latest/coroutine/"><code class="language-plaintext highlighter-rouge">coroutine</code></a> provides stackful asymmetric
coroutines.  It is built upon the <code class="language-plaintext highlighter-rouge">context</code> crate (see below).</p>

<p>It looks like this crate has not been maintained for quite some time and it
won’t compile. I’ll not do the task using the <code class="language-plaintext highlighter-rouge">coroutine</code> crate.  If you are
interested, their documentation contains some examples.</p>

<h2 id="rust-context-crate-stackful-symmetric">Rust context crate (stackful, symmetric)</h2>

<p>The third-part crate <a href="https://docs.rs/context/latest/context/index.html"><code class="language-plaintext highlighter-rouge">context</code></a> is similar to [Boost Context]. It
provides the abstraction of stackful symmetric coroutines.</p>

<p>It implements swap-stack using machine-specific assembly code
(<a href="https://github.com/zonyitoo/context-rs/blob/master/src/asm/jump_x86_64_sysv_elf_gas.S">x86-64</a>, <a href="https://github.com/zonyitoo/context-rs/blob/master/src/asm/make_arm64_aapcs_elf_gas.S">AArch64</a>,
<a href="https://github.com/zonyitoo/context-rs/blob/master/src/asm/jump_ppc64_sysv_elf_gas.S">ppc64</a>, sorry RISC-V).</p>

<p>The <a href="https://docs.rs/context/latest/context/context/struct.Context.html#method.resume"><code class="language-plaintext highlighter-rouge">Context::resume</code></a> method switches the thread to the
other coroutine, and pass the context of the original coroutine so the thread
can switch back.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">context</span><span class="p">::</span><span class="nn">stack</span><span class="p">::</span><span class="n">ProtectedFixedSizeStack</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">context</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Transfer</span><span class="p">};</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">enum</span> <span class="n">NestedList</span> <span class="p">{</span>
    <span class="nf">Leaf</span><span class="p">(</span><span class="nb">i32</span><span class="p">),</span>
    <span class="nf">Nested</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">NestedList</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">NestedList</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Transfer</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">list</span> <span class="p">{</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Context-switching consumes the `Context` object.  We have to take and replace it.</span>
            <span class="k">let</span> <span class="n">old_t</span> <span class="o">=</span> <span class="n">t</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">new_t</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">old_t</span><span class="py">.context</span><span class="nf">.resume</span><span class="p">(</span><span class="o">*</span><span class="n">num</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">};</span>
            <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">new_t</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="k">in</span> <span class="n">lists</span> <span class="p">{</span>
                <span class="c1">// This is stackful coroutine.  We can do recursive function call.</span>
                <span class="nf">traverse</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
    <span class="k">let</span> <span class="n">nested_list</span> <span class="o">=</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">3</span><span class="p">)]),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">5</span><span class="p">)]),</span>
        <span class="p">]),</span>
        <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Nested</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
            <span class="nn">NestedList</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
        <span class="p">]),</span>
    <span class="p">]);</span>

    <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">context_function</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Transfer</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span>
        <span class="c1">// The initial Transfer carries the pointer to the list as `data`.</span>
        <span class="k">let</span> <span class="n">list</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">t</span><span class="py">.data</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">NestedList</span><span class="p">)</span> <span class="p">};</span>

        <span class="c1">// From now on, we'll frequently take and replace the Transfer. Use Option.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">t_holder</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">t_holder</span><span class="p">);</span>

        <span class="c1">// Send a special value to indicate the end of traversal.</span>
        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_holder</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">t</span><span class="py">.context</span><span class="nf">.resume</span><span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span><span class="p">)</span> <span class="p">};</span>
        <span class="nd">unreachable!</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">stack</span> <span class="o">=</span> <span class="nn">ProtectedFixedSizeStack</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">Transfer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Context</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">,</span> <span class="n">context_function</span><span class="p">)</span> <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// The initial `resume` sends the list reference as a usize.</span>
    <span class="n">t</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">t</span><span class="py">.context</span><span class="nf">.resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nested_list</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">NestedList</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">};</span>

    <span class="c1">// Use this special value to indicate end of traversal.</span>
    <span class="k">while</span> <span class="n">t</span><span class="py">.data</span> <span class="o">!=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">t</span><span class="py">.data</span><span class="p">);</span>

        <span class="c1">// Subsequent `resume` doesn't need to carry values.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">t</span><span class="py">.context</span><span class="nf">.resume</span><span class="p">(</span><span class="mi">0usize</span><span class="p">)</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="c-iterators-stackless-asymmetric">C# iterators (stackless, asymmetric)</h2>

<p>C# can implement iterators using the <code class="language-plaintext highlighter-rouge">yield return</code> or <code class="language-plaintext highlighter-rouge">yield break</code> statements.
A function that contains <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield"><code class="language-plaintext highlighter-rouge">yield</code></a> returns an <code class="language-plaintext highlighter-rouge">Enumerable&lt;T&gt;</code> or
<code class="language-plaintext highlighter-rouge">Enumerator&lt;T&gt;</code> which is resumed every time an item is requested.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td><td class="code"><pre><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">interface</span> <span class="nc">NestedList</span>
<span class="p">{</span>
    <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">Traverse</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Leaf</span> <span class="p">:</span> <span class="n">NestedList</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Leaf</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">num</span> <span class="p">=</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">Traverse</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Branch</span> <span class="p">:</span> <span class="n">NestedList</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">NestedList</span><span class="p">&gt;</span> <span class="n">children</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Branch</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">children</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">NestedList</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">Branch</span> <span class="nf">Add</span><span class="p">(</span><span class="n">NestedList</span> <span class="n">child</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">children</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">Traverse</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// It is stackless.  We need to yield from the inner iterators.</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">y</span> <span class="k">in</span> <span class="n">child</span><span class="p">.</span><span class="nf">Traverse</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="k">yield</span> <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">IteratorTraversal</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
        <span class="kt">var</span> <span class="n">nestedList</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Branch</span><span class="p">()</span>
            <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
            <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Branch</span><span class="p">()</span>
                    <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Branch</span><span class="p">()</span>
                        <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">2</span><span class="p">))</span>
                        <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">3</span><span class="p">)))</span>
                    <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Branch</span><span class="p">()</span>
                        <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">4</span><span class="p">))</span>
                        <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">5</span><span class="p">))))</span>
            <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Branch</span><span class="p">()</span>
                    <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">6</span><span class="p">))</span>
                    <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">7</span><span class="p">))</span>
                    <span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">Leaf</span><span class="p">(</span><span class="m">8</span><span class="p">)));</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">n</span> <span class="k">in</span> <span class="n">nestedList</span><span class="p">.</span><span class="nf">Traverse</span><span class="p">())</span> <span class="c1">// Create the iterator</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="c-asyncawait-stackless-asymmetric-asynchronous">C# async/await (stackless, asymmetric, asynchronous)</h2>

<p>C# <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">supports asynchronous programming</a> (see
<a href="#async-await">appendix</a>).  Like async/await in any other language, its
programming model is more like cooperative multi-task programming than
coroutines.  It is possible to implement asynchronous traversal using an
<a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.threading.asyncqueue-1?view=visualstudiosdk-2022">AsyncQueue</a> to communicate between the traversal task and a
consumer task that consumes the visited values. I am not going to give an
example here.</p>

<h2 id="c-swapcontext-stackful-symmetric">C swapcontext (stackful, symmetric)</h2>

<p>The C programming language itself doesn’t have any support for coroutines or
<a href="#swap-stack">swap-stack</a>.</p>

<p>The POSIX function <a href="https://linux.die.net/man/3/makecontext"><code class="language-plaintext highlighter-rouge">makecontext</code></a> can create a “context” for a
function on a given stack so that when a subsequent invocation of
<a href="https://linux.die.net/man/3/swapcontext"><code class="language-plaintext highlighter-rouge">swapcontext</code></a> swaps to that context, it will continue
execution from the beginning of the given function on the given stack.  This
effectively provides a <a href="#swap-stack">swap-stack</a> mechanism, and can be used to implement
symmetric coroutines.</p>

<p>One design flaw of <code class="language-plaintext highlighter-rouge">makecontext</code> is that it only supports passing <code class="language-plaintext highlighter-rouge">int</code>
arguments to the given function.  Because the size of <code class="language-plaintext highlighter-rouge">int</code> is
platform-specific, it is hard to pass pointers across <code class="language-plaintext highlighter-rouge">makecontext</code>.  According
to the <a href="https://linux.die.net/man/3/makecontext">man page</a>, POSIX 2008 removed <code class="language-plaintext highlighter-rouge">makecontext</code> and
<code class="language-plaintext highlighter-rouge">swapcontext</code>, citing portability issues, and recommended the use of POSIX
threads.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ucontext.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">first_child</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next_sibling</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node8</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node7</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node8</span>    <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node6</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node7</span>    <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node678</span>      <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node6</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node5</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node4</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node5</span>    <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node45</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node4</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node3</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node2</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node3</span>    <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node23</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node45</span>   <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node2345</span>     <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node23</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node678</span>  <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node1</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>    <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2345</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="n">node12345678</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">NULL</span>      <span class="p">};</span>

<span class="n">ucontext_t</span> <span class="n">main_context</span><span class="p">;</span>
<span class="n">ucontext_t</span> <span class="n">coro_context</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">current_value</span><span class="p">;</span>
<span class="n">bool</span> <span class="n">finished</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">do_yield</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">current_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">swapcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coro_context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">main_context</span><span class="p">);</span>  <span class="c1">// switch back to main</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">visit_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_sibling</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">do_yield</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">visit_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">);</span>   <span class="c1">// recursive call</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">traverse</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">visit_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node12345678</span><span class="p">);</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coro_context</span><span class="p">);</span>

    <span class="c1">// Obviously, it is stackful.</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">65536</span><span class="p">);</span>    <span class="c1">// Not sure if 65536 is enough, though.</span>
                                    <span class="c1">// If we are careful enough, we should use mprotect</span>
                                    <span class="c1">// to create a PROT_NONE region to protect against</span>
                                    <span class="c1">// stack overflow.</span>
    <span class="n">coro_context</span><span class="p">.</span><span class="n">uc_stack</span> <span class="o">=</span> <span class="p">(</span><span class="n">stack_t</span><span class="p">){</span> <span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="n">stack</span><span class="p">,</span> <span class="p">.</span><span class="n">ss_size</span> <span class="o">=</span> <span class="mi">4096</span> <span class="p">};</span>
    <span class="n">coro_context</span><span class="p">.</span><span class="n">uc_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">main_context</span><span class="p">;</span>
    <span class="n">makecontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coro_context</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">traverse</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swapcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">main_context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">coro_context</span><span class="p">);</span>  <span class="c1">// switch to coroutine</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current_value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="c-coroutine-stackless-asymmetric-asynchronous">C++ coroutine (stackless, asymmetric, asynchronous)</h2>

<p>C++20 introduced “coroutines”.  More precisely, it introduced mechanisms so that
libraries can implement <a href="#async-await">asynchronous programming</a> on top of them.</p>

<p>Any function that contains <code class="language-plaintext highlighter-rouge">co_await</code>, <code class="language-plaintext highlighter-rouge">co_yield</code> and/or <code class="language-plaintext highlighter-rouge">co_return</code> are
coroutine functions.</p>

<p>Calling a coroutine function behaves like the pseudo-code defined in
<a href="https://timsong-cpp.github.io/cppwp/n4861/dcl.fct.def.coroutine#5">Section 9.5.4 (dcl.fct.def.coroutine) paragraph 5</a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="n">promise</span><span class="o">-</span><span class="n">type</span> <span class="n">promise</span> <span class="n">promise</span><span class="o">-</span><span class="n">constructor</span><span class="o">-</span><span class="n">arguments</span> <span class="p">;</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">()</span> <span class="p">;</span>
        <span class="n">function</span><span class="o">-</span><span class="n">body</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">initial</span><span class="o">-</span><span class="n">await</span><span class="o">-</span><span class="n">resume</span><span class="o">-</span><span class="n">called</span><span class="p">)</span>
            <span class="k">throw</span> <span class="p">;</span>
        <span class="n">promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">()</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="k">final</span><span class="o">-</span><span class="n">suspend</span> <span class="o">:</span>
    <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Basically, it implicitly creates a “promise object” which is called (awaited) at
different points of the coroutine execution, like “hooks” or aspect-oriented
programming.  The compiler will generate those <code class="language-plaintext highlighter-rouge">promise.xxxx()</code> method calls,
and it is the programmer’s (or library writer’s) responsibility to define the
“promise type” and the <code class="language-plaintext highlighter-rouge">.initial_suspend()</code>, <code class="language-plaintext highlighter-rouge">.unhandled_exception()</code>, and
<code class="language-plaintext highlighter-rouge">.final_suspend()</code> methods to make the generated calls meaningful.</p>

<p>And evaluation a <code class="language-plaintext highlighter-rouge">co_await</code> expression behaves as defined in <a href="https://timsong-cpp.github.io/cppwp/n4861/expr.await#5">Section 7.6.2.3
(expr.await) paragraph 5</a>.  It takes an “awaiter” (more
precisely, anything that can be converted to an “awaiter”) as operand, and</p>

<ul>
  <li>It calls <code class="language-plaintext highlighter-rouge">awaiter.await_ready()</code>.
    <ul>
      <li>If it returns true, it calls <code class="language-plaintext highlighter-rouge">awaiter.await_resume()</code>, and that’s the
value of the <code class="language-plaintext highlighter-rouge">co_await</code> expression.</li>
      <li>If it returns false, it calls <code class="language-plaintext highlighter-rouge">awaiter.await_suspend()</code>, and depending
on its result, it may suspend the execution of the coroutine, or suspend
and switch to another coroutine, or just continue execution.</li>
    </ul>
  </li>
</ul>

<p>It’s the “conditionally yielding” behaviour of common <a href="#async-await">async/await</a>-based
programming.  Again the compiler generates the above method calls, and it is
again the programmer’s (or library writer’s) responsibility to implement the
<code class="language-plaintext highlighter-rouge">.await_ready()</code>, <code class="language-plaintext highlighter-rouge">.await_resume()</code> and <code class="language-plaintext highlighter-rouge">.await_suspend()</code> methods to make those
generated calls meaningful.</p>

<p>The <a href="https://timsong-cpp.github.io/cppwp/n4861/expr.yield"><code class="language-plaintext highlighter-rouge">co_yield</code></a> expression calls <code class="language-plaintext highlighter-rouge">promise.yield_value(x)</code>,
and programmer (or library writer) shall implement the promise object to make
<code class="language-plaintext highlighter-rouge">.yield_value</code> method meaningful.</p>

<p>And the <a href="https://timsong-cpp.github.io/cppwp/n4861/stmt.return.coroutine"><code class="language-plaintext highlighter-rouge">co_return</code></a> statement calls
<code class="language-plaintext highlighter-rouge">promise.return_void()</code>, and the programmer (or library writer) shall implement
the promise object to make <code class="language-plaintext highlighter-rouge">.return_void</code> method meaningful.</p>

<p>And the standard library function <code class="language-plaintext highlighter-rouge">coroutine_handle::resume()</code> resumes a paused
“coroutine”.</p>

<p>As we can see</p>

<ul>
  <li>the specification defines the semantics of coroutine functions, the
<code class="language-plaintext highlighter-rouge">co_await</code>, <code class="language-plaintext highlighter-rouge">co_yield</code> and <code class="language-plaintext highlighter-rouge">co_return</code> expressions/statements, and the
<code class="language-plaintext highlighter-rouge">coroutine_handle</code> library object and its <code class="language-plaintext highlighter-rouge">.resume()</code> method, and</li>
  <li>the compiler (GCC, Clang, etc.) generate code for the <code class="language-plaintext highlighter-rouge">co_xxx</code>
expression/statements, and</li>
  <li>the programmer defines the promise type and (optionally) “awaiter” types and
fills in lots and lots of methods to customise the behaviour.</li>
</ul>

<p>How complicated C++20 “coroutines” are!</p>

<p>It is complicated enough to <a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html">confuse a C++ programmer with 25-years’
experience</a>.</p>

<p>And I admit I am not smart enough to use C++20 coroutines.</p>

<p>If you are not smart enough, either, but want to learn about C++20 coroutines, I
recommend starting with another language, such as Ruby or Lua, and come back to
C++20 when the idea of coroutines don’t scare you.</p>

<p>Anyway, here is the code.  The following code tries to use C++20 coroutines as
generators.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;coroutine&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">first_child</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next_sibling</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
<span class="n">Node</span> <span class="n">node8</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node7</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node8</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node6</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node7</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node678</span>      <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node6</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node5</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node4</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node5</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node45</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node4</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node3</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node3</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node23</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node45</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2345</span>     <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node23</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node678</span>  <span class="p">};</span>
<span class="n">Node</span> <span class="n">node1</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2345</span> <span class="p">};</span>
<span class="n">Node</span> <span class="n">node12345678</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>

<span class="k">struct</span> <span class="nc">Traverser</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">promise_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">handle_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">promise_type</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">current_value_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">finished_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="c1">// This is executed when the "coroutine" is created.</span>
        <span class="n">Traverser</span> <span class="n">get_return_object</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">Traverser</span><span class="p">(</span><span class="n">handle_type</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// Called at the beginning of the coroutine.</span>
        <span class="c1">// We let it stop there to mimic Python generator behaviour.</span>
        <span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">initial_suspend</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{};</span>
        <span class="p">}</span>

        <span class="c1">// Called when the coroutine finished execution.</span>
        <span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">final_suspend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
            <span class="c1">// We set a variable so the main function knows it finished.</span>
            <span class="n">finished_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">{};</span>
        <span class="p">}</span>

        <span class="c1">// Called when a co_yield expression is evaluated.</span>
        <span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">yield_value</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">current_value_</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">{};</span>
        <span class="p">}</span>

        <span class="c1">// Called when an exception is thrown.</span>
        <span class="kt">void</span> <span class="n">unhandled_exception</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">terminate</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">handle_type</span> <span class="n">handle_</span><span class="p">;</span>

    <span class="n">Traverser</span><span class="p">(</span><span class="n">handle_type</span> <span class="n">handle</span><span class="p">)</span> <span class="o">:</span> <span class="n">handle_</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">resume</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">handle_</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">finished</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">handle_</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">finished_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">get_value</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">handle_</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">current_value_</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">Traverser</span> <span class="n">visit_node</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_sibling</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Yield.</span>
            <span class="k">co_yield</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// It is stackless.  We need multiple levels of coroutines.</span>
            <span class="k">auto</span> <span class="n">sub_traverser</span> <span class="o">=</span> <span class="n">visit_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">);</span>
            <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sub_traverser</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sub_traverser</span><span class="p">.</span><span class="n">finished</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// Yield from sub-coroutine.</span>
                <span class="k">co_yield</span> <span class="n">sub_traverser</span><span class="p">.</span><span class="n">get_value</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">visit_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node12345678</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverser</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">traverser</span><span class="p">.</span><span class="n">finished</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">traverser</span><span class="p">.</span><span class="n">get_value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="c-boostcoroutine2-stackful-asymmetric">C++ Boost.Coroutine2 (stackful, asymmetric)</h2>

<p>Note: Boost.Coroutine is deprecated in favour for Boost.Coroutine2.</p>

<p><a href="https://www.boost.org/doc/libs/1_80_0/libs/coroutine2/doc/html/index.html">Boost.Coroutine2</a> provides stackful asymmetric coroutines.  It is implemented
on top of <a href="https://www.boost.org/doc/libs/1_80_0/libs/context/doc/html/index.html">Boost.Context</a> (see below).</p>

<p>A <code class="language-plaintext highlighter-rouge">boost::coroutines2::coroutine&lt;T&gt;</code> has two members: <code class="language-plaintext highlighter-rouge">pull_type</code> and
<code class="language-plaintext highlighter-rouge">push_type</code>.  A coroutine can be created by instantiating either of them.  In
this task, we will create a <code class="language-plaintext highlighter-rouge">pull_type</code> so that the main function can pull data
from the coroutine.  It will create a coroutine which receives a <code class="language-plaintext highlighter-rouge">&amp;push_type</code> so
that it can yield and push data back to the main function.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/coroutine2/coroutine.hpp&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">first_child</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next_sibling</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
<span class="n">Node</span> <span class="n">node8</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node7</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node8</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node6</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node7</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node678</span>      <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node6</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node5</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node4</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node5</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node45</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node4</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node3</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node3</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node23</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node45</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2345</span>     <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node23</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node678</span>  <span class="p">};</span>
<span class="n">Node</span> <span class="n">node1</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2345</span> <span class="p">};</span>
<span class="n">Node</span> <span class="n">node12345678</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>

<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">coroutines2</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">coro_t</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">visit_node</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">coro_t</span><span class="o">::</span><span class="n">push_type</span> <span class="o">&amp;</span><span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_sibling</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sink</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>   <span class="c1">// Yield at any level.  It's stackful!</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">visit_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">,</span> <span class="n">sink</span><span class="p">);</span>   <span class="c1">// Recursive call.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">coro_t</span><span class="o">::</span><span class="n">pull_type</span><span class="p">([](</span><span class="n">coro_t</span><span class="o">::</span><span class="n">push_type</span> <span class="o">&amp;</span><span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">visit_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node12345678</span><span class="p">,</span> <span class="n">sink</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">value</span> <span class="o">:</span> <span class="n">traverser</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Can be used as iterator using begin() and end().</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="c-boostcontext-stackful-symmetric">C++ Boost.Context (stackful, symmetric)</h2>

<p><a href="https://www.boost.org/doc/libs/1_80_0/libs/context/doc/html/index.html">Boost.Context</a> implements a <a href="#swap-stack">swap-stack</a> mechanism using machine-dependent
assembly language(<a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_x86_64_sysv_elf_gas.S">x86-64</a>, <a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_arm64_aapcs_elf_gas.S">ARM64</a>,
<a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_riscv64_sysv_elf_gas.S">RISCV64</a>, etc.).  We can also implement symmetric coroutines
using its C++ API.  A <code class="language-plaintext highlighter-rouge">boost::coroutine::fiber</code> represents a coroutine, and
<code class="language-plaintext highlighter-rouge">fiber::resume()</code> switches to that coroutine.  Because <code class="language-plaintext highlighter-rouge">fiber::resume()</code> doesn’t
pass values, we need to use a side channel (the shared <code class="language-plaintext highlighter-rouge">State</code> object) to pass
the value and indicate that the traversal has finished.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/coroutine2/coroutine.hpp&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">first_child</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next_sibling</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// [1, [[2, 3], [4, 5]], [6, 7, 8]]</span>
<span class="n">Node</span> <span class="n">node8</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node7</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node8</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node6</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node7</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node678</span>      <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node6</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node5</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node4</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node5</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node45</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node4</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node3</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node3</span>    <span class="p">};</span>
<span class="n">Node</span> <span class="n">node23</span>       <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node45</span>   <span class="p">};</span>
<span class="n">Node</span> <span class="n">node2345</span>     <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node23</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node678</span>  <span class="p">};</span>
<span class="n">Node</span> <span class="n">node1</span>        <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2345</span> <span class="p">};</span>
<span class="n">Node</span> <span class="n">node12345678</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">first_child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="p">,</span>  <span class="p">.</span><span class="n">next_sibling</span> <span class="o">=</span> <span class="nb">nullptr</span>   <span class="p">};</span>

<span class="k">struct</span> <span class="nc">State</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">current_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">finished</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">visit_node</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">State</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">fiber</span> <span class="o">&amp;</span><span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_sibling</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">state</span><span class="p">.</span><span class="n">current_value</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
            <span class="n">sink</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sink</span><span class="p">).</span><span class="n">resume</span><span class="p">();</span>   <span class="c1">// Yield at any level.  It's stackful!</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">visit_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">sink</span><span class="p">);</span>   <span class="c1">// Recursive call.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">State</span> <span class="n">state</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">fiber</span><span class="p">([</span><span class="o">&amp;</span><span class="n">state</span><span class="p">](</span><span class="n">boost</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">fiber</span> <span class="o">&amp;&amp;</span><span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">visit_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node12345678</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">sink</span><span class="p">);</span>
        <span class="n">state</span><span class="p">.</span><span class="n">finished</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sink</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverser</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">traverser</span><span class="p">).</span><span class="n">resume</span><span class="p">();</span>  <span class="c1">// Resume the coroutine.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">state</span><span class="p">.</span><span class="n">current_value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h1 id="appendices">Appendices</h1>

<h2 id="why-this-task">Why this task?</h2>

<p>The purpose of this task is to compare <em>symmetric</em>, <em>asymmetric</em>, <em>stackful</em> and
<em>stackless</em> coroutines.</p>

<p>This task is natural to implement with coroutines, because the traversal of a
data structure is relatively independent from the consumption of the values.</p>

<p>This task is also much easier with stackful coroutines than stackless
coroutines.  Because the data structure (nested lists) is recursive, it is
easier to traverse it using a recursive algorithm, and recursion needs a stack.
Stackful coroutines can handle recursive calls quite trivially. But when using
stackless coroutines, we have to do some hack and chain up multiple coroutines
to form a stack of coroutines, and yield values from the innermost coroutine
through multiple layers of coroutines to the consumer.</p>

<p>From the code examples above, we can clearly see the difference between
different kinds of coroutines.</p>

<h2 id="what-are-coroutines-anyway">What are coroutines anyway?</h2>

<p>According to <a href="https://dl.acm.org/doi/10.1145/366663.366704">Conway</a>, a <strong>coroutine</strong> is “<em>an autonomous program
which communicates with adjacent modules as if they were input or output
subroutines</em>”.  Coroutines are subroutines all at the same level, each acting as
if it were the master program when in fact there is no master program.</p>

<p>Coroutines has the following characteristics. (See <a href="http://www.lua.org/doc/jucs04.pdf"><em>Coroutines in
Lua</em></a>)</p>

<ol>
  <li>The values of data local to a coroutine persist between successive calls.</li>
  <li>The execution of a coroutine is suspended as control leaves it, only to
carry on where it left off when control re-enters the coroutine at some
later stage.</li>
</ol>

<p>The first characteristic means coroutines can be resumed from where it paused.</p>

<p>In the second characteristic, “as control leaves it” means it is the programmer
that decides <em>where</em> to pause a coroutine, not the implicit scheduler.  Control
flow is part of a program, not the runtime.</p>

<p>For this reason, the “fibers” in Ruby, the “generators” in Python, the
“threads” in Lua, and the “user contexts” in the <code class="language-plaintext highlighter-rouge">swapcontext</code> POSIX API are all
coroutines, despite not being called “coroutines”.  The programmer explicitly
transfers control from one to another.</p>

<p>On the other hand, a “goroutine” in the Go programming language is not a
coroutine, despite the similar name.  In fact, <a href="https://golang.google.cn/ref/spec#Go_statements">the official document</a>
defines a “goroutine” as “an independent concurrent thread of control”, i.e. a
thread.</p>

<p><small>Note: Goroutine is a threading mechanism implemented in the user space,
an “M × N” green thread system. The Go runtime schedules M goroutines on N native
threads. It is the scheduler that switches a native thread between different
goroutines at unspecified time and locations, usually when IO operations may
block, or when queues are full or empty.  To the programmer, a goroutine is just
like a thread: it keeps going forward.  It may block, but not because the
programmer asked it to yield, but because some requests cannot be satisfied,
such as queues and IO. </small></p>

<p>Coroutines are not mutually exclusive with threads.  Each thread is executing
one coroutine at a time, and each thread may jump from one coroutine to another
according to the control flow in the program.</p>

<h2 id="symmetric-and-asymmetric-coroutines">Symmetric and asymmetric coroutines.</h2>

<p>With <em>symmetric</em> coroutines, all coroutines are equal.  A thread can jump from
any coroutine to any other coroutine.  When switching, the programmer always
needs to specify which coroutine to jump to, i.e. destination.</p>

<p>With <em>asymmetric</em> coroutines, coroutines have a parent-child relation.  There
are two different operations that jumps between coroutines, namely <code class="language-plaintext highlighter-rouge">resume</code> and
<code class="language-plaintext highlighter-rouge">yield</code>.  When a thread “resumes” a coroutine, the destination becomes the child
of the source coroutine, until it “yields”, when the thread jumps back from the
child to the parent coroutine.  A coroutine cannot be resumed when it already
has a parent.  When yielding, the programmer doesn’t need to specify the
destination, because the destination is always implicitly the parent coroutine.</p>

<p>Symmetric and asymmetric coroutines have equal expressive power, and they can
implement each other.  See <a href="http://www.lua.org/doc/jucs04.pdf">Coroutines in Lua</a> for more details.</p>

<h2 id="stackful-and-stackless-coroutines">Stackful and stackless coroutines.</h2>

<p>A <em>stackful</em> coroutine has its own execution stack.  A thread can switch
coroutine when the current coroutine has any number of frames on its stack. When
switching, the thread saves the entire stack and switches to a whole new stack
(implementation-wise, it only needs to save registers, change the stack pointer,
and restore registers from the new stack).</p>

<p>A <em>stackless</em> coroutine has only one frame.  Therefore, a coroutine is usually
defined by a “coroutine function”. From my knowledge, all stackless coroutines
are asymmetric.  A coroutine function can only yield within the coroutine
function itself.  That means when a coroutine C1 calls another function F2, the
thread cannot yield from C1 while executing F2;  when a coroutine C1 resumes
another coroutine C2, the thread can only yield from C2 back to C1, but not
directly from C2 to C1’s parent.</p>

<p>Stackful coroutines are more powerful, but need some kind of “swap-stack”
mechanism (see below) to implement.  Stackless coroutines are more restricted,
but does not require swap-stack.</p>

<h2 id="swap-stack">The swap-stack mechanism</h2>

<p>Conceptually, the context of nested function calls is a stack, a
last-in-first-out data structure, called the <em>control stack</em>, often simply
called a <em>stack</em>.</p>

<p>A control stack has many <em>frames</em>.  Each frame contains the execution context of
a function activation, (and this is why a frame is also known as an <em>activation
record</em>).  The context includes the program counter (PC) as well as the values
of local variables.  The top frame is the context of the most recently entered
function, and is the only frame on a stack that is active.  All other frames are
paused at a call site, waiting for the called function (the frame above it) to
return.</p>

<p>In most programming languages, a thread is always bound to one stack. But more
generally, a thread can switch among different stacks.  When a thread switches
from one stack to another, it pauses the top frame as well making the whole
stack paused.  Then it switches its stack pointer to the new stack, and resume
the top frame of the new stack, therefore continue from where that frame was
paused.</p>

<p>This is basically what <em>stackful coroutine</em> does.  Each coroutine has a stack,
which can be paused and resumed.  When resumed, it continues from where it was
paused.</p>

<h3 id="implementing-swap-stack-with-compiler">Implementing swap-stack with compiler</h3>

<p>Implementation-wise, if the language is compiled, it needs a special instruction
sequence that does the following things:</p>

<ol>
  <li>Save live registers on the top of the current stack, and</li>
  <li>set the stack pointer (SP) register to the destination stack, and</li>
  <li>restore the saved registers from the top of the destination stack.</li>
</ol>

<p>The C and C++ programming languages themselves do not have support for
swap-stack.  In practice, we usually rely on libraries or compiler extensions to
do that in C or C++.</p>

<p>Here I give two examples of implementations of swap-stack for compiled code.</p>

<ol>
  <li>
    <p>One is from <a href="https://www.boost.org/doc/libs/1_80_0/libs/context/doc/html/index.html">Boost.Context</a>.  It is implemented as a library in the assembly
language, therefore it has to be platform-specific. Here are the code for
<a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_x86_64_sysv_elf_gas.S">x86-64</a>, <a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_arm64_aapcs_elf_gas.S">ARM64</a> and
<a href="https://github.com/boostorg/context/blob/develop/src/asm/jump_riscv64_sysv_elf_gas.S">RISCV64</a>.  Because it is implemented as a library, it can
only depend on the application binary interface (ABI) of the platform.  In
this case, the assembly code has to conservatively save all callee-saved
registers no matter whether they are still in use or not, because as a
library, it does not have the liveness information the compiler has.</p>
  </li>
  <li>
    <p>The other is an LLVM extension created by <a href="http://dx.doi.org/10.1145/2400682.2400695">Dolan et al.</a>.  As part of
a compiler framework, it can identify and save only live registers, making
it much more efficient than library-based approaches.</p>
  </li>
</ol>

<h3 id="implementing-swap-stack-with-interpreter">Implementing swap-stack with interpreter</h3>

<p>If the language is interpreted, it depends.  An interpreter can be stackful or
stackless, and even stackless interpreters can allow the interpreted functions
to call foreign C functions.</p>

<p>A stackful interpreter uses the native (C) stack to implement function
invocation.  Such interpreters usually has the following form:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">interpret_function</span><span class="p">(</span><span class="n">Frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">current_instruction</span><span class="p">().</span><span class="n">type</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">...:</span>
            <span class="p">...</span>
        <span class="k">case</span> <span class="n">CALL</span><span class="p">:</span>
            <span class="p">...</span>
            <span class="n">Frame</span> <span class="o">*</span><span class="n">new_frame</span> <span class="o">=</span> <span class="n">create_frame</span><span class="p">(</span><span class="n">called_function</span><span class="p">);</span>
            <span class="n">interpret_function</span><span class="p">(</span><span class="n">new_frame</span><span class="p">);</span>  <span class="c1">// Recursive call</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Because a language-level function call corresponds to an interpreter-level
(C-level) function call, each frame in the interpreted language corresponds to a
C frame.  It is difficult to implement swap-stack with stackful interpreter
because it needs to swap out the C stack (which has C frames) in order to swap
out the interpreted language stack.  As we have discussed before, C does not
have native support for swap-stack, and it needs libraries written in assembly
language or compiler extensions to do so.</p>

<p><a id="apdx-sisc"></a></p>

<p>What about stackless interpreters?</p>

<p>A stackless interpreter does not turn language-level function calls into C-level
function calls.  A stackless interpreter usually has the following form:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">interpret_function</span><span class="p">(</span><span class="n">Frame</span> <span class="o">*</span><span class="n">initial_frame</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Frame</span> <span class="o">*</span><span class="n">current_frame</span> <span class="o">=</span> <span class="n">initial_frame</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">current_instruction</span><span class="p">().</span><span class="n">type</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">...:</span>
            <span class="p">...</span>
        <span class="k">case</span> <span class="n">CALL</span><span class="p">:</span>
            <span class="p">...</span>
            <span class="n">Frame</span> <span class="o">*</span><span class="n">new_frame</span> <span class="o">=</span> <span class="n">create_frame</span><span class="p">(</span><span class="n">called_function</span><span class="p">);</span>
            <span class="n">new_frame</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">;</span>
            <span class="n">current_frame</span> <span class="o">=</span> <span class="n">new_frame</span><span class="p">;</span>  <span class="c1">// Only replace the frame pointer</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A stackless interpreter always remains in the single <code class="language-plaintext highlighter-rouge">interpret_function</code>
function activation even when the interpreted language program makes a call.
Swap-stack is relatively easier to implement with stackless interpreter,
because it does not need to swap out any C frames…</p>

<p>… unless it allows foreign function calls.  If the stackless interpreter
allows the interpreted language to call foreign C functions, then C functions
must have frames on some stack.  Then we face the same problem as implementing
swap-stack for compiled languages.</p>

<h3 id="the-mu-micro-virtual-machine">The Mu micro virtual machine</h3>

<p>I designed the <a href="https://microvm.github.io/">Mu micro virtual machine</a>, and it is the main part of <a href="https://wks.github.io/downloads/pdf/wang-thesis-2018.pdf">my
PhD thesis</a>.  Swap-stack is a very important mechanism of the Mu
micro VM, and it is designed to be supported by the JIT compiler.  It enables
the implementation of symmetric stackful coroutines, and it is the foundation of
other VM mechanisms, such as trapping and <a href="https://wks.github.io/downloads/pdf/osr-vee-2018.pdf">on-stack replacement
(OSR)</a>.  If you are interested, read
<a href="https://wks.github.io/downloads/pdf/wang-thesis-2018.pdf#subsection.5.3.6">Section 5.3.6</a> of <a href="https://wks.github.io/downloads/pdf/wang-thesis-2018.pdf">my thesis</a>.</p>

<h2 id="function-to-state-machine">Decomposing a function into a state machine</h2>

<p>Interpreters usually have no problem saving the frame of a function at a <code class="language-plaintext highlighter-rouge">yield</code>
point so that it can be resumed later.  The interpreter can implement the layout
of stack frames and the behaviour of function calls / coroutine resumption in
any way it wants.  They may even allocate frames in the heap so that they can
temporarily remove a frame from the stack and put it back later. For compilers,
if swap-stack is available, one thread can just save the register states on one
stack and restore them from another stack. Without swap-stack, however, it may
be a challenge.</p>

<p>One way to implement pause-able and resume-able functions is decomposing a
function into a state machine.  Each <code class="language-plaintext highlighter-rouge">yield</code> point becomes a state, and a
function starts by matching the state and jumping to the right place.</p>

<p>For example, assume the <code class="language-plaintext highlighter-rouge">yield()</code> call represents a coroutine yield in the
following C pseudo-code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Long</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">yield</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"time</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">yield</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"no</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">yield</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"see</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Such a function can be transformed into a function that takes a state when
called, and returns a new state when yielding or returning.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">State</span> <span class="p">{</span>
    <span class="n">START</span><span class="p">,</span> <span class="n">STATE1</span><span class="p">,</span> <span class="n">STATE2</span><span class="p">,</span> <span class="n">STATE3</span><span class="p">,</span> <span class="n">END</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">State</span> <span class="nf">foo</span><span class="p">(</span><span class="k">enum</span> <span class="n">State</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">START</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Long</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">STATE1</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">STATE1</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"time</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">STATE2</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">STATE2</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"no</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">STATE3</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">STATE3</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"see</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">END</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">State</span> <span class="n">state</span> <span class="o">=</span> <span class="n">START</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">END</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Resuming foo()...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"foo() paused</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>What about local variables?  Local variables can be packed into the states, too.
C programmers may use the <code class="language-plaintext highlighter-rouge">union</code> type, but it is easier with tagged unions or
object-oriented programming.</p>

<p>Suppose we have a (pseudo) Rust function where <code class="language-plaintext highlighter-rouge">yield!()</code> represents a coroutine
yield.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">square_sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Future</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"a * a = {}"</span><span class="p">,</span> <span class="n">a2</span><span class="p">);</span>
    <span class="k">yield</span><span class="o">!</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"b * b = {}"</span><span class="p">,</span> <span class="n">b2</span><span class="p">);</span>
    <span class="k">yield</span><span class="o">!</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a2</span> <span class="o">+</span> <span class="n">b2</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"result = {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can use an <code class="language-plaintext highlighter-rouge">enum</code> to hold <em>live</em> (will be used later) local variables at each
<code class="language-plaintext highlighter-rouge">yield!()</code> point.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre><span class="cd">/// Note: each state holds the live local variables.</span>
<span class="k">enum</span> <span class="n">State</span> <span class="p">{</span>
    <span class="n">Start</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
    <span class="n">State1</span> <span class="p">{</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">a2</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>  <span class="c1">// Note: a is no longer useful.</span>
    <span class="n">State2</span> <span class="p">{</span> <span class="n">a2</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b2</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span> <span class="c1">// Note: neither a nor b are useful now.</span>
    <span class="n">End</span> <span class="p">{</span> <span class="n">result</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
<span class="p">}</span>

<span class="cd">/// Calling this function merely gets the initial state.</span>
<span class="cd">/// It doesn't actually execute the body of the original function.</span>
<span class="k">fn</span> <span class="nf">square_sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">State</span> <span class="p">{</span>
    <span class="nn">State</span><span class="p">::</span><span class="n">Start</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Call this for each step.</span>
<span class="k">fn</span> <span class="nf">square_sum_step</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">State</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">State</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">state</span> <span class="p">{</span>
        <span class="nn">State</span><span class="p">::</span><span class="n">Start</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="c1">// Restore local variables from the state.</span>
            <span class="k">let</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"a * a = {}"</span><span class="p">,</span> <span class="n">a2</span><span class="p">);</span>
            <span class="nn">State</span><span class="p">::</span><span class="n">State1</span> <span class="p">{</span> <span class="n">b</span><span class="p">,</span> <span class="n">a2</span> <span class="p">}</span> <span class="c1">// Save useful local variables into state.</span>
        <span class="p">}</span>

        <span class="nn">State</span><span class="p">::</span><span class="n">State1</span> <span class="p">{</span> <span class="n">b</span><span class="p">,</span> <span class="n">a2</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="c1">// restore</span>
            <span class="k">let</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"b * b = {}"</span><span class="p">,</span> <span class="n">b2</span><span class="p">);</span>
            <span class="nn">State</span><span class="p">::</span><span class="n">State2</span> <span class="p">{</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span> <span class="p">}</span> <span class="c1">// save</span>
        <span class="p">}</span>

        <span class="nn">State</span><span class="p">::</span><span class="n">State2</span> <span class="p">{</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="c1">// restore</span>
            <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a2</span> <span class="o">+</span> <span class="n">b2</span><span class="p">;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"result = {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
            <span class="nn">State</span><span class="p">::</span><span class="n">End</span> <span class="p">{</span> <span class="n">result</span> <span class="p">}</span> <span class="c1">// save</span>
        <span class="p">}</span>

        <span class="nn">State</span><span class="p">::</span><span class="n">End</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Coroutine already finished!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">state</span> <span class="o">=</span> <span class="nf">square_sum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">state</span> <span class="p">{</span>
            <span class="nn">State</span><span class="p">::</span><span class="n">End</span> <span class="p">{</span> <span class="n">result</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Execution finished. Result is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Resuming..."</span><span class="p">);</span>
                <span class="n">state</span> <span class="o">=</span> <span class="nf">square_sum_step</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Yielded."</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="async-await">Asynchronous programming (async/await) and coroutines</h2>

<p>In asynchronous programming, a program consists of many tasks that can be
completed in the future, and one task can wait for other tasks to complete
before continuing.  There are many ways to implement asynchronous programming.
It can be trivially executed inline (e.g. the X10 compiler is <a href="https://x10.sourceforge.net/documentation/intro/latest/html/node4.html#SECTION00410000000000000000">allowed to
inline</a> an async activity), executed sequentially, using threads, or
using coroutines.</p>

<p>The notion of “Future” and its friend “Promise” are well-known in multi-thread
programming (<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/Future.html">C++</a>, <a href="https://en.cppreference.com/w/cpp/thread/future">Java</a>, <a href="https://learn.microsoft.com/en-us/cpp/standard-library/future-class">C#</a> and
<a href="https://docs.python.org/3/library/concurrent.futures.html#future-objects">Python</a>).  A pair of Future and Promise represents a value yet
to be produced.  The Future waits for the value to be produced, and the Promise
is a place to store the value to be acquired via the Future.  C++ even has the
<a href="https://en.cppreference.com/w/cpp/thread/async"><code class="language-plaintext highlighter-rouge">std::async</code></a> function in the standard library to launch an
asynchronous task in a new thread.</p>

<p>Recently many programming languages employed a style of asynchronous programming
language based on coroutines in the form of async/await.  I guess the reason
behind its gaining popularity is two fold:</p>

<ol>
  <li>
    <p>Native, OS-provided threads are too heavy-weight, but not many programming
languages support light-weight “M × N” green threads, that is, M OS threads
are multiplexed to run N application-level threads and N ≫ M.  AFAIK, only
Erlang and Go supports such light-weight threads.</p>
  </li>
  <li>
    <p>Not many languages support stackful coroutines.  As we discussed before,
stackful coroutines are only practical with swap-stack. Some languages (such
as Kotlin) are targeted to runtimes (such as JVM) that don’t support
swap-stack.</p>
  </li>
</ol>

<p>As a compromise, some languages resorted to coroutines.  They attempted to
implement cooperative multi-tasking using coroutines that yield when they are
about to block, and a scheduler that decides which coroutine can continue
without blocking.  And there is async/await.</p>

<p>A function can be annotated with the <code class="language-plaintext highlighter-rouge">async</code> keyword.  An async function is
like a Python generator.  When called, it doesn’t execute the body of the
function immediately, but will create an object that holds the execution context
of the function, like a frame.  An async function may contain <code class="language-plaintext highlighter-rouge">await</code>
expressions.  An <code class="language-plaintext highlighter-rouge">await</code> is like a conditional <code class="language-plaintext highlighter-rouge">yield</code>.  If a given <code class="language-plaintext highlighter-rouge">Future</code> is
ready, then grab the value and continue; otherwise, suspend the execution and
give control to the scheduler so that it can find something else to execute.</p>

<p>Async and await gives the programmer the feeling of multi-thread programming
except that the programmer must explicitly annotate places that may
<em>potentially</em> yield with <code class="language-plaintext highlighter-rouge">await</code>.</p>

<p>You can find an async/await example in JavaScript earlier in this post.  It
looks pretty like two threads communicating with each other using a channel.</p>

<h3 id="consequence-of-being-stackless">Consequence of being stackless</h3>

<p>Without proper swap-stack support, the compiler has to implement coroutines by
decomposing <code class="language-plaintext highlighter-rouge">async</code> functions into state machines.  <code class="language-plaintext highlighter-rouge">await</code> expressions are
places the function may yield, and each <code class="language-plaintext highlighter-rouge">await</code> represents a state in the state
machine.</p>

<p>However, async/await is not the only way to implement cooperative multi-task
programming on top of coroutines.  <a href="http://www.gevent.org/index.html">gevent</a> is a Python framework based on
<a href="https://greenlet.readthedocs.io/en/latest/index.html">Greenlets</a> which implement symmetric coroutines.  With the ability to
switch coroutine at any level of stack, each coroutine can yield to the
scheduler as part of potentially blocking functions (such as sleeping, IO
operations, etc.), and programmers do not need to annotate any expression with
<code class="language-plaintext highlighter-rouge">await</code>.</p>

<!--
vim: tw=80
-->]]></content><author><name>Kunshan Wang</name></author><category term="blog" /><category term="coroutine,rosettacode" /><summary type="html"><![CDATA[I’ll try to use coroutines to traverse nested lists, Rosetta Code style. That means I’ll do it in many different programming languages and libraries, including Ruby, Lua, Python (including greenlets), JavaScript, Rust, C#, etc. This task shows the difference between symmetric vs asymmetric coroutines, and stackful vs stackless coroutines. Note that this post alone may not be enough to teach you how to use coroutines in all those languages. I’ll also provide basic information about coroutines, swap-stack, async/await, etc. in the appendices.]]></summary></entry><entry><title type="html">A Wrong Name: Fifteen Years of TransitiveClosure in MMTk</title><link href="/blog/2022/05/16/fifteen-years-transitiveclosure.html" rel="alternate" type="text/html" title="A Wrong Name: Fifteen Years of TransitiveClosure in MMTk" /><published>2022-05-16T00:00:00+00:00</published><updated>2022-05-16T00:00:00+00:00</updated><id>/blog/2022/05/16/fifteen-years-transitiveclosure</id><content type="html" xml:base="/blog/2022/05/16/fifteen-years-transitiveclosure.html"><![CDATA[<p>The <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> interface in MMTk is confusing.  It should have been
split into two different interfaces, but not… until now.  What’s more
interesting is how we ended up having an interface like that 15 years ago, and
why it stayed that way since then.</p>

<h2 id="mmtk">MMTk?</h2>

<p>I have been contributing to the Memory Management Toolkit (MMTk) project since I
left Huawei.  <a href="https://www.mmtk.io/">MMTk</a> is a framework for garbage collection.  It was part of the
<a href="https://www.jikesrvm.org/">JikesRVM</a>, and has been a good platform for GC research.  Many state-of-the-art
garbage collection algorithms have been developed on it.  Now we are
re-implementing MMTk in Rust so that it can be integrated into many different
languages and VMs, such as OpenJDK, V8, Julia, GHC, PyPy and, of course
<a href="https://github.com/mmtk/mmtk-ruby/">Ruby</a> which I am working on.</p>

<p>As I started working on MMTk, one part of the code, that is, the
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code> interface/trait has always confused me.</p>

<h2 id="transitiveclosure">TransitiveClosure?</h2>

<p>In the core MMTk repository, the <a href="https://github.com/mmtk/mmtk-core">mmtk-core</a>, you can find the
<a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/plan/transitive_closure.rs#L12">TransitiveClosure</a> trait and its implementation for all
<code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> instances. (Let’s not worry about what <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code>
does for now.)</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TransitiveClosure</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">ProcessEdgesWork</span><span class="o">&gt;</span> <span class="n">TransitiveClosure</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">ProcessEdgesWork</span><span class="p">::</span><span class="nf">process_node</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The presence of <code class="language-plaintext highlighter-rouge">unreachable!();</code> startled me.  The code implemented one method
(<code class="language-plaintext highlighter-rouge">process_node</code>), but declared the other method (<code class="language-plaintext highlighter-rouge">process_edge</code>) unreachable.
This is not how we usually use traits.  When we define a trait with two methods,
we expect <em>both</em> methods to be callable on <em>all</em> instances. Otherwise, why do we
even have the <code class="language-plaintext highlighter-rouge">process_edge</code> method in <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> in the first place?</p>

<p>I guess <em>some</em> types must have implemented the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait <em>and</em>
provided a proper <code class="language-plaintext highlighter-rouge">process_edge</code> implementation.  And…  I am right.  It is
<a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/plan/transitive_closure.rs#L51">ObjectsClosure</a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">ProcessEdgesWork</span><span class="o">&gt;</span> <span class="n">TransitiveClosure</span> <span class="k">for</span> <span class="n">ObjectsClosure</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.buffer</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.buffer</span><span class="nf">.reserve</span><span class="p">(</span><span class="nn">E</span><span class="p">::</span><span class="n">CAPACITY</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.buffer</span><span class="nf">.push</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
        <span class="c1">// ... more code omitted.</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">unreachable!()</code> again?  What the <a href="https://www.dictionary.com/browse/wtf">…</a>!</p>

<p>Clearly <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> and <code class="language-plaintext highlighter-rouge">ObjectsClosure</code> are implementing two different
interfaces.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> only implements <code class="language-plaintext highlighter-rouge">process_node</code>, while</li>
  <li><code class="language-plaintext highlighter-rouge">ObjectsClosure</code> only implements <code class="language-plaintext highlighter-rouge">process_edge</code>.</li>
</ul>

<h2 id="should-we-split-transitiveclosure">Should we split TransitiveClosure?</h2>

<p>Maybe we should split it into <em>two different traits</em>, one contains
<code class="language-plaintext highlighter-rouge">process_node</code> and the other contains <code class="language-plaintext highlighter-rouge">process_edge</code>.  In this way, a type may
only implement the trait it needs, and not the <code class="language-plaintext highlighter-rouge">unreachable!()</code> stub.</p>

<p>Or, should we?</p>

<p>To confirm this, let’s find their call sites, and see whether we ever use both
methods at the same time.  The short answer is, no.</p>

<h3 id="the-process_node-method">The process_node method</h3>

<p><code class="language-plaintext highlighter-rouge">process_node</code> is only called by <code class="language-plaintext highlighter-rouge">XxxSpace::trace_object</code>, where <code class="language-plaintext highlighter-rouge">XxxSpace</code> is a
concrete space.  It can be <a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/policy/copyspace.rs#L156">CopySpace</a>, <a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/policy/mallocspace/global.rs#L244">MallocSpace</a>,
<a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/policy/largeobjectspace.rs#L170">LargeObjectSpace</a> and so on.</p>

<p><small><em><code class="language-plaintext highlighter-rouge">ImmixSpace</code> even has <a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/policy/immix/immixspace.rs#L317">two</a> <a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/policy/immix/immixspace.rs#L340">flavours</a> of
<code class="language-plaintext highlighter-rouge">trace_object</code>, both call <code class="language-plaintext highlighter-rouge">process_node</code>.</em></small></p>

<p>The <code class="language-plaintext highlighter-rouge">trace_object</code> method of a space visits an object during tracing.  It marks
or copies the object and, if it is the first time it visits an object, it
<em>enqueues</em> the object into the marking queue by calling the <code class="language-plaintext highlighter-rouge">process_node</code>
method which does the actual enqueuing.</p>

<h3 id="the-process_edge-method">The process_edge method</h3>

<p><code class="language-plaintext highlighter-rouge">process_edge</code> is only called by <code class="language-plaintext highlighter-rouge">VM::Scanning::scan_object</code>.</p>

<p><code class="language-plaintext highlighter-rouge">scan_object</code> is implemented by a VM binding (such as <a href="https://github.com/mmtk/mmtk-openjdk/blob/86c6f534ae57d03fa45e7a73b698f851c84ab943/mmtk/src/scanning.rs#L42">the OpenJDK
binding</a>) because it is VM-specific.  MMTk calls <code class="language-plaintext highlighter-rouge">scan_object</code>
when it needs the VM to locate all reference fields in an object.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Scanning</span><span class="o">&lt;</span><span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">scan_object</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">TransitiveClosure</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">trace</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
        <span class="n">tls</span><span class="p">:</span> <span class="n">VMWorkerThread</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="c1">// ... more code omitted</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">trait</code> parameter is a call-back.  When <code class="language-plaintext highlighter-rouge">scan_object(trace, object, tls)</code> is
called, it scans <code class="language-plaintext highlighter-rouge">object</code>, and calls <code class="language-plaintext highlighter-rouge">trace.process_edge</code> on each edge, i.e.
each reference field, of <code class="language-plaintext highlighter-rouge">object</code>.</p>

<h3 id="yes--they-are-different">Yes!  They are different!</h3>

<p>We confirmed that each of the two methods is used in a different scenario.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">process_node</code> is only used by <code class="language-plaintext highlighter-rouge">trace_object</code>, and</li>
  <li><code class="language-plaintext highlighter-rouge">process_edge</code> is only used by <code class="language-plaintext highlighter-rouge">scan_object</code>.</li>
</ul>

<p>And nothing calls both <code class="language-plaintext highlighter-rouge">process_node</code> and <code class="language-plaintext highlighter-rouge">process_edge</code> at the same time.</p>

<p>So let’s split them into two traits.</p>

<p>But my colleague <a href="https://qinsoon.com/">Yi Lin</a> reminded me that there were other classes that extends
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code> in the original MMTk in JikesRVM.  To be safe, I looked into
the original JikesRVM MMTk before making further decisions.</p>

<h2 id="back-in-jikesrvm">Back in JikesRVM</h2>

<p>Now we temporarily move away from Rust MMTk, and go back to JikesRVM MMTk.  If
the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait is designed like this in Rust, it must have its
roots back in JikesRVM.</p>

<h3 id="transitiveclosure-in-jikesrvm-mmtk">TransitiveClosure in JikesRVM MMTk</h3>

<p>In <a href="https://www.jikesrvm.org/">JikesRVM</a>, there is a class named <a href="https://github.com/JikesRVM/JikesRVM/blob/0b6002e7d746a829d56c90acfc4bb5c560faf634/MMTk/src/org/mmtk/plan/TransitiveClosure.java#L29">TransitiveClosure</a>.  Yes.
It is a <em>class</em>, not an interface.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Uninterruptible</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
  <span class="c1">// Other methods omitted...</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">source</span><span class="o">,</span> <span class="nc">Address</span> <span class="n">slot</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">VM</span><span class="o">.</span><span class="na">assertions</span><span class="o">.</span><span class="na">fail</span><span class="o">(</span><span class="s">"processEdge not implemented."</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">VM</span><span class="o">.</span><span class="na">assertions</span><span class="o">.</span><span class="na">fail</span><span class="o">(</span><span class="s">"processNode not implemented."</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Defining <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> as a class allows it to provide failing default
implementations of <code class="language-plaintext highlighter-rouge">processEdge</code> and <code class="language-plaintext highlighter-rouge">processNode</code>.  This allows its subclasses
to override one method while leaving the other failing.</p>

<p><small><em>(Note that the JikesRVM code was written before Java 8, so interface
methods could not have default implementations.)</em></small></p>

<h3 id="transitiveclosure-subclasses-in-jikesrvm-mmtk">TransitiveClosure subclasses in JikesRVM MMTk</h3>

<p>In JikesRVM, many classes inherit from <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>.</p>

<ul>
  <li>TransitiveClosure
    <ul>
      <li>TraceLocal
        <ul>
          <li>NoGCTraceLocal</li>
          <li>MSTraceLocal</li>
          <li>SSTraceLocal</li>
          <li>MCMarkTraceLocal</li>
          <li>MCForwardTraceLocal</li>
          <li>ImmixTraceLocal</li>
          <li>ImmixDefragTraceLocal</li>
          <li>…</li>
        </ul>
      </li>
      <li>RCZero</li>
      <li>RCModifiedProcessor</li>
      <li>GenRCModifiedProcessor</li>
      <li>ObjectReferenceBuffer
        <ul>
          <li>RCDecBuffer</li>
        </ul>
      </li>
      <li>TraceWriteBuffer</li>
    </ul>
  </li>
</ul>

<h3 id="tracelocal">TraceLocal</h3>

<p>Back in JikesRVM MMTk, there was no concept of “work packet”.  The abstraction
of tracing is the <code class="language-plaintext highlighter-rouge">Trace</code> class and its thread-local counterpart, <code class="language-plaintext highlighter-rouge">TraceLocal</code>.
<code class="language-plaintext highlighter-rouge">ThreadLocal</code> was the local context of a GC thread during tracing GC.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceLocal</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="nd">@Inline</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">values</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">object</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="nd">@Inline</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">source</span><span class="o">,</span> <span class="nc">Address</span> <span class="n">slot</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ObjectReference</span> <span class="n">object</span> <span class="o">=</span> <span class="no">VM</span><span class="o">.</span><span class="na">activePlan</span><span class="o">.</span><span class="na">global</span><span class="o">().</span><span class="na">loadObjectReference</span><span class="o">(</span><span class="n">slot</span><span class="o">);</span>
        <span class="nc">ObjectReference</span> <span class="n">newObject</span> <span class="o">=</span> <span class="n">traceObject</span><span class="o">(</span><span class="n">object</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">overwriteReferenceDuringTrace</span><span class="o">())</span> <span class="o">{</span>
            <span class="no">VM</span><span class="o">.</span><span class="na">activePlan</span><span class="o">.</span><span class="na">global</span><span class="o">().</span><span class="na">storeObjectReference</span><span class="o">(</span><span class="n">slot</span><span class="o">,</span> <span class="n">newObject</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// ... more code omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In JikesRVM, <code class="language-plaintext highlighter-rouge">TraceLocal</code> is the counterpart of both <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> and
<code class="language-plaintext highlighter-rouge">ObjectsClosure</code> of the current Rust MMTk.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Space.traceObject</code> calls <code class="language-plaintext highlighter-rouge">TraceLocal.processNode</code> to enqueues newly visited
objects,
    <ul>
      <li>just like <code class="language-plaintext highlighter-rouge">XxxSpace::trace_object</code> calling
<code class="language-plaintext highlighter-rouge">ProcessEdgesWork.process_node</code> in Rust MMTk.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> calls <code class="language-plaintext highlighter-rouge">TraceLocal.processEdge</code> to process each
reference field (edge),
    <ul>
      <li>just like <code class="language-plaintext highlighter-rouge">Scanning::scan_object</code> calling <code class="language-plaintext highlighter-rouge">ObjectsClosure.process_edge</code>
in Rust MMTk.</li>
    </ul>
  </li>
</ul>

<p>In JikesRVM MMTk, each plan (GC algorithm) defines its own <code class="language-plaintext highlighter-rouge">TraceLocal</code>
subclass.</p>

<p><small><em>(Some GC algorithms. such as MarkCompact and Immix, even have more than
one <code class="language-plaintext highlighter-rouge">TraceLocal</code> for different kinds of traces.)</em></small></p>

<p>It looks like the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> is a proper interface for <code class="language-plaintext highlighter-rouge">TraceLocal</code>.
It implements both <code class="language-plaintext highlighter-rouge">processNode</code> and <code class="language-plaintext highlighter-rouge">processEdge</code>.</p>

<p>However, <code class="language-plaintext highlighter-rouge">TraceLocal</code> is the only class that implements both <code class="language-plaintext highlighter-rouge">processNode</code> and
<code class="language-plaintext highlighter-rouge">processEdge</code>.  Other classes don’t.</p>

<h3 id="processedge-field-visitors">processEdge: Field visitors</h3>

<p>Some subclasses of <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> are related to reference counting (RC).
They are <code class="language-plaintext highlighter-rouge">RCZero</code>, <code class="language-plaintext highlighter-rouge">RCModifiedProcessor</code>, etc.  They only override the
<code class="language-plaintext highlighter-rouge">processEdge</code> method, assuming <code class="language-plaintext highlighter-rouge">processNode</code> is never called.</p>

<p>What do they do?</p>

<p>They are <strong>field visitors</strong>.  For example, <code class="language-plaintext highlighter-rouge">RCZero</code> visits edges and stores
<code class="language-plaintext highlighter-rouge">null</code> to each field.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">RCZero</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="c1">// Does not override processNode, leaving it failing</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">source</span><span class="o">,</span> <span class="nc">Address</span> <span class="n">slot</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slot</span><span class="o">.</span><span class="na">store</span><span class="o">(</span><span class="nc">ObjectReference</span><span class="o">.</span><span class="na">nullReference</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>During RC collection, <code class="language-plaintext highlighter-rouge">RCZero</code> is passed to <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> as the
callback to set all reference fields of an object to <code class="language-plaintext highlighter-rouge">null</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RCBaseCollector</span> <span class="kd">extends</span> <span class="nc">StopTheWorldCollector</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RCZero</span> <span class="n">zero</span><span class="o">;</span>  <span class="c1">// This implements TransitiveClosure</span>
    <span class="c1">// ... more code omitted</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">collectionPhase</span><span class="o">(</span><span class="kt">short</span> <span class="n">phaseId</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">primary</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ... more code omitted</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">phaseId</span> <span class="o">==</span> <span class="nc">RCBase</span><span class="o">.</span><span class="na">PROCESS_DECBUFFER</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// ... more code omitted</span>
            <span class="k">while</span> <span class="o">(!(</span><span class="n">current</span> <span class="o">=</span> <span class="n">decBuffer</span><span class="o">.</span><span class="na">pop</span><span class="o">()).</span><span class="na">isNull</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// ... more code omitted</span>
                <span class="no">VM</span><span class="o">.</span><span class="na">scanning</span><span class="o">.</span><span class="na">scanObject</span><span class="o">(</span><span class="n">zero</span><span class="o">,</span> <span class="n">current</span><span class="o">);</span>  <span class="c1">// Passing zero as callback</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Other RC-related classes are similar.  They record the fields or apply
decrements to the objects pointed by each field.</p>

<h3 id="processnode-to-enqueue-objects">processNode: to enqueue objects</h3>

<p>The <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> class only implements <code class="language-plaintext highlighter-rouge">processNode</code>.</p>

<p><small><em>(In fact, <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> is the only class that overrides
<code class="language-plaintext highlighter-rouge">processNode</code> but note <code class="language-plaintext highlighter-rouge">processEdge</code> throughout the history of
JikesRVM.)</em></small></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TraceWriteBuffer</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">WriteBuffer</span> <span class="n">buffer</span><span class="o">;</span>
    <span class="c1">// ... more code omitted</span>
    <span class="nd">@Inline</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">object</span><span class="o">.</span><span class="na">toAddress</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> is only used by <code class="language-plaintext highlighter-rouge">CMSMutator</code> (concurrent mark-sweep mutator).</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CMSMutator</span> <span class="kd">extends</span> <span class="nc">ConcurrentMutator</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">TraceWriteBuffer</span> <span class="n">remset</span><span class="o">;</span>
    <span class="c1">// ... more code omitted</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">checkAndEnqueueReference</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">ref</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ref</span><span class="o">.</span><span class="na">isNull</span><span class="o">())</span> <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">barrierActive</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">ref</span><span class="o">.</span><span class="na">isNull</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span>      <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">MARK_SWEEP</span><span class="o">,</span> <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">msSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>            <span class="c1">// here</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">IMMORTAL</span><span class="o">,</span>   <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">immortalSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>      <span class="c1">// here</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">LOS</span><span class="o">,</span>        <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">loSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>            <span class="c1">// here</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">NON_MOVING</span><span class="o">,</span> <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">nonMovingSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>     <span class="c1">// here</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">SMALL_CODE</span><span class="o">,</span> <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">smallCodeSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>     <span class="c1">// here</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">LARGE_CODE</span><span class="o">,</span> <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">largeCodeSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>     <span class="c1">// here</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// ... more code omitted</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In simple terms, the code above means “Trace the object <code class="language-plaintext highlighter-rouge">ref</code> in the space it is
in, and, if it is the first time the object is traced, enqueue it in <code class="language-plaintext highlighter-rouge">remset</code>.”</p>

<p>What’s in common between <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> and <code class="language-plaintext highlighter-rouge">TraceLocal</code> is that both of
them contain a buffer (a remember set, or the tracing queue) where the
<code class="language-plaintext highlighter-rouge">traceObject</code> method can enqueue newly visited objects to.  This is what
<code class="language-plaintext highlighter-rouge">processNode</code> is for, i.e. <em>enqueuing objects</em>.</p>

<h3 id="so-why-not-introducing-a-dedicated-interface">So why not introducing a dedicated interface?</h3>

<p>There comes an interesting question:</p>

<blockquote>
  <p><em>If some classes are just field visitors, why don’t we have a dedicated
  interface for it, and name it <code class="language-plaintext highlighter-rouge">FieldVisitor</code>?</em></p>
</blockquote>

<p>and</p>

<blockquote>
  <p><em>If some classes are just places to enqueue objects, why don’t we have a
  dedicated interface for it, and name it <code class="language-plaintext highlighter-rouge">ObjectBuffer</code>?</em></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">TransitiveClosure</code> has been there for 15 years.  Many developers have made
contributions to MMTk, and some of them must have noticed the issues I talked
about.  Why have <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> remained this way till today?</p>

<p>And why did we end up having this <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> amalgamation in the first
place?</p>

<h2 id="through-the-history">Through the history</h2>

<p>To answer these questions, I dug into the Git revision history of the JikesRVM
repository.</p>

<p>The <code class="language-plaintext highlighter-rouge">git blame</code> command can show me in which commit any line in any source file
is last modified.  I use <a href="https://github.com/tpope/vim-fugitive">vim-fugitive</a>, and it even allows me to follow a line
of code from one commit to another, and see every single change to a line of
code in history.</p>

<h3 id="early-days-of-object-scanning">Early days of object scanning</h3>

<p>The history of <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> is the history of object scanning interface
and implementation.</p>

<p><a href="https://github.com/JikesRVM/JikesRVM/tree/68e36aac633743a7930516eb4c7536240152dc1e">Back in 2003</a>, MMTk (was JMTk back then) and JikesRVM were
more tightly coupled than they are today.  Unlike the modern <code class="language-plaintext highlighter-rouge">Scanning</code>
interface, the <code class="language-plaintext highlighter-rouge">ScanObject</code> class back then contained concrete implementations
directly. The <a href="https://github.com/JikesRVM/JikesRVM/blob/68e36aac633743a7930516eb4c7536240152dc1e/rvm/src/vm/memoryManagers/JMTk/vmInterface/ScanObject.java#L42"><code class="language-plaintext highlighter-rouge">ScanObject.scan</code></a> method enumerates
reference fields, and directly calls the <code class="language-plaintext highlighter-rouge">Plan.traceObjectLocation</code> static
method, which does the load/traceObject/store sequence like our modern
<code class="language-plaintext highlighter-rouge">ProcessEdgesWork::process_edge</code> method.  Everything was hard-wired.  The
operation for visiting field was fixed.</p>

<p><a href="https://github.com/JikesRVM/JikesRVM/commit/e7bc7a0b35b96d3182a8cb53f9548c38c90de579">A commit in 2003</a> introduced the
<a href="https://github.com/JikesRVM/JikesRVM/blob/e7bc7a0b35b96d3182a8cb53f9548c38c90de579/rvm/src/vm/memoryManagers/JMTk/vmInterface/ScanObject.java#L64"><code class="language-plaintext highlighter-rouge">ScanObject.enumeratePointers</code></a> method which calls back to
<code class="language-plaintext highlighter-rouge">Plan.enumeratePointerLocation</code> which can be customised.  This allows a certain
degree of freedom of what to do with each field, instead of
load/traceObject/store.</p>

<p><a href="https://github.com/JikesRVM/JikesRVM/commit/e7195af9696795f20acb4eb841bc9beec8e7d412">Another commit in 2003</a> introduced the <code class="language-plaintext highlighter-rouge">Enumerate</code> class
which was subsequently renamed to <code class="language-plaintext highlighter-rouge">Enumerator</code> and <a href="https://github.com/JikesRVM/JikesRVM/commit/c2ff58e6a8499ad987ecb1c30a0f206f1036ef1c">made fully
abstract</a>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Enumerator</span> <span class="kd">implements</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">abstract</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enumeratePointerLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">location</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ScanObject.enumeratePointers</code> method then used <code class="language-plaintext highlighter-rouge">Enumerator</code> as the call
back instead calling into <code class="language-plaintext highlighter-rouge">Plan</code> directly, allowing the behavior of visiting
each edge to be fully customised.</p>

<p>As I conjectured, <em>some developers did notice that the call-back for
<code class="language-plaintext highlighter-rouge">scanObjects</code> should be customisable</em>, and <code class="language-plaintext highlighter-rouge">Enumerator</code> was introduced just for
that.</p>

<h3 id="in-2006-just-before-that-important-change">In 2006, just before that important change</h3>

<p>Both the <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> and <code class="language-plaintext highlighter-rouge">Scanning.enumeratePointers</code> existed in <a href="https://github.com/JikesRVM/JikesRVM/blob/600956237939e61b314535d485dfdfcbab2c0bbe/MMTk/src/org/mmtk/vm/Scanning.java">the
Scanning class</a> before late 2006.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Scanning</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">scanObject</span><span class="o">(</span><span class="nc">TraceLocal</span> <span class="n">trace</span><span class="o">,</span> <span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">enumeratePointers</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">,</span> <span class="nc">Enumerator</span> <span class="n">e</span><span class="o">);</span>
    <span class="c1">// ... more code omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Both <code class="language-plaintext highlighter-rouge">scanObject</code> and <code class="language-plaintext highlighter-rouge">enumeratePointers</code> enumerate reference fields in an
object.  However, they are used in totally different places.</p>

<h4 id="scanningscanobject">Scanning.scanObject</h4>

<p>The <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> method was used for tracing, as it took <code class="language-plaintext highlighter-rouge">TraceLocal</code>
as parameter, and called <code class="language-plaintext highlighter-rouge">TraceLocal.traceObjectLocation</code> for each reference
filed.</p>

<p>Note that at that time, <a href="https://github.com/JikesRVM/JikesRVM/blob/600956237939e61b314535d485dfdfcbab2c0bbe/MMTk/src/org/mmtk/plan/TraceLocal.java#L42">TraceLocal was a root
class</a>. There was no superclasses or interfaces
like <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> for it to extend/implement. (<code class="language-plaintext highlighter-rouge">Constants</code> is an
all-static interface, and <code class="language-plaintext highlighter-rouge">Uninterruptible</code> is just a marker.)  This means
<code class="language-plaintext highlighter-rouge">scanObject</code> was only applicable to subclasses of <code class="language-plaintext highlighter-rouge">TraceLocal</code>, and nothing
else.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceLocal</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span> <span class="c1">// no superclass</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span> <span class="c1">// traceObject calls this</span>
        <span class="n">values</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">object</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">root</span><span class="o">)</span> <span class="c1">// scanObject calls this</span>
            <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="nc">ObjectReference</span> <span class="n">object</span> <span class="o">=</span> <span class="n">objLoc</span><span class="o">.</span><span class="na">loadObjectReference</span><span class="o">();</span>
        <span class="nc">ObjectReference</span> <span class="n">newObject</span> <span class="o">=</span> <span class="n">traceObject</span><span class="o">(</span><span class="n">object</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
        <span class="n">objLoc</span><span class="o">.</span><span class="na">store</span><span class="o">(</span><span class="n">newObject</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// ... more code omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="scanningenumeratepointers">Scanning.enumeratePointers</h4>

<p>On the other hand, the <code class="language-plaintext highlighter-rouge">Scanning.enumeratePointers</code> could in theory be used by
any code that needs to enumerate reference fields.  At that time, it was used
for (deferred) reference counting.  The following was the “mark grey” operation
in trial-deletion for cycle collection in reference counting.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TrialDeletion</span> <span class="kd">extends</span> <span class="nc">CycleDetector</span>
        <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">TDGreyEnumerator</span> <span class="n">greyEnum</span><span class="o">;</span>  <span class="c1">// extends Enumerator</span>
    <span class="c1">// ... more code omitted</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">markGrey</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">,</span> <span class="kt">long</span> <span class="n">timeCap</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="c1">// ... more code omitted</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">object</span><span class="o">.</span><span class="na">isNull</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// ... more code omitted</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">abort</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nc">RefCountSpace</span><span class="o">.</span><span class="na">isGrey</span><span class="o">(</span><span class="n">object</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">RefCountSpace</span><span class="o">.</span><span class="na">makeGrey</span><span class="o">(</span><span class="n">object</span><span class="o">);</span>
                <span class="nc">Scan</span><span class="o">.</span><span class="na">enumeratePointers</span><span class="o">(</span><span class="n">object</span><span class="o">,</span> <span class="n">greyEnum</span><span class="o">);</span>  <span class="c1">// pay attention to this call site</span>
            <span class="o">}</span>
            <span class="n">object</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">abort</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// ... more code omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The call site of <code class="language-plaintext highlighter-rouge">Scan.enumeratePointers</code> passed a <code class="language-plaintext highlighter-rouge">TDGreyEnumerator</code> instance
which customised the behaviour of visiting fields.  It just forward the call to
<code class="language-plaintext highlighter-rouge">TrialDeletion.enumerateGrey</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TDGreyEnumerator</span> <span class="kd">extends</span> <span class="nc">Enumerator</span> <span class="kd">implements</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">TrialDeletion</span> <span class="n">td</span><span class="o">;</span>
    <span class="c1">// ... more code omitted</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enumeratePointerLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="n">td</span><span class="o">.</span><span class="na">enumerateGrey</span><span class="o">(</span><span class="n">objLoc</span><span class="o">.</span><span class="na">loadObjectReference</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="the-obvious-problem">The obvious problem</h4>

<p>We then had <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> for tracing, and <code class="language-plaintext highlighter-rouge">Scanning.enumeratePointers</code>
for RC.</p>

<p>But <em>why did we need both methods</em>?  <code class="language-plaintext highlighter-rouge">scanObject</code> was basically a special case
of <code class="language-plaintext highlighter-rouge">enumeratePointers</code> that called <code class="language-plaintext highlighter-rouge">TraceObject.enumeratePointerLocation</code>.</p>

<p>Could we <strong>unify</strong> them? Apparently someone noticed that, and he did a
refactoring.</p>

<h3 id="unifying-scanobject-and-enumeratepointers-with-tracestep">Unifying scanObject and enumeratePointers with “TraceStep”</h3>

<p>In late 2006, <a href="https://github.com/JikesRVM/JikesRVM/commit/64f538ca4d348f062f3afb313f519ffcbbbd22bd">someone created a commit</a> which
introduced a new version of reference counting collector, and at the same time
did “a huge refactoring” (see the commit message).</p>

<p>This commit created a class named <code class="language-plaintext highlighter-rouge">TraceStep</code>.  <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> then took
<code class="language-plaintext highlighter-rouge">TraceStep</code> as parameter instead of <code class="language-plaintext highlighter-rouge">TraceLocal</code>.  The <code class="language-plaintext highlighter-rouge">enumeratePointers</code>
method was removed.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceStep</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Scanning</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">scanObject</span><span class="o">(</span><span class="nc">TraceStep</span> <span class="n">trace</span><span class="o">,</span> <span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Obviously, <code class="language-plaintext highlighter-rouge">TraceStep</code> was intended to replaced <code class="language-plaintext highlighter-rouge">Enumerator</code> as the call-back
interface for <code class="language-plaintext highlighter-rouge">scanObject</code> to enumerating fields.  Both tracing and RC started
using <code class="language-plaintext highlighter-rouge">scanObject</code> from then on.</p>

<p>For tracing, the <code class="language-plaintext highlighter-rouge">TraceLocal</code> started to extend <code class="language-plaintext highlighter-rouge">TraceStep</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceLocal</span> <span class="kd">extends</span> <span class="nc">TraceStep</span>   <span class="c1">// Now extends TraceStep</span>
        <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">)</span> <span class="c1">// called by scanObject</span>
            <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="n">traceObjectLocation</span><span class="o">(</span><span class="n">objLoc</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">root</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="c1">// ... just like before</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>RC operations, such as “mark grey”, started extending <code class="language-plaintext highlighter-rouge">TraceStep</code> instead of
<code class="language-plaintext highlighter-rouge">Enumerator</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TrialDeletionGreyStep</span> <span class="kd">extends</span> <span class="nc">TraceStep</span>  <span class="c1">// Now extends TraceStep instead of Enumerator</span>
        <span class="kd">implements</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ObjectReference</span> <span class="n">object</span> <span class="o">=</span> <span class="n">objLoc</span><span class="o">.</span><span class="na">loadObjectReference</span><span class="o">();</span>
        <span class="o">((</span><span class="nc">TrialDeletionCollector</span><span class="o">)</span><span class="nc">CDCollector</span><span class="o">.</span><span class="na">current</span><span class="o">()).</span><span class="na">enumerateGrey</span><span class="o">(</span><span class="n">object</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TrialDeletionCollector</span> <span class="kd">extends</span> <span class="nc">CDCollector</span>
        <span class="kd">implements</span> <span class="nc">Uninterruptible</span><span class="o">,</span> <span class="nc">Constants</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TrialDeletionGreyStep</span> <span class="n">greyStep</span><span class="o">;</span>  <span class="c1">// A TraceStep instead of Enumerator</span>
    <span class="c1">// ... more code omitted</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">markGrey</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="c1">// ... more code omitted</span>
        <span class="nc">Scan</span><span class="o">.</span><span class="na">scanObject</span><span class="o">(</span><span class="n">greyStep</span><span class="o">,</span> <span class="n">object</span><span class="o">);</span>  <span class="c1">// now passes a TraceStep as arg</span>
        <span class="c1">// ... more code omitted</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This commit successfully unified the object scanning interface.
<code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> became the only object-scanning method. It became
applicable to all <code class="language-plaintext highlighter-rouge">TraceStep</code> instances alike, and was no longer coupled with
<code class="language-plaintext highlighter-rouge">TraceLocal</code>. Good! Nicely done!</p>

<p>More over, this commit cleverly found a concept that describes both
<code class="language-plaintext highlighter-rouge">TraceLocal</code> and the various operations in reference counting, such as “mark
grey”, “scan black”, etc.  It was <strong>“TraceStep”</strong>.  Intuitively, all of them
were steps of tracing.</p>

<p>But really?  We will soon find that it is not really that clever.</p>

<h3 id="here-comes-transitiveclosure">Here comes TransitiveClosure</h3>

<p>In 2007, someone made <a href="https://github.com/JikesRVM/JikesRVM/commit/f85c61257bbeda1efeed3a2f6a4ba5903cbe74e0">another commit</a> to “reorganise the core of
transitive closure”, and the motivations were “concurrent collection” and
“implementing prefetching during trace”.</p>

<p>In this commit, <code class="language-plaintext highlighter-rouge">TraceStep</code> was renamed to our familiar <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>.</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">TraceStep.traceObjectLocation</code> method was renamed to
<code class="language-plaintext highlighter-rouge">TransitiveClosure.processEdge</code>, and</li>
  <li>a new method <code class="language-plaintext highlighter-rouge">processNode</code> was added.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Uninterruptible</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
  <span class="cm">/**
   * Trace an edge during GC.
   *
   * @param objLoc The location containing the object reference.
   */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">VM</span><span class="o">.</span><span class="na">assertions</span><span class="o">.</span><span class="na">fail</span><span class="o">(</span><span class="s">"processEdge not implemented."</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="cm">/**
   * Trace a node during GC.
   *
   * @param object The object to be processed.
   */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">VM</span><span class="o">.</span><span class="na">assertions</span><span class="o">.</span><span class="na">fail</span><span class="o">(</span><span class="s">"processNode not implemented."</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that I didn’t add any <code class="language-plaintext highlighter-rouge">// ... more code omitted</code> comment because back in
2007, that was <a href="https://github.com/JikesRVM/JikesRVM/blob/f85c61257bbeda1efeed3a2f6a4ba5903cbe74e0/MMTk/src/org/mmtk/plan/TransitiveClosure.java#L29">the entire class body of <code class="language-plaintext highlighter-rouge">TransitiveClosure</code></a>.</p>

<p><code class="language-plaintext highlighter-rouge">TraceLocal</code> now extends <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> instead of <code class="language-plaintext highlighter-rouge">TraceStep</code>, and</p>

<ul>
  <li>the <code class="language-plaintext highlighter-rouge">traceObjectLocation</code> method was renamed to <code class="language-plaintext highlighter-rouge">processEdge</code>, and</li>
  <li>the <code class="language-plaintext highlighter-rouge">enqueue</code> method was renamed to <code class="language-plaintext highlighter-rouge">processNode</code>.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceLocal</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ... like before</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">source</span><span class="o">,</span> <span class="nc">Address</span> <span class="n">slot</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ... like before</span>
    <span class="o">}</span>
    <span class="c1">// ... more code omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<p>A few days later, <a href="https://github.com/JikesRVM/JikesRVM/commit/2257a7565c9920beb8455a6df0f8f6f8dbb2bae4">a subsequent commit</a> introduced a
<code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> class that extended <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> and overrode
<code class="language-plaintext highlighter-rouge">processNode</code> alone, and not <code class="language-plaintext highlighter-rouge">processEdge</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TraceWriteBuffer</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="c1">// ... more code omitted</span>
    <span class="nd">@Inline</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// .. as you have seen in previous sections.</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It remains the only class that overrides <code class="language-plaintext highlighter-rouge">processNode</code> but note <code class="language-plaintext highlighter-rouge">processEdge</code>
in the history of JikesRVM, even today.</p>

<p>With this change, <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> started to serve two distinct purposes.</p>

<ol>
  <li>the callback for <code class="language-plaintext highlighter-rouge">scanObject</code>, and</li>
  <li>the place to enqueue an object after tracing it.</li>
</ol>

<p>If a class was only used in one of the two cases, it would override only one of
the two methods.</p>

<h3 id="10-years-passed">10 years passed…</h3>

<p><code class="language-plaintext highlighter-rouge">TransitiveClosure</code> remained this way in JikesRVM MMTk since then.</p>

<p>And the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> class grew a little bit.  <a href="https://github.com/JikesRVM/JikesRVM/blob/5072f19761115d987b6ee162f49a03522d36c697/MMTk/src/org/mmtk/plan/TransitiveClosure.java#L32">Some static fields and
methods about specialised scanning</a> were added to it, as if
it were a good place to hold information for specialised scanning.</p>

<h3 id="and-there-was-rust-mmtk">…and there was Rust MMTk.</h3>

<p>In 2017, we started porting MMTk to Rust.</p>

<h4 id="porting-mmtk-to-rust">Porting MMTk to Rust</h4>

<p>The <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> was copied to the Rust version, except this time it
was represented as a Rust trait.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TransitiveClosure</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And <code class="language-plaintext highlighter-rouge">TraceLocal</code> was a trait that requires <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TraceLocal</span><span class="p">:</span> <span class="n">TransitiveClosure</span> <span class="p">{</span>
    <span class="c1">// ... other methods</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Scanning.scan_object</code> method took <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> as parameter, just
like JikesRVM MMTk.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Scanning</span><span class="o">&lt;</span><span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">scan_object</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">TransitiveClosure</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">trace</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
        <span class="n">tls</span><span class="p">:</span> <span class="n">OpaquePointer</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="c1">// ... more code omitted</span>
<span class="p">}</span>

</code></pre></div></div>

<p>And the <code class="language-plaintext highlighter-rouge">XxxSpace::trace_object</code> methods still took <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> as
parameter, like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="n">CopySpace</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">trace_object</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">TransitiveClosure</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">trace</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
        <span class="n">allocator</span><span class="p">:</span> <span class="n">Allocator</span><span class="p">,</span>
        <span class="n">tls</span><span class="p">:</span> <span class="n">OpaquePointer</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ObjectReference</span> <span class="p">{</span>

    <span class="c1">// ... more code omitted</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And <a href="https://github.com/mmtk/mmtk-core/blob/96855d287fe5ea789a532f347d6ee37e6679c71f/src/plan/tracelocal.rs">there was still TraceLocal</a>. (Not any more now.)</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TraceLocal</span><span class="p">:</span> <span class="n">TransitiveClosure</span> <span class="p">{</span>
    <span class="c1">// ... omitted.  There are many methods, but none is interesting here.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Like in JikesRVM MMTk,</p>

<ul>
  <li>the <code class="language-plaintext highlighter-rouge">scan_object</code> method still called <code class="language-plaintext highlighter-rouge">trace.process_edge</code> for each visited
edge, and</li>
  <li>the <code class="language-plaintext highlighter-rouge">trace_object</code> method still called <code class="language-plaintext highlighter-rouge">trace.process_node</code> to enqueue the
object on first visit.</li>
</ul>

<p>Initially, <em>we did not address the fact that TransitiveClosure served two
different purposes.</em> By that time, we had just begun porting MMTk to Rust.  <strong>We
prioritised making Rust MMTk working</strong>, and ported from JikesRVM MMTk in a style
closely resembled the original Java code.</p>

<p>And MMTk worked.  Not just worked, but worked for OpenJDK, JikesRVM and several
other VMs, too.</p>

<h4 id="introducing-work-packets">Introducing work packets</h4>

<p>We later removed <code class="language-plaintext highlighter-rouge">TraceLocal</code> and introduced the work packet system.</p>

<p>The work packet system represents each unit of work as a “packet” that can be
scheduled on any GC worker thread.  The <code class="language-plaintext highlighter-rouge">TraceLocal</code> class was replaced by two
work packets:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> work packet represents a list of edges to be traced.</li>
  <li>The <code class="language-plaintext highlighter-rouge">ScanObjects</code> work packet represents a list of objects to be scanned.</li>
</ul>

<p>A <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> work packet also carries an object queue inside it.  It
needs the <code class="language-plaintext highlighter-rouge">process_node</code> method so that <code class="language-plaintext highlighter-rouge">XxxSpace.trace_object</code> can call it and
queue newly visited objects.</p>

<p>Therefore, <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> implements TransitiveClosure because
<code class="language-plaintext highlighter-rouge">trace_object</code> expects it. And… remember?  That implementation startled me…</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">ProcessEdgesWork</span><span class="o">&gt;</span> <span class="n">TransitiveClosure</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">ProcessEdgesWork</span><span class="p">::</span><span class="nf">process_node</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then what visits edges when scanning an object?  It is now the <code class="language-plaintext highlighter-rouge">ObjectsClosure</code>
object.  It needs to provide <code class="language-plaintext highlighter-rouge">process_edge</code>, but <code class="language-plaintext highlighter-rouge">Scanning::scan_object</code> expects
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code>.</p>

<p>So we have to do what the <a href="https://www.dictionary.com/browse/wtf">…</a> we need to satisfy that requirement, as we
have seen before:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">ProcessEdgesWork</span><span class="o">&gt;</span> <span class="n">TransitiveClosure</span> <span class="k">for</span> <span class="n">ObjectsClosure</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.buffer</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.buffer</span><span class="nf">.reserve</span><span class="p">(</span><span class="nn">E</span><span class="p">::</span><span class="n">CAPACITY</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.buffer</span><span class="nf">.push</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
        <span class="c1">// ... more code omitted.</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>As you can see, <strong>even after we migrated to the work packet system, and even
though we no longer have any type that overrides both <code class="language-plaintext highlighter-rouge">process_edge</code> and
<code class="language-plaintext highlighter-rouge">process_node</code>, we still kept both <code class="language-plaintext highlighter-rouge">process_edge</code> and <code class="language-plaintext highlighter-rouge">process_node</code> in the
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait</strong>.</p>

<h2 id="why-do-we-end-up-having-transitiveclosure-like-this">Why do we end up having TransitiveClosure like this?</h2>

<p>We have been startled by smelly code.  We have <a href="https://www.dictionary.com/browse/wtf">expressed our anger, impatience,
surprise, etc., without explicit vulgarity</a>.  We have looked into JikesRVM
for the old MMTk.  We have gone through the history to see the change of the
object scanning interface, and read the commits from developers with the
intention of improving MMTk.</p>

<p>But why do we end up having a <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait like this?</p>

<h3 id="have-we-noticed-that-object-scanning-is-not-necessarily-part-of-tracing">Have we noticed that object scanning is not necessarily part of tracing?</h3>

<p>Yes.  The <a href="https://github.com/JikesRVM/JikesRVM/commit/c2ff58e6a8499ad987ecb1c30a0f206f1036ef1c"><code class="language-plaintext highlighter-rouge">Enumerator</code></a> interface was introduced just for
that.  When called back from <code class="language-plaintext highlighter-rouge">scan_object</code>, it allows us to do anything to
reference fields.</p>

<h3 id="have-we-refactored-scan_object-so-it-takes-a-simple-callback-instead-of-tracelocal">Have we refactored scan_object so it takes a simple callback instead of TraceLocal?</h3>

<p>Yes.  When <a href="https://github.com/JikesRVM/JikesRVM/commit/64f538ca4d348f062f3afb313f519ffcbbbd22bd"><code class="language-plaintext highlighter-rouge">TraceStep</code></a> was introduced, We unified
<code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> and <code class="language-plaintext highlighter-rouge">Scanning.enumeratePointers</code>.  <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code>
was refactored to only depend on <code class="language-plaintext highlighter-rouge">TraceStep</code>, and <code class="language-plaintext highlighter-rouge">TraceStep</code> was an abstract
class with only an abstract method <code class="language-plaintext highlighter-rouge">traceObjectLocation(Address objLoc)</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceStep</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Scanning</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">scanObject</span><span class="o">(</span><span class="nc">TraceStep</span> <span class="n">trace</span><span class="o">,</span> <span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This should have been the ideal interface for <code class="language-plaintext highlighter-rouge">Scanning.scan_object</code> for MMTk in
Java.  (Rust could use closure to make it more concise.)</p>

<h3 id="but-why-did-we-migrate-away-from-it">But why did we migrate away from it?</h3>

<p>Probably only the author of <a href="https://github.com/JikesRVM/JikesRVM/commit/f85c61257bbeda1efeed3a2f6a4ba5903cbe74e0">this commit</a> knows the exact reason.</p>

<p>To my understanding, I think it was because <strong><code class="language-plaintext highlighter-rouge">TraceStep</code> was such a good, but
a wrong, name</strong>.</p>

<ol>
  <li>
    <p>We named it “TraceStep”.</p>
  </li>
  <li>
    <p>We made it the superclass of <code class="language-plaintext highlighter-rouge">TraceLocal</code>.</p>
  </li>
  <li>
    <p>We then <a href="https://github.com/JikesRVM/JikesRVM/commit/2257a7565c9920beb8455a6df0f8f6f8dbb2bae4">introduced TraceWriteBuffer</a>.</p>
  </li>
  <li>
    <p>We noticed <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> was another place to enqueue objects in
addition to <code class="language-plaintext highlighter-rouge">TraceLocal</code>.</p>
  </li>
  <li>
    <p>Then we naturally thought that both <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> and <code class="language-plaintext highlighter-rouge">TraceLocal</code>
should have a common superclass that had a method named <code class="language-plaintext highlighter-rouge">enqueue</code>.</p>

    <p>But <code class="language-plaintext highlighter-rouge">TraceStep</code> doesn’t have <code class="language-plaintext highlighter-rouge">enqueue</code>.</p>
  </li>
  <li>
    <p>Then we extended <code class="language-plaintext highlighter-rouge">TraceStep</code> into <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>, and added <code class="language-plaintext highlighter-rouge">enqueue</code>.</p>

    <p>And we even renamed <code class="language-plaintext highlighter-rouge">enqueue</code> to <code class="language-plaintext highlighter-rouge">processNode</code> to make it consistent with
<code class="language-plaintext highlighter-rouge">processEdge</code>.</p>
  </li>
  <li>
    <p>Then we have <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> which had <code class="language-plaintext highlighter-rouge">processEdge</code> and <code class="language-plaintext highlighter-rouge">processNode</code>.</p>
  </li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceLocal</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TraceWriteBuffer</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Wow!  “TransitiveClosure” was an even better name!  That was what <code class="language-plaintext highlighter-rouge">TraceLocal</code>
really was, i.e. computing the transitive closure of an object graph!  A
“transitive closure” is a graph!  A graph has nodes and edges!</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> doesn’t override <code class="language-plaintext highlighter-rouge">processEdge</code>, and <code class="language-plaintext highlighter-rouge">RCZero</code> doesn’t
override <code class="language-plaintext highlighter-rouge">processNode</code>!</p>

<p>No worries.  We leave them “unreachable”.</p>

<p>“Unreachable”?  That doesn’t sound right.</p>

<p>But it worked… for 15 years.</p>

<p>The name “TransitiveClosure”  made so much sense that we stuck to
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code> forever, even after we ported MMTk to Rust.</p>

<h3 id="but-tracestep-is-a-wrong-name">But TraceStep is a wrong name.</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">TraceLocal</code>, “mark grey”, “scan black”, <code class="language-plaintext highlighter-rouge">RCZero</code> and so on are all steps in
tracing,</li>
  <li>and those trace steps process edges,</li>
  <li>hence <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> should accept <code class="language-plaintext highlighter-rouge">TraceStep</code> as a call-back
argument, so <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> can give <code class="language-plaintext highlighter-rouge">TraceStep</code> edges to process.</li>
</ol>

<p>Wrong.</p>

<p><code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> accepts a callback argument not because the callback is a
step of tracing, but simply <strong>because the callback visits edges</strong>.</p>

<p>I don’t really know what counts as a “trace step”.</p>

<ul>
  <li>Does “assigning <code class="language-plaintext highlighter-rouge">null</code> to each reference field” count as a “trace step”?</li>
  <li>Does “applying decrement operations to the reference counts of all neighbor
objects” count as a “trace step” even if it is used in reference counting,
only?</li>
  <li>Is trial-deletion considered as a kind of tracing at all?</li>
</ul>

<p>No matter what it is, isn’t it much easier to just say</p>

<blockquote>
  <p><em>“<code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> accepts it as a callback argument because it visits
  edges.”</em></p>
</blockquote>

<h3 id="the-nature-of-interfaces">The nature of interfaces.</h3>

<p>This is the nature of interfaces.  A reuseable component should not make
assumptions about its neighbours more than necessary.  This is <strong>the
separation of concern</strong>.</p>

<p>It is just like when we do the following in rust:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.foreach</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Iterator::foreach</code> function accepts this closure not because it prints
things, but because it visits elements.  <code class="language-plaintext highlighter-rouge">foreach</code> is intended for visiting
elements.  The closure receives the object.  That is the contract of the
<code class="language-plaintext highlighter-rouge">foreach</code> method.  Whether it prints the element or how it prints the element is
not part of the contract.</p>

<p>So “Enumerator” was a right name.  It correctly describes the role of the object
in a <code class="language-plaintext highlighter-rouge">scanObject</code> invocation, that is, <em>“it enumerates fields”</em>, nothing more.
That’s all what <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> need to care about.  It passes each field
to the callback, and that’s it.  It should not assume what that callback object
does to each edge.  Whether it is a <code class="language-plaintext highlighter-rouge">TraceLocal</code> or an RC operation is beyond
its obligation.</p>

<p>“TraceStep” was wrong.  “TransitiveClosure” was also wrong.  Neither of them
is what <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> cares about.</p>

<h2 id="finding-the-way-out">Finding the way out</h2>

<p>We have seen the history, and know why it ended up like this.</p>

<p>We know what was wrong, and what would be right.</p>

<p>“Enumerator” was right.  “TraceStep” was wrong.  “TransitiveClosure” was wrong,
too, but it just sounded so good.</p>

<p>No matter how good it sounds, we need to fix it.</p>

<p>From our analysis in the beginning of this article, we should split
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code> into two traits,</p>

<ol>
  <li>one as the callback of <code class="language-plaintext highlighter-rouge">Scanning::scan_object</code>, and</li>
  <li>the other to be used by <code class="language-plaintext highlighter-rouge">XxxSpace::trace_object</code> to enqueue object.</li>
</ol>

<p>I have opened an <a href="https://github.com/mmtk/mmtk-core/issues/559">issue</a>, and detailed the steps of
splitting and removing <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> from <code class="language-plaintext highlighter-rouge">mmtk-core</code>.</p>

<h3 id="refactoring-scanningscan_object">Refactoring Scanning::scan_object</h3>

<p><code class="language-plaintext highlighter-rouge">Scanning::scan_object</code> takes an object and a callback as parameters.  It will
find all reference fields in the object, and invoke the callback for each
reference field.</p>

<p>We need a proper name for the callback of <code class="language-plaintext highlighter-rouge">Scanning::scan_object</code>.</p>

<p>I name it <code class="language-plaintext highlighter-rouge">EdgeVisitor</code>, and its only method is, as you can imagine,
<code class="language-plaintext highlighter-rouge">visit_edge</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">EdgeVisitor</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">visit_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="n">Address</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And it replaces <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> as the parameter type of
<code class="language-plaintext highlighter-rouge">Scanning::scan_object</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Scanning</span><span class="o">&lt;</span><span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">scan_object</span><span class="o">&lt;</span><span class="n">EV</span><span class="p">:</span> <span class="n">EdgeVisitor</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">tls</span><span class="p">:</span> <span class="n">VMWorkerThread</span><span class="p">,</span>
        <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
        <span class="n">edge_visitor</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">EV</span><span class="p">,</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then the only callback that have ever been passed to <code class="language-plaintext highlighter-rouge">Scanning::scan_object</code>,
i.e. <code class="language-plaintext highlighter-rouge">ObjectsClosure</code>, now implements <code class="language-plaintext highlighter-rouge">EdgeVisitor</code>, instead.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">ProcessEdgesWork</span><span class="o">&gt;</span> <span class="n">EdgeVisitor</span> <span class="k">for</span> <span class="n">ObjectsClosure</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">visit_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... code omitted</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And this change has been <a href="https://github.com/mmtk/mmtk-core/commit/0babba20290d3c4e4cdb2a83284aa7204c9a23cc">merged</a> into the master branch of
<code class="language-plaintext highlighter-rouge">mmtk-core</code>.</p>

<h4 id="meanwhile-in-australia">Meanwhile in Australia…</h4>

<p>While I was refactoring <code class="language-plaintext highlighter-rouge">mmtk-core</code> and working on <code class="language-plaintext highlighter-rouge">mmtk-ruby</code>, my colleague
<a href="https://wenyu.me/">Wenyu Zhao</a> was busy with <a href="https://users.cecs.anu.edu.au/~steveb/pubs/papers/lxr-pldi-2022.pdf">his paper about the LXC GC algorithm</a> targetting <a href="https://pldi22.sigplan.org/details/pldi-2022-pldi/15/Low-Latency-High-Throughput-Garbage-Collection">PLDI 2022</a>.</p>

<p>Wenyu <a href="https://github.com/wenyuzhao/mmtk-core/commit/9587aca2c62e02e043a5f01c3488cd91e21515b0">independently introduced</a> the
<a href="https://github.com/wenyuzhao/mmtk-core/blob/9587aca2c62e02e043a5f01c3488cd91e21515b0/src/plan/transitive_closure.rs#L88"><code class="language-plaintext highlighter-rouge">EdgeIterator</code></a> struct.  It is a wrapper over
<code class="language-plaintext highlighter-rouge">Scanning::scan_object</code> and <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>, and the <code class="language-plaintext highlighter-rouge">unreachable!()</code>
statement, too! :P</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">EdgeIterator</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span> <span class="o">+</span> <span class="nv">'a</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">_p</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="n">EdgeIterator</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">VM</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iterate</span><span class="p">(</span><span class="n">o</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span> <span class="p">{</span> <span class="n">f</span><span class="p">:</span> <span class="k">box</span> <span class="n">f</span><span class="p">,</span> <span class="n">_p</span><span class="p">:</span> <span class="n">PhantomData</span> <span class="p">};</span>
        <span class="o">&lt;</span><span class="nn">VM</span><span class="p">::</span><span class="n">VMScanning</span> <span class="k">as</span> <span class="n">Scanning</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">scan_object</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="nf">VMWorkerThread</span><span class="p">(</span><span class="nn">VMThread</span><span class="p">::</span><span class="n">UNINITIALIZED</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="n">TransitiveClosure</span> <span class="k">for</span> <span class="n">EdgeIterator</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">VM</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.f</span><span class="p">)(</span><span class="n">slot</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this struct, it allows a closure to be used in the place of a
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code>.  The following code applies the <code class="language-plaintext highlighter-rouge">inc</code> RC operation to all
adjacent objects:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">EdgeIterator</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">E</span><span class="p">::</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">iterate</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="p">|</span><span class="n">edge</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.inc</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span> <span class="n">edge</span><span class="nf">.load</span><span class="p">()</span> <span class="p">});</span>
<span class="p">})</span>
</code></pre></div></div>

<p>And the following applies <code class="language-plaintext highlighter-rouge">dec</code>, and optionally frees the object:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">EdgeIterator</span><span class="p">::</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">iterate</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">|</span><span class="n">edge</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">edge</span><span class="py">.load</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ObjectReference</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">t</span><span class="nf">.is_null</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">Ok</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="k">super</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nf">dec</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">super</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nf">is_dead</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
            <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Pretty neat, isn’t it?  It is so neat that I want to steal the code and add an
<code class="language-plaintext highlighter-rouge">EdgeVisitor::from_closure</code> factory method for my <code class="language-plaintext highlighter-rouge">EdgeVisitor</code>.</p>

<p>One interesting thing is, Wenyu introduced this for reference counting,
according to the <a href="https://github.com/wenyuzhao/mmtk-core/commit/9587aca2c62e02e043a5f01c3488cd91e21515b0">commit message</a>.  What a coincidence!  Daniel
<a href="https://github.com/JikesRVM/JikesRVM/commit/64f538ca4d348f062f3afb313f519ffcbbbd22bd">introduced <code class="language-plaintext highlighter-rouge">TraceStep</code> in 2006</a> for exactly the same
reason: reference counting, according to its commit message, too.
Understandably, reference counting is very different from tracing.  RC needs to
scan objects, but not for tracing, so passing <code class="language-plaintext highlighter-rouge">TraceLocal</code> to <code class="language-plaintext highlighter-rouge">scan_object</code>
doesn’t make sense.  Therefore, those additional operations, be it mark-grey,
scan-black or just freeing objects, all define their own callbacks to be called
by <code class="language-plaintext highlighter-rouge">scan_object</code>. This necessitates the creation of a better interface for the
callback of <code class="language-plaintext highlighter-rouge">scan_object</code>.</p>

<h3 id="refactoring-spacetrace_object">Refactoring Space::trace_object</h3>

<p>The <code class="language-plaintext highlighter-rouge">XxxSpace::trace_object</code> method usually has this form:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="n">CopySpace</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">trace_object</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">TransitiveClosure</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">trace</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
        <span class="n">semantics</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">CopySemantics</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">worker</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">GCWorker</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ObjectReference</span> <span class="p">{</span>
        <span class="c1">// ... more code omitted</span>
        <span class="k">if</span> <span class="cm">/* is first visited */</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">new_object</span> <span class="o">=</span> <span class="nn">object_forwarding</span><span class="p">::</span><span class="nn">forward_object</span><span class="p">::</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>

            <span class="n">trace</span><span class="nf">.process_node</span><span class="p">(</span><span class="n">new_object</span><span class="p">);</span>  <span class="c1">// enqueue object</span>
            <span class="n">new_object</span>  <span class="c1">// return the forwarded obj ref</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ... more code omitted</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If an object is first visited, it enqueues the object in <code class="language-plaintext highlighter-rouge">trace</code>, and returns
the forwarded object reference.</p>

<p>This method is polymorphic w.r.t. <code class="language-plaintext highlighter-rouge">T</code>.  <code class="language-plaintext highlighter-rouge">T</code> is the <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> (a
sub-trait of <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>) type used by the plan.  We used to have one
different <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> type for each plan, which made this generic type
parameter necessary.</p>

<p>We already <a href="https://github.com/mmtk/mmtk-core/issues/110#issuecomment-954335561">noticed</a> that we may safely remove this
only use case of the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait (i.e. <code class="language-plaintext highlighter-rouge">trace_object</code>) once we
remove plan-specific <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> implementations. And the good thing is,
we have recently just <a href="https://github.com/mmtk/mmtk-core/commit/93281e9563fb5a780b880c086f67c75fc66bc8f8">removed</a> all plan-specific
<code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> implementations. Although we are not sure whether we will
have plan-specific <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> for complex GC algorithms in the future, I
think the code is much cleaner for a refactoring.</p>

<p>However, I <a href="https://github.com/mmtk/mmtk-core/issues/559">believe</a> the <code class="language-plaintext highlighter-rouge">trace</code> parameter is
completely unnecessary.  We just need a return value to indicate whether it is
the first time the object is visited, so that the <em>caller</em> of <code class="language-plaintext highlighter-rouge">trace_object</code>
(which is only <code class="language-plaintext highlighter-rouge">ProcessEdgesWork::process_edge</code> at this time) can enqueue the
object.  So instead of</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">object</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">slot</span><span class="py">.load</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ObjectReference</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">new_object</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.trace_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
    <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="n">OVERWRITE_REFERENCE</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">slot</span><span class="nf">.store</span><span class="p">(</span><span class="n">new_object</span><span class="p">)</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>we shall have</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">object</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">slot</span><span class="py">.load</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ObjectReference</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">new_object</span><span class="p">,</span> <span class="n">first_visit</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.trace_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
    <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="n">OVERWRITE_REFERENCE</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">slot</span><span class="nf">.store</span><span class="p">(</span><span class="n">new_object</span><span class="p">)</span> <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">first_visit</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.enqueue</span><span class="p">(</span><span class="n">new_object</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>However, the <code class="language-plaintext highlighter-rouge">#[inline]</code> above <code class="language-plaintext highlighter-rouge">trace_object</code> indicates that it is very
performance-critical.  We’d better measure before making the decision to change.</p>

<h2 id="epilogue">Epilogue</h2>

<p>After fifteen years, the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait is finally going to change.</p>

<p>The Rust MMTk is under active development now.  As we proceed, we may see more
things like this, things that have remained in its current state for years, or
even decades.  But this doesn’t mean they are always right.  We have to rethink
about the code again and again, and fix the problems whenever we can.</p>

<h2 id="update">Update</h2>

<p>We eventually <a href="https://github.com/mmtk/mmtk-core/pull/607">removed</a> <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> as well as the stale
<code class="language-plaintext highlighter-rouge">TraceLocal</code> trait from <code class="language-plaintext highlighter-rouge">mmtk-core</code>.  However, unlike we discussed in previous
sections, we did not remove the <code class="language-plaintext highlighter-rouge">trace</code> parameter from <code class="language-plaintext highlighter-rouge">trace_object</code>.  We think
“enqueuing objects” is still a responsibility of the <code class="language-plaintext highlighter-rouge">trace_object</code> method, so
we should still enqueue objects in <code class="language-plaintext highlighter-rouge">trace_object</code> instead of in <code class="language-plaintext highlighter-rouge">process_edges</code>
using the return value.  Therefore, we simply renamed <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> to
<code class="language-plaintext highlighter-rouge">ObjectQueue</code>, and renamed <code class="language-plaintext highlighter-rouge">process_node</code> to <code class="language-plaintext highlighter-rouge">enqueue</code>, so they indicate exactly
what they do.  And now it is the actual object queue instead of
<code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> that implements <code class="language-plaintext highlighter-rouge">ObjectQueue</code>.</p>

<p>The signature of <code class="language-plaintext highlighter-rouge">CopySpace::trace_object</code> now looks like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[inline(always)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">trace_object</span><span class="o">&lt;</span><span class="n">Q</span><span class="p">:</span> <span class="n">ObjectQueue</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">queue</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Q</span><span class="p">,</span>
    <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
    <span class="n">semantics</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">CopySemantics</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">worker</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">GCWorker</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ObjectReference</span> <span class="p">{</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">ObjectQueue</code> is still a trait.  It does not have to be a physical
queue.  If a GC algorithm does not hold objects in a queue during tracing, it
can implement this trait and process the “enqueued” object immediatey.</p>

<h2 id="see-also">See also</h2>

<p>The tracking issue: https://github.com/mmtk/mmtk-core/issues/559</p>

<!--
vim: tw=80
-->]]></content><author><name>Kunshan Wang</name></author><category term="blog" /><category term="mmtk" /><summary type="html"><![CDATA[The TransitiveClosure interface in MMTk is confusing. It should have been split into two different interfaces, but not… until now. What’s more interesting is how we ended up having an interface like that 15 years ago, and why it stayed that way since then.]]></summary></entry><entry><title type="html">Hello world!</title><link href="/blog/2022/04/15/Hello-world.html" rel="alternate" type="text/html" title="Hello world!" /><published>2022-04-15T00:00:00+00:00</published><updated>2022-04-15T00:00:00+00:00</updated><id>/blog/2022/04/15/Hello-world</id><content type="html" xml:base="/blog/2022/04/15/Hello-world.html"><![CDATA[<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
incididunt ut labore et dolore magna aliqua. A erat nam at lectus urna duis
convallis convallis. Augue mauris augue neque gravida in fermentum et
sollicitudin ac. Ante in nibh mauris cursus mattis molestie a. Cras pulvinar
mattis nunc sed blandit libero volutpat sed cras. Duis ultricies lacus sed
turpis tincidunt id. Elementum eu facilisis sed odio morbi quis commodo odio.
Quisque non tellus orci ac auctor augue mauris. Amet consectetur adipiscing
elit pellentesque habitant morbi tristique senectus. Euismod elementum nisi
quis eleifend quam adipiscing vitae. Diam maecenas sed enim ut sem viverra
aliquet eget. Habitant morbi tristique senectus et netus et. Facilisi nullam
vehicula ipsum a. Mi proin sed libero enim sed. Lacus vel facilisis volutpat
est.</p>

<p>Malesuada pellentesque elit eget gravida cum sociis natoque. Dolor magna eget
est lorem ipsum dolor. Id eu nisl nunc mi ipsum faucibus. Elit eget gravida cum
sociis natoque penatibus et. Augue interdum velit euismod in pellentesque massa
placerat duis ultricies. Aliquet eget sit amet tellus cras adipiscing enim eu
turpis. Nisl pretium fusce id velit ut tortor. Non enim praesent elementum
facilisis. Libero volutpat sed cras ornare arcu dui vivamus arcu. Molestie nunc
non blandit massa enim. Nam aliquam sem et tortor consequat. Turpis egestas sed
tempus urna et pharetra pharetra. Nisi vitae suscipit tellus mauris a diam
maecenas. Praesent tristique magna sit amet purus gravida quis. Convallis
tellus id interdum velit laoreet.</p>

<p>In hac habitasse platea dictumst vestibulum. Urna neque viverra justo nec
ultrices. Amet nisl purus in mollis. Ut lectus arcu bibendum at varius vel
pharetra vel turpis. Facilisi nullam vehicula ipsum a arcu cursus vitae congue.
Ornare arcu dui vivamus arcu. Volutpat commodo sed egestas egestas fringilla
phasellus faucibus scelerisque eleifend. Et pharetra pharetra massa massa
ultricies mi. At augue eget arcu dictum varius duis at consectetur. Amet massa
vitae tortor condimentum lacinia quis vel eros.</p>

<p>Tellus pellentesque eu tincidunt tortor aliquam nulla facilisi cras fermentum.
Feugiat nisl pretium fusce id velit. Dictum at tempor commodo ullamcorper a.
Quam vulputate dignissim suspendisse in. Massa id neque aliquam vestibulum
morbi blandit cursus risus. Laoreet sit amet cursus sit amet dictum sit amet.
Cursus vitae congue mauris rhoncus aenean vel elit. Phasellus vestibulum lorem
sed risus. Et netus et malesuada fames ac. Pharetra magna ac placerat
vestibulum lectus mauris ultrices eros in. Proin sed libero enim sed faucibus
turpis in. Sed vulputate mi sit amet mauris commodo quis. Egestas tellus rutrum
tellus pellentesque eu tincidunt tortor aliquam. Consectetur purus ut faucibus
pulvinar elementum integer enim. Elementum tempus egestas sed sed risus.
Molestie ac feugiat sed lectus vestibulum mattis ullamcorper. Convallis a cras
semper auctor neque vitae tempus quam pellentesque. Nunc vel risus commodo
viverra. Nam libero justo laoreet sit amet cursus. Elit duis tristique
sollicitudin nibh sit amet commodo nulla.</p>

<p>In ante metus dictum at tempor commodo ullamcorper a lacus. Id eu nisl nunc mi
ipsum faucibus. Semper eget duis at tellus at. Proin sagittis nisl rhoncus
mattis rhoncus. Habitasse platea dictumst vestibulum rhoncus est pellentesque.
Eget felis eget nunc lobortis mattis aliquam. Risus sed vulputate odio ut enim
blandit volutpat maecenas volutpat. Viverra nibh cras pulvinar mattis nunc sed
blandit libero. Ut venenatis tellus in metus vulputate. Aliquam sem et tortor
consequat id. Suspendisse ultrices gravida dictum fusce ut placerat orci nulla.</p>]]></content><author><name>Kunshan Wang</name></author><category term="blog" /><summary type="html"><![CDATA[Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. A erat nam at lectus urna duis convallis convallis. Augue mauris augue neque gravida in fermentum et sollicitudin ac. Ante in nibh mauris cursus mattis molestie a. Cras pulvinar mattis nunc sed blandit libero volutpat sed cras. Duis ultricies lacus sed turpis tincidunt id. Elementum eu facilisis sed odio morbi quis commodo odio. Quisque non tellus orci ac auctor augue mauris. Amet consectetur adipiscing elit pellentesque habitant morbi tristique senectus. Euismod elementum nisi quis eleifend quam adipiscing vitae. Diam maecenas sed enim ut sem viverra aliquet eget. Habitant morbi tristique senectus et netus et. Facilisi nullam vehicula ipsum a. Mi proin sed libero enim sed. Lacus vel facilisis volutpat est.]]></summary></entry></feed>