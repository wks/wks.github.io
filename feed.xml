<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-09-27T13:02:37+00:00</updated><id>/feed.xml</id><title type="html">Kunshan Wang</title><subtitle>Kunshan Wang&apos;s Personal Web Site</subtitle><author><name>Kunshan Wang</name></author><entry><title type="html">A Wrong Name: Fifteen Years of TransitiveClosure in MMTk</title><link href="/blog/2022/05/16/fifteen-years-transitiveclosure.html" rel="alternate" type="text/html" title="A Wrong Name: Fifteen Years of TransitiveClosure in MMTk" /><published>2022-05-16T00:00:00+00:00</published><updated>2022-05-16T00:00:00+00:00</updated><id>/blog/2022/05/16/fifteen-years-transitiveclosure</id><content type="html" xml:base="/blog/2022/05/16/fifteen-years-transitiveclosure.html"><![CDATA[<p>The <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> interface in MMTk is confusing.  It should have been
split into two different interfaces, but not… until now.  What’s more
interesting is how we ended up having an interface like that 15 years ago, and
why it stayed that way since then.</p>

<h2 id="mmtk">MMTk?</h2>

<p>I have been contributing to the Memory Management Toolkit (MMTk) project since I
left Huawei.  <a href="https://www.mmtk.io/">MMTk</a> is a framework for garbage collection.  It was part of the
<a href="https://www.jikesrvm.org/">JikesRVM</a>, and has been a good platform for GC research.  Many state-of-the-art
garbage collection algorithms have been developed on it.  Now we are
re-implementing MMTk in Rust so that it can be integrated into many different
languages and VMs, such as OpenJDK, V8, Julia, GHC, PyPy and, of course
<a href="https://github.com/mmtk/mmtk-ruby/">Ruby</a> which I am working on.</p>

<p>As I started working on MMTk, one part of the code, that is, the
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code> interface/trait has always confused me.</p>

<h2 id="transitiveclosure">TransitiveClosure?</h2>

<p>In the core MMTk repository, the <a href="https://github.com/mmtk/mmtk-core">mmtk-core</a>, you can find the
<a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/plan/transitive_closure.rs#L12">TransitiveClosure</a> trait and its implementation for all
<code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> instances. (Let’s not worry about what <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code>
does for now.)</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TransitiveClosure</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">ProcessEdgesWork</span><span class="o">&gt;</span> <span class="n">TransitiveClosure</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">ProcessEdgesWork</span><span class="p">::</span><span class="nf">process_node</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The presence of <code class="language-plaintext highlighter-rouge">unreachable!();</code> startled me.  The code implemented one method
(<code class="language-plaintext highlighter-rouge">process_node</code>), but declared the other method (<code class="language-plaintext highlighter-rouge">process_edge</code>) unreachable.
This is not how we usually use traits.  When we define a trait with two methods,
we expect <em>both</em> methods to be callable on <em>all</em> instances. Otherwise, why do we
even have the <code class="language-plaintext highlighter-rouge">process_edge</code> method in <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> in the first place?</p>

<p>I guess <em>some</em> types must have implemented the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait <em>and</em>
provided a proper <code class="language-plaintext highlighter-rouge">process_edge</code> implementation.  And…  I am right.  It is
<a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/plan/transitive_closure.rs#L51">ObjectsClosure</a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">ProcessEdgesWork</span><span class="o">&gt;</span> <span class="n">TransitiveClosure</span> <span class="k">for</span> <span class="n">ObjectsClosure</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.buffer</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.buffer</span><span class="nf">.reserve</span><span class="p">(</span><span class="nn">E</span><span class="p">::</span><span class="n">CAPACITY</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.buffer</span><span class="nf">.push</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
        <span class="c1">// ... more code omitted.</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">unreachable!()</code> again?  What the <a href="https://www.dictionary.com/browse/wtf">…</a>!</p>

<p>Clearly <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> and <code class="language-plaintext highlighter-rouge">ObjectsClosure</code> are implementing two different
interfaces.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> only implements <code class="language-plaintext highlighter-rouge">process_node</code>, while</li>
  <li><code class="language-plaintext highlighter-rouge">ObjectsClosure</code> only implements <code class="language-plaintext highlighter-rouge">process_edge</code>.</li>
</ul>

<h2 id="should-we-split-transitiveclosure">Should we split TransitiveClosure?</h2>

<p>Maybe we should split it into <em>two different traits</em>, one contains
<code class="language-plaintext highlighter-rouge">process_node</code> and the other contains <code class="language-plaintext highlighter-rouge">process_edge</code>.  In this way, a type may
only implement the trait it needs, and not the <code class="language-plaintext highlighter-rouge">unreachable!()</code> stub.</p>

<p>Or, should we?</p>

<p>To confirm this, let’s find their call sites, and see whether we ever use both
methods at the same time.  The short answer is, no.</p>

<h3 id="the-process_node-method">The process_node method</h3>

<p><code class="language-plaintext highlighter-rouge">process_node</code> is only called by <code class="language-plaintext highlighter-rouge">XxxSpace::trace_object</code>, where <code class="language-plaintext highlighter-rouge">XxxSpace</code> is a
concrete space.  It can be <a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/policy/copyspace.rs#L156">CopySpace</a>, <a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/policy/mallocspace/global.rs#L244">MallocSpace</a>,
<a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/policy/largeobjectspace.rs#L170">LargeObjectSpace</a> and so on.</p>

<p><small><em><code class="language-plaintext highlighter-rouge">ImmixSpace</code> even has <a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/policy/immix/immixspace.rs#L317">two</a> <a href="https://github.com/mmtk/mmtk-core/blob/093da769a71067dcd4f37db6f453213e7dace660/src/policy/immix/immixspace.rs#L340">flavours</a> of
<code class="language-plaintext highlighter-rouge">trace_object</code>, both call <code class="language-plaintext highlighter-rouge">process_node</code>.</em></small></p>

<p>The <code class="language-plaintext highlighter-rouge">trace_object</code> method of a space visits an object during tracing.  It marks
or copies the object and, if it is the first time it visits an object, it
<em>enqueues</em> the object into the marking queue by calling the <code class="language-plaintext highlighter-rouge">process_node</code>
method which does the actual enqueuing.</p>

<h3 id="the-process_edge-method">The process_edge method</h3>

<p><code class="language-plaintext highlighter-rouge">process_edge</code> is only called by <code class="language-plaintext highlighter-rouge">VM::Scanning::scan_object</code>.</p>

<p><code class="language-plaintext highlighter-rouge">scan_object</code> is implemented by a VM binding (such as <a href="https://github.com/mmtk/mmtk-openjdk/blob/86c6f534ae57d03fa45e7a73b698f851c84ab943/mmtk/src/scanning.rs#L42">the OpenJDK
binding</a>) because it is VM-specific.  MMTk calls <code class="language-plaintext highlighter-rouge">scan_object</code>
when it needs the VM to locate all reference fields in an object.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Scanning</span><span class="o">&lt;</span><span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">scan_object</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">TransitiveClosure</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">trace</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
        <span class="n">tls</span><span class="p">:</span> <span class="n">VMWorkerThread</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="c1">// ... more code omitted</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">trait</code> parameter is a call-back.  When <code class="language-plaintext highlighter-rouge">scan_object(trace, object, tls)</code> is
called, it scans <code class="language-plaintext highlighter-rouge">object</code>, and calls <code class="language-plaintext highlighter-rouge">trace.process_edge</code> on each edge, i.e.
each reference field, of <code class="language-plaintext highlighter-rouge">object</code>.</p>

<h3 id="yes--they-are-different">Yes!  They are different!</h3>

<p>We confirmed that each of the two methods is used in a different scenario.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">process_node</code> is only used by <code class="language-plaintext highlighter-rouge">trace_object</code>, and</li>
  <li><code class="language-plaintext highlighter-rouge">process_edge</code> is only used by <code class="language-plaintext highlighter-rouge">scan_object</code>.</li>
</ul>

<p>And nothing calls both <code class="language-plaintext highlighter-rouge">process_node</code> and <code class="language-plaintext highlighter-rouge">process_edge</code> at the same time.</p>

<p>So let’s split them into two traits.</p>

<p>But my colleague <a href="https://qinsoon.com/">Yi Lin</a> reminded me that there were other classes that extends
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code> in the original MMTk in JikesRVM.  To be safe, I looked into
the original JikesRVM MMTk before making further decisions.</p>

<h2 id="back-in-jikesrvm">Back in JikesRVM</h2>

<p>Now we temporarily move away from Rust MMTk, and go back to JikesRVM MMTk.  If
the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait is designed like this in Rust, it must have its
roots back in JikesRVM.</p>

<h3 id="transitiveclosure-in-jikesrvm-mmtk">TransitiveClosure in JikesRVM MMTk</h3>

<p>In <a href="https://www.jikesrvm.org/">JikesRVM</a>, there is a class named <a href="https://github.com/JikesRVM/JikesRVM/blob/0b6002e7d746a829d56c90acfc4bb5c560faf634/MMTk/src/org/mmtk/plan/TransitiveClosure.java#L29">TransitiveClosure</a>.  Yes.
It is a <em>class</em>, not an interface.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Uninterruptible</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
  <span class="c1">// Other methods omitted...</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">source</span><span class="o">,</span> <span class="nc">Address</span> <span class="n">slot</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">VM</span><span class="o">.</span><span class="na">assertions</span><span class="o">.</span><span class="na">fail</span><span class="o">(</span><span class="s">"processEdge not implemented."</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">VM</span><span class="o">.</span><span class="na">assertions</span><span class="o">.</span><span class="na">fail</span><span class="o">(</span><span class="s">"processNode not implemented."</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Defining <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> as a class allows it to provide failing default
implementations of <code class="language-plaintext highlighter-rouge">processEdge</code> and <code class="language-plaintext highlighter-rouge">processNode</code>.  This allows its subclasses
to override one method while leaving the other failing.</p>

<p><small><em>(Note that the JikesRVM code was written before Java 8, so interface
methods could not have default implementations.)</em></small></p>

<h3 id="transitiveclosure-subclasses-in-jikesrvm-mmtk">TransitiveClosure subclasses in JikesRVM MMTk</h3>

<p>In JikesRVM, many classes inherit from <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>.</p>

<ul>
  <li>TransitiveClosure
    <ul>
      <li>TraceLocal
        <ul>
          <li>NoGCTraceLocal</li>
          <li>MSTraceLocal</li>
          <li>SSTraceLocal</li>
          <li>MCMarkTraceLocal</li>
          <li>MCForwardTraceLocal</li>
          <li>ImmixTraceLocal</li>
          <li>ImmixDefragTraceLocal</li>
          <li>…</li>
        </ul>
      </li>
      <li>RCZero</li>
      <li>RCModifiedProcessor</li>
      <li>GenRCModifiedProcessor</li>
      <li>ObjectReferenceBuffer
        <ul>
          <li>RCDecBuffer</li>
        </ul>
      </li>
      <li>TraceWriteBuffer</li>
    </ul>
  </li>
</ul>

<h3 id="tracelocal">TraceLocal</h3>

<p>Back in JikesRVM MMTk, there was no concept of “work packet”.  The abstraction
of tracing is the <code class="language-plaintext highlighter-rouge">Trace</code> class and its thread-local counterpart, <code class="language-plaintext highlighter-rouge">TraceLocal</code>.
<code class="language-plaintext highlighter-rouge">ThreadLocal</code> was the local context of a GC thread during tracing GC.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceLocal</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="nd">@Inline</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">values</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">object</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="nd">@Inline</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">source</span><span class="o">,</span> <span class="nc">Address</span> <span class="n">slot</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ObjectReference</span> <span class="n">object</span> <span class="o">=</span> <span class="no">VM</span><span class="o">.</span><span class="na">activePlan</span><span class="o">.</span><span class="na">global</span><span class="o">().</span><span class="na">loadObjectReference</span><span class="o">(</span><span class="n">slot</span><span class="o">);</span>
        <span class="nc">ObjectReference</span> <span class="n">newObject</span> <span class="o">=</span> <span class="n">traceObject</span><span class="o">(</span><span class="n">object</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">overwriteReferenceDuringTrace</span><span class="o">())</span> <span class="o">{</span>
            <span class="no">VM</span><span class="o">.</span><span class="na">activePlan</span><span class="o">.</span><span class="na">global</span><span class="o">().</span><span class="na">storeObjectReference</span><span class="o">(</span><span class="n">slot</span><span class="o">,</span> <span class="n">newObject</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// ... more code omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In JikesRVM, <code class="language-plaintext highlighter-rouge">TraceLocal</code> is the counterpart of both <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> and
<code class="language-plaintext highlighter-rouge">ObjectsClosure</code> of the current Rust MMTk.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Space.traceObject</code> calls <code class="language-plaintext highlighter-rouge">TraceLocal.processNode</code> to enqueues newly visited
objects,
    <ul>
      <li>just like <code class="language-plaintext highlighter-rouge">XxxSpace::trace_object</code> calling
<code class="language-plaintext highlighter-rouge">ProcessEdgesWork.process_node</code> in Rust MMTk.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> calls <code class="language-plaintext highlighter-rouge">TraceLocal.processEdge</code> to process each
reference field (edge),
    <ul>
      <li>just like <code class="language-plaintext highlighter-rouge">Scanning::scan_object</code> calling <code class="language-plaintext highlighter-rouge">ObjectsClosure.process_edge</code>
in Rust MMTk.</li>
    </ul>
  </li>
</ul>

<p>In JikesRVM MMTk, each plan (GC algorithm) defines its own <code class="language-plaintext highlighter-rouge">TraceLocal</code>
subclass.</p>

<p><small><em>(Some GC algorithms. such as MarkCompact and Immix, even have more than
one <code class="language-plaintext highlighter-rouge">TraceLocal</code> for different kinds of traces.)</em></small></p>

<p>It looks like the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> is a proper interface for <code class="language-plaintext highlighter-rouge">TraceLocal</code>.
It implements both <code class="language-plaintext highlighter-rouge">processNode</code> and <code class="language-plaintext highlighter-rouge">processEdge</code>.</p>

<p>However, <code class="language-plaintext highlighter-rouge">TraceLocal</code> is the only class that implements both <code class="language-plaintext highlighter-rouge">processNode</code> and
<code class="language-plaintext highlighter-rouge">processEdge</code>.  Other classes don’t.</p>

<h3 id="processedge-field-visitors">processEdge: Field visitors</h3>

<p>Some subclasses of <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> are related to reference counting (RC).
They are <code class="language-plaintext highlighter-rouge">RCZero</code>, <code class="language-plaintext highlighter-rouge">RCModifiedProcessor</code>, etc.  They only override the
<code class="language-plaintext highlighter-rouge">processEdge</code> method, assuming <code class="language-plaintext highlighter-rouge">processNode</code> is never called.</p>

<p>What do they do?</p>

<p>They are <strong>field visitors</strong>.  For example, <code class="language-plaintext highlighter-rouge">RCZero</code> visits edges and stores
<code class="language-plaintext highlighter-rouge">null</code> to each field.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">RCZero</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="c1">// Does not override processNode, leaving it failing</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">source</span><span class="o">,</span> <span class="nc">Address</span> <span class="n">slot</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slot</span><span class="o">.</span><span class="na">store</span><span class="o">(</span><span class="nc">ObjectReference</span><span class="o">.</span><span class="na">nullReference</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>During RC collection, <code class="language-plaintext highlighter-rouge">RCZero</code> is passed to <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> as the
callback to set all reference fields of an object to <code class="language-plaintext highlighter-rouge">null</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RCBaseCollector</span> <span class="kd">extends</span> <span class="nc">StopTheWorldCollector</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RCZero</span> <span class="n">zero</span><span class="o">;</span>  <span class="c1">// This implements TransitiveClosure</span>
    <span class="c1">// ... more code omitted</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">collectionPhase</span><span class="o">(</span><span class="kt">short</span> <span class="n">phaseId</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">primary</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ... more code omitted</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">phaseId</span> <span class="o">==</span> <span class="nc">RCBase</span><span class="o">.</span><span class="na">PROCESS_DECBUFFER</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// ... more code omitted</span>
            <span class="k">while</span> <span class="o">(!(</span><span class="n">current</span> <span class="o">=</span> <span class="n">decBuffer</span><span class="o">.</span><span class="na">pop</span><span class="o">()).</span><span class="na">isNull</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// ... more code omitted</span>
                <span class="no">VM</span><span class="o">.</span><span class="na">scanning</span><span class="o">.</span><span class="na">scanObject</span><span class="o">(</span><span class="n">zero</span><span class="o">,</span> <span class="n">current</span><span class="o">);</span>  <span class="c1">// Passing zero as callback</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Other RC-related classes are similar.  They record the fields or apply
decrements to the objects pointed by each field.</p>

<h3 id="processnode-to-enqueue-objects">processNode: to enqueue objects</h3>

<p>The <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> class only implements <code class="language-plaintext highlighter-rouge">processNode</code>.</p>

<p><small><em>(In fact, <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> is the only class that overrides
<code class="language-plaintext highlighter-rouge">processNode</code> but note <code class="language-plaintext highlighter-rouge">processEdge</code> throughout the history of
JikesRVM.)</em></small></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TraceWriteBuffer</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">WriteBuffer</span> <span class="n">buffer</span><span class="o">;</span>
    <span class="c1">// ... more code omitted</span>
    <span class="nd">@Inline</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">object</span><span class="o">.</span><span class="na">toAddress</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> is only used by <code class="language-plaintext highlighter-rouge">CMSMutator</code> (concurrent mark-sweep mutator).</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CMSMutator</span> <span class="kd">extends</span> <span class="nc">ConcurrentMutator</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">TraceWriteBuffer</span> <span class="n">remset</span><span class="o">;</span>
    <span class="c1">// ... more code omitted</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">checkAndEnqueueReference</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">ref</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ref</span><span class="o">.</span><span class="na">isNull</span><span class="o">())</span> <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">barrierActive</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">ref</span><span class="o">.</span><span class="na">isNull</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span>      <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">MARK_SWEEP</span><span class="o">,</span> <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">msSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>            <span class="c1">// here</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">IMMORTAL</span><span class="o">,</span>   <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">immortalSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>      <span class="c1">// here</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">LOS</span><span class="o">,</span>        <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">loSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>            <span class="c1">// here</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">NON_MOVING</span><span class="o">,</span> <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">nonMovingSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>     <span class="c1">// here</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">SMALL_CODE</span><span class="o">,</span> <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">smallCodeSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>     <span class="c1">// here</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Space</span><span class="o">.</span><span class="na">isInSpace</span><span class="o">(</span><span class="no">CMS</span><span class="o">.</span><span class="na">LARGE_CODE</span><span class="o">,</span> <span class="n">ref</span><span class="o">))</span> <span class="no">CMS</span><span class="o">.</span><span class="na">largeCodeSpace</span><span class="o">.</span><span class="na">traceObject</span><span class="o">(</span><span class="n">remset</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>     <span class="c1">// here</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// ... more code omitted</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In simple terms, the code above means “Trace the object <code class="language-plaintext highlighter-rouge">ref</code> in the space it is
in, and, if it is the first time the object is traced, enqueue it in <code class="language-plaintext highlighter-rouge">remset</code>.”</p>

<p>What’s in common between <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> and <code class="language-plaintext highlighter-rouge">TraceLocal</code> is that both of
them contain a buffer (a remember set, or the tracing queue) where the
<code class="language-plaintext highlighter-rouge">traceObject</code> method can enqueue newly visited objects to.  This is what
<code class="language-plaintext highlighter-rouge">processNode</code> is for, i.e. <em>enqueuing objects</em>.</p>

<h3 id="so-why-not-introducing-a-dedicated-interface">So why not introducing a dedicated interface?</h3>

<p>There comes an interesting question:</p>

<blockquote>
  <p><em>If some classes are just field visitors, why don’t we have a dedicated
  interface for it, and name it <code class="language-plaintext highlighter-rouge">FieldVisitor</code>?</em></p>
</blockquote>

<p>and</p>

<blockquote>
  <p><em>If some classes are just places to enqueue objects, why don’t we have a
  dedicated interface for it, and name it <code class="language-plaintext highlighter-rouge">ObjectBuffer</code>?</em></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">TransitiveClosure</code> has been there for 15 years.  Many developers have made
contributions to MMTk, and some of them must have noticed the issues I talked
about.  Why have <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> remained this way till today?</p>

<p>And why did we end up having this <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> amalgamation in the first
place?</p>

<h2 id="through-the-history">Through the history</h2>

<p>To answer these questions, I dug into the Git revision history of the JikesRVM
repository.</p>

<p>The <code class="language-plaintext highlighter-rouge">git blame</code> command can show me in which commit any line in any source file
is last modified.  I use <a href="https://github.com/tpope/vim-fugitive">vim-fugitive</a>, and it even allows me to follow a line
of code from one commit to another, and see every single change to a line of
code in history.</p>

<h3 id="early-days-of-object-scanning">Early days of object scanning</h3>

<p>The history of <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> is the history of object scanning interface
and implementation.</p>

<p><a href="https://github.com/JikesRVM/JikesRVM/tree/68e36aac633743a7930516eb4c7536240152dc1e">Back in 2003</a>, MMTk (was JMTk back then) and JikesRVM were
more tightly coupled than they are today.  Unlike the modern <code class="language-plaintext highlighter-rouge">Scanning</code>
interface, the <code class="language-plaintext highlighter-rouge">ScanObject</code> class back then contained concrete implementations
directly. The <a href="https://github.com/JikesRVM/JikesRVM/blob/68e36aac633743a7930516eb4c7536240152dc1e/rvm/src/vm/memoryManagers/JMTk/vmInterface/ScanObject.java#L42"><code class="language-plaintext highlighter-rouge">ScanObject.scan</code></a> method enumerates
reference fields, and directly calls the <code class="language-plaintext highlighter-rouge">Plan.traceObjectLocation</code> static
method, which does the load/traceObject/store sequence like our modern
<code class="language-plaintext highlighter-rouge">ProcessEdgesWork::process_edge</code> method.  Everything was hard-wired.  The
operation for visiting field was fixed.</p>

<p><a href="https://github.com/JikesRVM/JikesRVM/commit/e7bc7a0b35b96d3182a8cb53f9548c38c90de579">A commit in 2003</a> introduced the
<a href="https://github.com/JikesRVM/JikesRVM/blob/e7bc7a0b35b96d3182a8cb53f9548c38c90de579/rvm/src/vm/memoryManagers/JMTk/vmInterface/ScanObject.java#L64"><code class="language-plaintext highlighter-rouge">ScanObject.enumeratePointers</code></a> method which calls back to
<code class="language-plaintext highlighter-rouge">Plan.enumeratePointerLocation</code> which can be customised.  This allows a certain
degree of freedom of what to do with each field, instead of
load/traceObject/store.</p>

<p><a href="https://github.com/JikesRVM/JikesRVM/commit/e7195af9696795f20acb4eb841bc9beec8e7d412">Another commit in 2003</a> introduced the <code class="language-plaintext highlighter-rouge">Enumerate</code> class
which was subsequently renamed to <code class="language-plaintext highlighter-rouge">Enumerator</code> and <a href="https://github.com/JikesRVM/JikesRVM/commit/c2ff58e6a8499ad987ecb1c30a0f206f1036ef1c">made fully
abstract</a>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Enumerator</span> <span class="kd">implements</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">abstract</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enumeratePointerLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">location</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ScanObject.enumeratePointers</code> method then used <code class="language-plaintext highlighter-rouge">Enumerator</code> as the call
back instead calling into <code class="language-plaintext highlighter-rouge">Plan</code> directly, allowing the behavior of visiting
each edge to be fully customised.</p>

<p>As I conjectured, <em>some developers did notice that the call-back for
<code class="language-plaintext highlighter-rouge">scanObjects</code> should be customisable</em>, and <code class="language-plaintext highlighter-rouge">Enumerator</code> was introduced just for
that.</p>

<h3 id="in-2006-just-before-that-important-change">In 2006, just before that important change</h3>

<p>Both the <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> and <code class="language-plaintext highlighter-rouge">Scanning.enumeratePointers</code> existed in <a href="https://github.com/JikesRVM/JikesRVM/blob/600956237939e61b314535d485dfdfcbab2c0bbe/MMTk/src/org/mmtk/vm/Scanning.java">the
Scanning class</a> before late 2006.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Scanning</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">scanObject</span><span class="o">(</span><span class="nc">TraceLocal</span> <span class="n">trace</span><span class="o">,</span> <span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">enumeratePointers</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">,</span> <span class="nc">Enumerator</span> <span class="n">e</span><span class="o">);</span>
    <span class="c1">// ... more code omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Both <code class="language-plaintext highlighter-rouge">scanObject</code> and <code class="language-plaintext highlighter-rouge">enumeratePointers</code> enumerate reference fields in an
object.  However, they are used in totally different places.</p>

<h4 id="scanningscanobject">Scanning.scanObject</h4>

<p>The <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> method was used for tracing, as it took <code class="language-plaintext highlighter-rouge">TraceLocal</code>
as parameter, and called <code class="language-plaintext highlighter-rouge">TraceLocal.traceObjectLocation</code> for each reference
filed.</p>

<p>Note that at that time, <a href="https://github.com/JikesRVM/JikesRVM/blob/600956237939e61b314535d485dfdfcbab2c0bbe/MMTk/src/org/mmtk/plan/TraceLocal.java#L42">TraceLocal was a root
class</a>. There was no superclasses or interfaces
like <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> for it to extend/implement. (<code class="language-plaintext highlighter-rouge">Constants</code> is an
all-static interface, and <code class="language-plaintext highlighter-rouge">Uninterruptible</code> is just a marker.)  This means
<code class="language-plaintext highlighter-rouge">scanObject</code> was only applicable to subclasses of <code class="language-plaintext highlighter-rouge">TraceLocal</code>, and nothing
else.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceLocal</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span> <span class="c1">// no superclass</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span> <span class="c1">// traceObject calls this</span>
        <span class="n">values</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">object</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">root</span><span class="o">)</span> <span class="c1">// scanObject calls this</span>
            <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="nc">ObjectReference</span> <span class="n">object</span> <span class="o">=</span> <span class="n">objLoc</span><span class="o">.</span><span class="na">loadObjectReference</span><span class="o">();</span>
        <span class="nc">ObjectReference</span> <span class="n">newObject</span> <span class="o">=</span> <span class="n">traceObject</span><span class="o">(</span><span class="n">object</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
        <span class="n">objLoc</span><span class="o">.</span><span class="na">store</span><span class="o">(</span><span class="n">newObject</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// ... more code omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="scanningenumeratepointers">Scanning.enumeratePointers</h4>

<p>On the other hand, the <code class="language-plaintext highlighter-rouge">Scanning.enumeratePointers</code> could in theory be used by
any code that needs to enumerate reference fields.  At that time, it was used
for (deferred) reference counting.  The following was the “mark grey” operation
in trial-deletion for cycle collection in reference counting.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TrialDeletion</span> <span class="kd">extends</span> <span class="nc">CycleDetector</span>
        <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">TDGreyEnumerator</span> <span class="n">greyEnum</span><span class="o">;</span>  <span class="c1">// extends Enumerator</span>
    <span class="c1">// ... more code omitted</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">markGrey</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">,</span> <span class="kt">long</span> <span class="n">timeCap</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="c1">// ... more code omitted</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">object</span><span class="o">.</span><span class="na">isNull</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// ... more code omitted</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">abort</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nc">RefCountSpace</span><span class="o">.</span><span class="na">isGrey</span><span class="o">(</span><span class="n">object</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">RefCountSpace</span><span class="o">.</span><span class="na">makeGrey</span><span class="o">(</span><span class="n">object</span><span class="o">);</span>
                <span class="nc">Scan</span><span class="o">.</span><span class="na">enumeratePointers</span><span class="o">(</span><span class="n">object</span><span class="o">,</span> <span class="n">greyEnum</span><span class="o">);</span>  <span class="c1">// pay attention to this call site</span>
            <span class="o">}</span>
            <span class="n">object</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">abort</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// ... more code omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The call site of <code class="language-plaintext highlighter-rouge">Scan.enumeratePointers</code> passed a <code class="language-plaintext highlighter-rouge">TDGreyEnumerator</code> instance
which customised the behaviour of visiting fields.  It just forward the call to
<code class="language-plaintext highlighter-rouge">TrialDeletion.enumerateGrey</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TDGreyEnumerator</span> <span class="kd">extends</span> <span class="nc">Enumerator</span> <span class="kd">implements</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">TrialDeletion</span> <span class="n">td</span><span class="o">;</span>
    <span class="c1">// ... more code omitted</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enumeratePointerLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="n">td</span><span class="o">.</span><span class="na">enumerateGrey</span><span class="o">(</span><span class="n">objLoc</span><span class="o">.</span><span class="na">loadObjectReference</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="the-obvious-problem">The obvious problem</h4>

<p>We then had <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> for tracing, and <code class="language-plaintext highlighter-rouge">Scanning.enumeratePointers</code>
for RC.</p>

<p>But <em>why did we need both methods</em>?  <code class="language-plaintext highlighter-rouge">scanObject</code> was basically a special case
of <code class="language-plaintext highlighter-rouge">enumeratePointers</code> that called <code class="language-plaintext highlighter-rouge">TraceObject.enumeratePointerLocation</code>.</p>

<p>Could we <strong>unify</strong> them? Apparently someone noticed that, and he did a
refactoring.</p>

<h3 id="unifying-scanobject-and-enumeratepointers-with-racestep">Unifying scanObject and enumeratePointers with “raceStep”</h3>

<p>In late 2006, <a href="https://github.com/JikesRVM/JikesRVM/commit/64f538ca4d348f062f3afb313f519ffcbbbd22bd">someone created a commit</a> which
introduced a new version of reference counting collector, and at the same time
did “a huge refactoring” (see the commit message).</p>

<p>This commit created a class named <code class="language-plaintext highlighter-rouge">TraceStep</code>.  <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> then took
<code class="language-plaintext highlighter-rouge">TraceStep</code> as parameter instead of <code class="language-plaintext highlighter-rouge">TraceLocal</code>.  The <code class="language-plaintext highlighter-rouge">enumeratePointers</code>
method was removed.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceStep</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Scanning</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">scanObject</span><span class="o">(</span><span class="nc">TraceStep</span> <span class="n">trace</span><span class="o">,</span> <span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Obviously, <code class="language-plaintext highlighter-rouge">TraceStep</code> was intended to replaced <code class="language-plaintext highlighter-rouge">Enumerator</code> as the call-back
interface for <code class="language-plaintext highlighter-rouge">scanObject</code> to enumerating fields.  Both tracing and RC started
using <code class="language-plaintext highlighter-rouge">scanObject</code> from then on.</p>

<p>For tracing, the <code class="language-plaintext highlighter-rouge">TraceLocal</code> started to extend <code class="language-plaintext highlighter-rouge">TraceStep</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceLocal</span> <span class="kd">extends</span> <span class="nc">TraceStep</span>   <span class="c1">// Now extends TraceStep</span>
        <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">)</span> <span class="c1">// called by scanObject</span>
            <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="n">traceObjectLocation</span><span class="o">(</span><span class="n">objLoc</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">root</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="c1">// ... just like before</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>RC operations, such as “mark grey”, started extending <code class="language-plaintext highlighter-rouge">TraceStep</code> instead of
<code class="language-plaintext highlighter-rouge">Enumerator</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TrialDeletionGreyStep</span> <span class="kd">extends</span> <span class="nc">TraceStep</span>  <span class="c1">// Now extends TraceStep instead of Enumerator</span>
        <span class="kd">implements</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ObjectReference</span> <span class="n">object</span> <span class="o">=</span> <span class="n">objLoc</span><span class="o">.</span><span class="na">loadObjectReference</span><span class="o">();</span>
        <span class="o">((</span><span class="nc">TrialDeletionCollector</span><span class="o">)</span><span class="nc">CDCollector</span><span class="o">.</span><span class="na">current</span><span class="o">()).</span><span class="na">enumerateGrey</span><span class="o">(</span><span class="n">object</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TrialDeletionCollector</span> <span class="kd">extends</span> <span class="nc">CDCollector</span>
        <span class="kd">implements</span> <span class="nc">Uninterruptible</span><span class="o">,</span> <span class="nc">Constants</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TrialDeletionGreyStep</span> <span class="n">greyStep</span><span class="o">;</span>  <span class="c1">// A TraceStep instead of Enumerator</span>
    <span class="c1">// ... more code omitted</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">markGrey</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InlinePragma</span> <span class="o">{</span>
        <span class="c1">// ... more code omitted</span>
        <span class="nc">Scan</span><span class="o">.</span><span class="na">scanObject</span><span class="o">(</span><span class="n">greyStep</span><span class="o">,</span> <span class="n">object</span><span class="o">);</span>  <span class="c1">// now passes a TraceStep as arg</span>
        <span class="c1">// ... more code omitted</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This commit successfully unified the object scanning interface.
<code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> became the only object-scanning method. It became
applicable to all <code class="language-plaintext highlighter-rouge">TraceStep</code> instances alike, and was no longer coupled with
<code class="language-plaintext highlighter-rouge">TraceLocal</code>. Good! Nicely done!</p>

<p>More over, this commit cleverly found a concept that describes both
<code class="language-plaintext highlighter-rouge">TraceLocal</code> and the various operations in reference counting, such as “mark
grey”, “scan black”, etc.  It was <strong>“TraceStep”</strong>.  Intuitively, all of them
were steps of tracing.</p>

<p>But really?  We will soon find that it is not really that clever.</p>

<h3 id="here-comes-transitiveclosure">Here comes TransitiveClosure</h3>

<p>In 2007, someone made <a href="https://github.com/JikesRVM/JikesRVM/commit/f85c61257bbeda1efeed3a2f6a4ba5903cbe74e0">another commit</a> to “reorganise the core of
transitive closure”, and the motivations were “concurrent collection” and
“implementing prefetching during trace”.</p>

<p>In this commit, <code class="language-plaintext highlighter-rouge">TraceStep</code> was renamed to our familiar <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>.</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">TraceStep.traceObjectLocation</code> method was renamed to
<code class="language-plaintext highlighter-rouge">TransitiveClosure.processEdge</code>, and</li>
  <li>a new method <code class="language-plaintext highlighter-rouge">processNode</code> was added.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Uninterruptible</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
  <span class="cm">/**
   * Trace an edge during GC.
   *
   * @param objLoc The location containing the object reference.
   */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">VM</span><span class="o">.</span><span class="na">assertions</span><span class="o">.</span><span class="na">fail</span><span class="o">(</span><span class="s">"processEdge not implemented."</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="cm">/**
   * Trace a node during GC.
   *
   * @param object The object to be processed.
   */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">VM</span><span class="o">.</span><span class="na">assertions</span><span class="o">.</span><span class="na">fail</span><span class="o">(</span><span class="s">"processNode not implemented."</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that I didn’t add any <code class="language-plaintext highlighter-rouge">// ... more code omitted</code> comment because back in
2007, that was <a href="https://github.com/JikesRVM/JikesRVM/blob/f85c61257bbeda1efeed3a2f6a4ba5903cbe74e0/MMTk/src/org/mmtk/plan/TransitiveClosure.java#L29">the entire class body of <code class="language-plaintext highlighter-rouge">TransitiveClosure</code></a>.</p>

<p><code class="language-plaintext highlighter-rouge">TraceLocal</code> now extends <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> instead of <code class="language-plaintext highlighter-rouge">TraceStep</code>, and</p>

<ul>
  <li>the <code class="language-plaintext highlighter-rouge">traceObjectLocation</code> method was renamed to <code class="language-plaintext highlighter-rouge">processEdge</code>, and</li>
  <li>the <code class="language-plaintext highlighter-rouge">enqueue</code> method was renamed to <code class="language-plaintext highlighter-rouge">processNode</code>.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceLocal</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ... like before</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">source</span><span class="o">,</span> <span class="nc">Address</span> <span class="n">slot</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ... like before</span>
    <span class="o">}</span>
    <span class="c1">// ... more code omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<p>A few days later, <a href="https://github.com/JikesRVM/JikesRVM/commit/2257a7565c9920beb8455a6df0f8f6f8dbb2bae4">a subsequent commit</a> introduced a
<code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> class that extended <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> and overrode
<code class="language-plaintext highlighter-rouge">processNode</code> alone, and not <code class="language-plaintext highlighter-rouge">processEdge</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TraceWriteBuffer</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="c1">// ... more code omitted</span>
    <span class="nd">@Inline</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// .. as you have seen in previous sections.</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It remains the only class that overrides <code class="language-plaintext highlighter-rouge">processNode</code> but note <code class="language-plaintext highlighter-rouge">processEdge</code>
in the history of JikesRVM, even today.</p>

<p>With this change, <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> started to serve two distinct purposes.</p>

<ol>
  <li>the callback for <code class="language-plaintext highlighter-rouge">scanObject</code>, and</li>
  <li>the place to enqueue an object after tracing it.</li>
</ol>

<p>If a class was only used in one of the two cases, it would override only one of
the two methods.</p>

<h3 id="10-years-passed">10 years passed…</h3>

<p><code class="language-plaintext highlighter-rouge">TransitiveClosure</code> remained this way in JikesRVM MMTk since then.</p>

<p>And the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> class grew a little bit.  <a href="https://github.com/JikesRVM/JikesRVM/blob/5072f19761115d987b6ee162f49a03522d36c697/MMTk/src/org/mmtk/plan/TransitiveClosure.java#L32">Some static fields and
methods about specialised scanning</a> were added to it, as if
it were a good place to hold information for specialised scanning.</p>

<h3 id="and-there-was-rust-mmtk">…and there was Rust MMTk.</h3>

<p>In 2017, we started porting MMTk to Rust.</p>

<h4 id="porting-mmtk-to-rust">Porting MMTk to Rust</h4>

<p>The <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> was copied to the Rust version, except this time it
was represented as a Rust trait.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TransitiveClosure</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And <code class="language-plaintext highlighter-rouge">TraceLocal</code> was a trait that requires <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TraceLocal</span><span class="p">:</span> <span class="n">TransitiveClosure</span> <span class="p">{</span>
    <span class="c1">// ... other methods</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Scanning.scan_object</code> method took <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> as parameter, just
like JikesRVM MMTk.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Scanning</span><span class="o">&lt;</span><span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">scan_object</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">TransitiveClosure</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">trace</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
        <span class="n">tls</span><span class="p">:</span> <span class="n">OpaquePointer</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="c1">// ... more code omitted</span>
<span class="p">}</span>

</code></pre></div></div>

<p>And the <code class="language-plaintext highlighter-rouge">XxxSpace::trace_object</code> methods still took <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> as
parameter, like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="n">CopySpace</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">trace_object</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">TransitiveClosure</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">trace</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
        <span class="n">allocator</span><span class="p">:</span> <span class="n">Allocator</span><span class="p">,</span>
        <span class="n">tls</span><span class="p">:</span> <span class="n">OpaquePointer</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ObjectReference</span> <span class="p">{</span>

    <span class="c1">// ... more code omitted</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And <a href="https://github.com/mmtk/mmtk-core/blob/96855d287fe5ea789a532f347d6ee37e6679c71f/src/plan/tracelocal.rs">there was still TraceLocal</a>. (Not any more now.)</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TraceLocal</span><span class="p">:</span> <span class="n">TransitiveClosure</span> <span class="p">{</span>
    <span class="c1">// ... omitted.  There are many methods, but none is interesting here.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Like in JikesRVM MMTk,</p>

<ul>
  <li>the <code class="language-plaintext highlighter-rouge">scan_object</code> method still called <code class="language-plaintext highlighter-rouge">trace.process_edge</code> for each visited
edge, and</li>
  <li>the <code class="language-plaintext highlighter-rouge">trace_object</code> method still called <code class="language-plaintext highlighter-rouge">trace.process_node</code> to enqueue the
object on first visit.</li>
</ul>

<p>Initially, <em>we did not address the fact that TransitiveClosure served two
different purposes.</em> By that time, we had just begun porting MMTk to Rust.  <strong>We
prioritised making Rust MMTk working</strong>, and ported from JikesRVM MMTk in a style
closely resembled the original Java code.</p>

<p>And MMTk worked.  Not just worked, but worked for OpenJDK, JikesRVM and several
other VMs, too.</p>

<h4 id="introducing-work-packets">Introducing work packets</h4>

<p>We later removed <code class="language-plaintext highlighter-rouge">TraceLocal</code> and introduced the work packet system.</p>

<p>The work packet system represents each unit of work as a “packet” that can be
scheduled on any GC worker thread.  The <code class="language-plaintext highlighter-rouge">TraceLocal</code> class was replaced by two
work packets:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> work packet represents a list of edges to be traced.</li>
  <li>The <code class="language-plaintext highlighter-rouge">ScanObjects</code> work packet represents a list of objects to be scanned.</li>
</ul>

<p>A <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> work packet also carries an object queue inside it.  It
needs the <code class="language-plaintext highlighter-rouge">process_node</code> method so that <code class="language-plaintext highlighter-rouge">XxxSpace.trace_object</code> can call it and
queue newly visited objects.</p>

<p>Therefore, <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> implements TransitiveClosure because
<code class="language-plaintext highlighter-rouge">trace_object</code> expects it. And… remember?  That implementation startled me…</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">ProcessEdgesWork</span><span class="o">&gt;</span> <span class="n">TransitiveClosure</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">ProcessEdgesWork</span><span class="p">::</span><span class="nf">process_node</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then what visits edges when scanning an object?  It is now the <code class="language-plaintext highlighter-rouge">ObjectsClosure</code>
object.  It needs to provide <code class="language-plaintext highlighter-rouge">process_edge</code>, but <code class="language-plaintext highlighter-rouge">Scanning::scan_object</code> expects
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code>.</p>

<p>So we have to do what the <a href="https://www.dictionary.com/browse/wtf">…</a> we need to satisfy that requirement, as we
have seen before:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">ProcessEdgesWork</span><span class="o">&gt;</span> <span class="n">TransitiveClosure</span> <span class="k">for</span> <span class="n">ObjectsClosure</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.buffer</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.buffer</span><span class="nf">.reserve</span><span class="p">(</span><span class="nn">E</span><span class="p">::</span><span class="n">CAPACITY</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.buffer</span><span class="nf">.push</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
        <span class="c1">// ... more code omitted.</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>As you can see, <strong>even after we migrated to the work packet system, and even
though we no longer have any type that overrides both <code class="language-plaintext highlighter-rouge">process_edge</code> and
<code class="language-plaintext highlighter-rouge">process_node</code>, we still kept both <code class="language-plaintext highlighter-rouge">process_edge</code> and <code class="language-plaintext highlighter-rouge">process_node</code> in the
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait</strong>.</p>

<h2 id="why-do-we-end-up-having-transitiveclosure-like-this">Why do we end up having TransitiveClosure like this?</h2>

<p>We have been startled by smelly code.  We have <a href="https://www.dictionary.com/browse/wtf">expressed our anger, impatience,
surprise, etc., without explicit vulgarity</a>.  We have looked into JikesRVM
for the old MMTk.  We have gone through the history to see the change of the
object scanning interface, and read the commits from developers with the
intention of improving MMTk.</p>

<p>But why do we end up having a <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait like this?</p>

<h3 id="have-we-noticed-that-object-scanning-is-not-necessarily-part-of-tracing">Have we noticed that object scanning is not necessarily part of tracing?</h3>

<p>Yes.  The <a href="https://github.com/JikesRVM/JikesRVM/commit/c2ff58e6a8499ad987ecb1c30a0f206f1036ef1c"><code class="language-plaintext highlighter-rouge">Enumerator</code></a> interface was introduced just for
that.  When called back from <code class="language-plaintext highlighter-rouge">scan_object</code>, it allows us to do anything to
reference fields.</p>

<h3 id="have-we-refactored-scan_object-so-it-takes-a-simple-callback-instead-of-tracelocal">Have we refactored scan_object so it takes a simple callback instead of TraceLocal?</h3>

<p>Yes.  When <a href="https://github.com/JikesRVM/JikesRVM/commit/64f538ca4d348f062f3afb313f519ffcbbbd22bd"><code class="language-plaintext highlighter-rouge">TraceStep</code></a> was introduced, We unified
<code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> and <code class="language-plaintext highlighter-rouge">Scanning.enumeratePointers</code>.  <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code>
was refactored to only depend on <code class="language-plaintext highlighter-rouge">TraceStep</code>, and <code class="language-plaintext highlighter-rouge">TraceStep</code> was an abstract
class with only an abstract method <code class="language-plaintext highlighter-rouge">traceObjectLocation(Address objLoc)</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceStep</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">traceObjectLocation</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Scanning</span> <span class="kd">implements</span> <span class="nc">Constants</span><span class="o">,</span> <span class="nc">Uninterruptible</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">scanObject</span><span class="o">(</span><span class="nc">TraceStep</span> <span class="n">trace</span><span class="o">,</span> <span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This should have been the ideal interface for <code class="language-plaintext highlighter-rouge">Scanning.scan_object</code> for MMTk in
Java.  (Rust could use closure to make it more concise.)</p>

<h3 id="but-why-did-we-migrate-away-from-it">But why did we migrate away from it?</h3>

<p>Probably only the author of <a href="https://github.com/JikesRVM/JikesRVM/commit/f85c61257bbeda1efeed3a2f6a4ba5903cbe74e0">this commit</a> knows the exact reason.</p>

<p>To my understanding, I think it was because <strong><code class="language-plaintext highlighter-rouge">TraceStep</code> was such a good, but
a wrong, name</strong>.</p>

<ol>
  <li>
    <p>We named it “TraceStep”.</p>
  </li>
  <li>
    <p>We made it the superclass of <code class="language-plaintext highlighter-rouge">TraceLocal</code>.</p>
  </li>
  <li>
    <p>We then <a href="https://github.com/JikesRVM/JikesRVM/commit/2257a7565c9920beb8455a6df0f8f6f8dbb2bae4">introduced TraceWriteBuffer</a>.</p>
  </li>
  <li>
    <p>We noticed <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> was another place to enqueue objects in
addition to <code class="language-plaintext highlighter-rouge">TraceLocal</code>.</p>
  </li>
  <li>
    <p>Then we naturally thought that both <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> and <code class="language-plaintext highlighter-rouge">TraceLocal</code>
should have a common superclass that had a method named <code class="language-plaintext highlighter-rouge">enqueue</code>.</p>

    <p>But <code class="language-plaintext highlighter-rouge">TraceStep</code> doesn’t have <code class="language-plaintext highlighter-rouge">enqueue</code>.</p>
  </li>
  <li>
    <p>Then we extended <code class="language-plaintext highlighter-rouge">TraceStep</code> into <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>, and added <code class="language-plaintext highlighter-rouge">enqueue</code>.</p>

    <p>And we even renamed <code class="language-plaintext highlighter-rouge">enqueue</code> to <code class="language-plaintext highlighter-rouge">processNode</code> to make it consistent with
<code class="language-plaintext highlighter-rouge">processEdge</code>.</p>
  </li>
  <li>
    <p>Then we have <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> which had <code class="language-plaintext highlighter-rouge">processEdge</code> and <code class="language-plaintext highlighter-rouge">processNode</code>.</p>
  </li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TraceLocal</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TraceWriteBuffer</span> <span class="kd">extends</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Wow!  “TransitiveClosure” was an even better name!  That was what <code class="language-plaintext highlighter-rouge">TraceLocal</code>
really was, i.e. computing the transitive closure of an object graph!  A
“transitive closure” is a graph!  A graph has nodes and edges!</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processEdge</span><span class="o">(</span><span class="nc">Address</span> <span class="n">objLoc</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processNode</span><span class="o">(</span><span class="nc">ObjectReference</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But <code class="language-plaintext highlighter-rouge">TraceWriteBuffer</code> doesn’t override <code class="language-plaintext highlighter-rouge">processEdge</code>, and <code class="language-plaintext highlighter-rouge">RCZero</code> doesn’t
override <code class="language-plaintext highlighter-rouge">processNode</code>!</p>

<p>No worries.  We leave them “unreachable”.</p>

<p>“Unreachable”?  That doesn’t sound right.</p>

<p>But it worked… for 15 years.</p>

<p>The name “TransitiveClosure”  made so much sense that we stuck to
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code> forever, even after we ported MMTk to Rust.</p>

<h3 id="but-tracestep-is-a-wrong-name">But TraceStep is a wrong name.</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">TraceLocal</code>, “mark grey”, “scan black”, <code class="language-plaintext highlighter-rouge">RCZero</code> and so on are all steps in
tracing,</li>
  <li>and those trace steps process edges,</li>
  <li>hence <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> should accept <code class="language-plaintext highlighter-rouge">TraceStep</code> as a call-back
argument, so <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> can give <code class="language-plaintext highlighter-rouge">TraceStep</code> edges to process.</li>
</ol>

<p>Wrong.</p>

<p><code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> accepts a callback argument not because the callback is a
step of tracing, but simply <strong>because the callback visits edges</strong>.</p>

<p>I don’t really know what counts as a “trace step”.</p>

<ul>
  <li>Does “assigning <code class="language-plaintext highlighter-rouge">null</code> to each reference field” count as a “trace step”?</li>
  <li>Does “applying decrement operations to the reference counts of all neighbor
objects” count as a “trace step” even if it is used in reference counting,
only?</li>
  <li>Is trial-deletion considered as a kind of tracing at all?</li>
</ul>

<p>No matter what it is, isn’t it much easier to just say</p>

<blockquote>
  <p><em>“<code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> accepts it as a callback argument because it visits
  edges.”</em></p>
</blockquote>

<h3 id="the-nature-of-interfaces">The nature of interfaces.</h3>

<p>This is the nature of interfaces.  A reuseable component should not make
assumptions about its neighbours more than necessary.  This is <strong>the
separation of concern</strong>.</p>

<p>It is just like when we do the following in rust:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.foreach</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Iterator::foreach</code> function accepts this closure not because it prints
things, but because it visits elements.  <code class="language-plaintext highlighter-rouge">foreach</code> is intended for visiting
elements.  The closure receives the object.  That is the contract of the
<code class="language-plaintext highlighter-rouge">foreach</code> method.  Whether it prints the element or how it prints the element is
not part of the contract.</p>

<p>So “Enumerator” was a right name.  It correctly describes the role of the object
in a <code class="language-plaintext highlighter-rouge">scanObject</code> invocation, that is, <em>“it enumerates fields”</em>, nothing more.
That’s all what <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> need to care about.  It passes each field
to the callback, and that’s it.  It should not assume what that callback object
does to each edge.  Whether it is a <code class="language-plaintext highlighter-rouge">TraceLocal</code> or an RC operation is beyond
its obligation.</p>

<p>“TraceStep” was wrong.  “TransitiveClosure” was also wrong.  Neither of them
is what <code class="language-plaintext highlighter-rouge">Scanning.scanObject</code> cares about.</p>

<h2 id="finding-the-way-out">Finding the way out</h2>

<p>We have seen the history, and know why it ended up like this.</p>

<p>We know what was wrong, and what would be right.</p>

<p>“Enumerator” was right.  “TraceStep” was wrong.  “TransitiveClosure” was wrong,
too, but it just sounded so good.</p>

<p>No matter how good it sounds, we need to fix it.</p>

<p>From our analysis in the beginning of this article, we should split
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code> into two traits,</p>

<ol>
  <li>one as the callback of <code class="language-plaintext highlighter-rouge">Scanning::scan_object</code>, and</li>
  <li>the other to be used by <code class="language-plaintext highlighter-rouge">XxxSpace::trace_object</code> to enqueue object.</li>
</ol>

<p>I have opened an <a href="https://github.com/mmtk/mmtk-core/issues/559">issue</a>, and detailed the steps of
splitting and removing <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> from <code class="language-plaintext highlighter-rouge">mmtk-core</code>.</p>

<h3 id="refactoring-scanningscan_object">Refactoring Scanning::scan_object</h3>

<p><code class="language-plaintext highlighter-rouge">Scanning::scan_object</code> takes an object and a callback as parameters.  It will
find all reference fields in the object, and invoke the callback for each
reference field.</p>

<p>We need a proper name for the callback of <code class="language-plaintext highlighter-rouge">Scanning::scan_object</code>.</p>

<p>I name it <code class="language-plaintext highlighter-rouge">EdgeVisitor</code>, and its only method is, as you can imagine,
<code class="language-plaintext highlighter-rouge">visit_edge</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">EdgeVisitor</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">visit_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="n">Address</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And it replaces <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> as the parameter type of
<code class="language-plaintext highlighter-rouge">Scanning::scan_object</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Scanning</span><span class="o">&lt;</span><span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">scan_object</span><span class="o">&lt;</span><span class="n">EV</span><span class="p">:</span> <span class="n">EdgeVisitor</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">tls</span><span class="p">:</span> <span class="n">VMWorkerThread</span><span class="p">,</span>
        <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
        <span class="n">edge_visitor</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">EV</span><span class="p">,</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then the only callback that have ever been passed to <code class="language-plaintext highlighter-rouge">Scanning::scan_object</code>,
i.e. <code class="language-plaintext highlighter-rouge">ObjectsClosure</code>, now implements <code class="language-plaintext highlighter-rouge">EdgeVisitor</code>, instead.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">ProcessEdgesWork</span><span class="o">&gt;</span> <span class="n">EdgeVisitor</span> <span class="k">for</span> <span class="n">ObjectsClosure</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">visit_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... code omitted</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And this change has been <a href="https://github.com/mmtk/mmtk-core/commit/0babba20290d3c4e4cdb2a83284aa7204c9a23cc">merged</a> into the master branch of
<code class="language-plaintext highlighter-rouge">mmtk-core</code>.</p>

<h4 id="meanwhile-in-australia">Meanwhile in Australia…</h4>

<p>While I was refactoring <code class="language-plaintext highlighter-rouge">mmtk-core</code> and working on <code class="language-plaintext highlighter-rouge">mmtk-ruby</code>, my colleague
<a href="https://wenyu.me/">Wenyu Zhao</a> was busy with <a href="https://users.cecs.anu.edu.au/~steveb/pubs/papers/lxr-pldi-2022.pdf">his paper about the LXC GC algorithm</a> targetting <a href="https://pldi22.sigplan.org/details/pldi-2022-pldi/15/Low-Latency-High-Throughput-Garbage-Collection">PLDI 2022</a>.</p>

<p>Wenyu <a href="https://github.com/wenyuzhao/mmtk-core/commit/9587aca2c62e02e043a5f01c3488cd91e21515b0">independently introduced</a> the
<a href="https://github.com/wenyuzhao/mmtk-core/blob/9587aca2c62e02e043a5f01c3488cd91e21515b0/src/plan/transitive_closure.rs#L88"><code class="language-plaintext highlighter-rouge">EdgeIterator</code></a> struct.  It is a wrapper over
<code class="language-plaintext highlighter-rouge">Scanning::scan_object</code> and <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>, and the <code class="language-plaintext highlighter-rouge">unreachable!()</code>
statement, too! :P</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">EdgeIterator</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span> <span class="o">+</span> <span class="nv">'a</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">_p</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="n">EdgeIterator</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">VM</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iterate</span><span class="p">(</span><span class="n">o</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span> <span class="p">{</span> <span class="n">f</span><span class="p">:</span> <span class="k">box</span> <span class="n">f</span><span class="p">,</span> <span class="n">_p</span><span class="p">:</span> <span class="n">PhantomData</span> <span class="p">};</span>
        <span class="o">&lt;</span><span class="nn">VM</span><span class="p">::</span><span class="n">VMScanning</span> <span class="k">as</span> <span class="n">Scanning</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">scan_object</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="nf">VMWorkerThread</span><span class="p">(</span><span class="nn">VMThread</span><span class="p">::</span><span class="n">UNINITIALIZED</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="n">TransitiveClosure</span> <span class="k">for</span> <span class="n">EdgeIterator</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">VM</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.f</span><span class="p">)(</span><span class="n">slot</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">process_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this struct, it allows a closure to be used in the place of a
<code class="language-plaintext highlighter-rouge">TransitiveClosure</code>.  The following code applies the <code class="language-plaintext highlighter-rouge">inc</code> RC operation to all
adjacent objects:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">EdgeIterator</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">E</span><span class="p">::</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">iterate</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="p">|</span><span class="n">edge</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.inc</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span> <span class="n">edge</span><span class="nf">.load</span><span class="p">()</span> <span class="p">});</span>
<span class="p">})</span>
</code></pre></div></div>

<p>And the following applies <code class="language-plaintext highlighter-rouge">dec</code>, and optionally frees the object:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">EdgeIterator</span><span class="p">::</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">iterate</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">|</span><span class="n">edge</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">edge</span><span class="py">.load</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ObjectReference</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">t</span><span class="nf">.is_null</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">Ok</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="k">super</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nf">dec</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">super</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nf">is_dead</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
            <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Pretty neat, isn’t it?  It is so neat that I want to steal the code and add an
<code class="language-plaintext highlighter-rouge">EdgeVisitor::from_closure</code> factory method for my <code class="language-plaintext highlighter-rouge">EdgeVisitor</code>.</p>

<p>One interesting thing is, Wenyu introduced this for reference counting,
according to the <a href="https://github.com/wenyuzhao/mmtk-core/commit/9587aca2c62e02e043a5f01c3488cd91e21515b0">commit message</a>.  What a coincidence!  Daniel
<a href="https://github.com/JikesRVM/JikesRVM/commit/64f538ca4d348f062f3afb313f519ffcbbbd22bd">introduced <code class="language-plaintext highlighter-rouge">TraceStep</code> in 2006</a> for exactly the same
reason: reference counting, according to its commit message, too.
Understandably, reference counting is very different from tracing.  RC needs to
scan objects, but not for tracing, so passing <code class="language-plaintext highlighter-rouge">TraceLocal</code> to <code class="language-plaintext highlighter-rouge">scan_object</code>
doesn’t make sense.  Therefore, those additional operations, be it mark-grey,
scan-black or just freeing objects, all define their own callbacks to be called
by <code class="language-plaintext highlighter-rouge">scan_object</code>. This necessitates the creation of a better interface for the
callback of <code class="language-plaintext highlighter-rouge">scan_object</code>.</p>

<h3 id="refactoring-spacetrace_object">Refactoring Space::trace_object</h3>

<p>The <code class="language-plaintext highlighter-rouge">XxxSpace::trace_object</code> method usually has this form:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">VM</span><span class="p">:</span> <span class="n">VMBinding</span><span class="o">&gt;</span> <span class="n">CopySpace</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">trace_object</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">TransitiveClosure</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">trace</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
        <span class="n">semantics</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">CopySemantics</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">worker</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">GCWorker</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ObjectReference</span> <span class="p">{</span>
        <span class="c1">// ... more code omitted</span>
        <span class="k">if</span> <span class="cm">/* is first visited */</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">new_object</span> <span class="o">=</span> <span class="nn">object_forwarding</span><span class="p">::</span><span class="nn">forward_object</span><span class="p">::</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>

            <span class="n">trace</span><span class="nf">.process_node</span><span class="p">(</span><span class="n">new_object</span><span class="p">);</span>  <span class="c1">// enqueue object</span>
            <span class="n">new_object</span>  <span class="c1">// return the forwarded obj ref</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ... more code omitted</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If an object is first visited, it enqueues the object in <code class="language-plaintext highlighter-rouge">trace</code>, and returns
the forwarded object reference.</p>

<p>This method is polymorphic w.r.t. <code class="language-plaintext highlighter-rouge">T</code>.  <code class="language-plaintext highlighter-rouge">T</code> is the <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> (a
sub-trait of <code class="language-plaintext highlighter-rouge">TransitiveClosure</code>) type used by the plan.  We used to have one
different <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> type for each plan, which made this generic type
parameter necessary.</p>

<p>We already <a href="https://github.com/mmtk/mmtk-core/issues/110#issuecomment-954335561">noticed</a> that we may safely remove this
only use case of the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait (i.e. <code class="language-plaintext highlighter-rouge">trace_object</code>) once we
remove plan-specific <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> implementations. And the good thing is,
we have recently just <a href="https://github.com/mmtk/mmtk-core/commit/93281e9563fb5a780b880c086f67c75fc66bc8f8">removed</a> all plan-specific
<code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> implementations. Although we are not sure whether we will
have plan-specific <code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> for complex GC algorithms in the future, I
think the code is much cleaner for a refactoring.</p>

<p>However, I <a href="https://github.com/mmtk/mmtk-core/issues/559">believe</a> the <code class="language-plaintext highlighter-rouge">trace</code> parameter is
completely unnecessary.  We just need a return value to indicate whether it is
the first time the object is visited, so that the <em>caller</em> of <code class="language-plaintext highlighter-rouge">trace_object</code>
(which is only <code class="language-plaintext highlighter-rouge">ProcessEdgesWork::process_edge</code> at this time) can enqueue the
object.  So instead of</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">object</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">slot</span><span class="py">.load</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ObjectReference</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">new_object</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.trace_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
    <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="n">OVERWRITE_REFERENCE</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">slot</span><span class="nf">.store</span><span class="p">(</span><span class="n">new_object</span><span class="p">)</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>we shall have</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">process_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">object</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">slot</span><span class="py">.load</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ObjectReference</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">new_object</span><span class="p">,</span> <span class="n">first_visit</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.trace_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
    <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="n">OVERWRITE_REFERENCE</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">slot</span><span class="nf">.store</span><span class="p">(</span><span class="n">new_object</span><span class="p">)</span> <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">first_visit</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.enqueue</span><span class="p">(</span><span class="n">new_object</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>However, the <code class="language-plaintext highlighter-rouge">#[inline]</code> above <code class="language-plaintext highlighter-rouge">trace_object</code> indicates that it is very
performance-critical.  We’d better measure before making the decision to change.</p>

<h2 id="epilogue">Epilogue</h2>

<p>After fifteen years, the <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> trait is finally going to change.</p>

<p>The Rust MMTk is under active development now.  As we proceed, we may see more
things like this, things that have remained in its current state for years, or
even decades.  But this doesn’t mean they are always right.  We have to rethink
about the code again and again, and fix the problems whenever we can.</p>

<h2 id="update">Update</h2>

<p>We eventually <a href="https://github.com/mmtk/mmtk-core/pull/607">removed</a> <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> as well as the stale
<code class="language-plaintext highlighter-rouge">TraceLocal</code> trait from <code class="language-plaintext highlighter-rouge">mmtk-core</code>.  However, unlike we discussed in previous
sections, we did not remove the <code class="language-plaintext highlighter-rouge">trace</code> parameter from <code class="language-plaintext highlighter-rouge">trace_object</code>.  We think
“enqueuing objects” is still a responsibility of the <code class="language-plaintext highlighter-rouge">trace_object</code> method, so
we should still enqueue objects in <code class="language-plaintext highlighter-rouge">trace_object</code> instead of in <code class="language-plaintext highlighter-rouge">process_edges</code>
using the return value.  Therefore, we simply renamed <code class="language-plaintext highlighter-rouge">TransitiveClosure</code> to
<code class="language-plaintext highlighter-rouge">ObjectQueue</code>, and renamed <code class="language-plaintext highlighter-rouge">process_node</code> to <code class="language-plaintext highlighter-rouge">enqueue</code>, so they indicate exactly
what they do.  And now it is the actual object queue instead of
<code class="language-plaintext highlighter-rouge">ProcessEdgesWork</code> that implements <code class="language-plaintext highlighter-rouge">ObjectQueue</code>.</p>

<p>The signature of <code class="language-plaintext highlighter-rouge">CopySpace::trace_object</code> now looks like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[inline(always)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">trace_object</span><span class="o">&lt;</span><span class="n">Q</span><span class="p">:</span> <span class="n">ObjectQueue</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">queue</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Q</span><span class="p">,</span>
    <span class="n">object</span><span class="p">:</span> <span class="n">ObjectReference</span><span class="p">,</span>
    <span class="n">semantics</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">CopySemantics</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">worker</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">GCWorker</span><span class="o">&lt;</span><span class="n">VM</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ObjectReference</span> <span class="p">{</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">ObjectQueue</code> is still a trait.  It does not have to be a physical
queue.  If a GC algorithm does not hold objects in a queue during tracing, it
can implement this trait and process the “enqueued” object immediatey.</p>

<h2 id="see-also">See also</h2>

<p>The tracking issue: https://github.com/mmtk/mmtk-core/issues/559</p>

<!--
vim: tw=80
-->]]></content><author><name>Kunshan Wang</name></author><category term="blog" /><category term="mmtk" /><summary type="html"><![CDATA[The TransitiveClosure interface in MMTk is confusing. It should have been split into two different interfaces, but not… until now. What’s more interesting is how we ended up having an interface like that 15 years ago, and why it stayed that way since then.]]></summary></entry><entry><title type="html">Hello world!</title><link href="/blog/2022/04/15/Hello-world.html" rel="alternate" type="text/html" title="Hello world!" /><published>2022-04-15T00:00:00+00:00</published><updated>2022-04-15T00:00:00+00:00</updated><id>/blog/2022/04/15/Hello-world</id><content type="html" xml:base="/blog/2022/04/15/Hello-world.html"><![CDATA[<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
incididunt ut labore et dolore magna aliqua. A erat nam at lectus urna duis
convallis convallis. Augue mauris augue neque gravida in fermentum et
sollicitudin ac. Ante in nibh mauris cursus mattis molestie a. Cras pulvinar
mattis nunc sed blandit libero volutpat sed cras. Duis ultricies lacus sed
turpis tincidunt id. Elementum eu facilisis sed odio morbi quis commodo odio.
Quisque non tellus orci ac auctor augue mauris. Amet consectetur adipiscing
elit pellentesque habitant morbi tristique senectus. Euismod elementum nisi
quis eleifend quam adipiscing vitae. Diam maecenas sed enim ut sem viverra
aliquet eget. Habitant morbi tristique senectus et netus et. Facilisi nullam
vehicula ipsum a. Mi proin sed libero enim sed. Lacus vel facilisis volutpat
est.</p>

<p>Malesuada pellentesque elit eget gravida cum sociis natoque. Dolor magna eget
est lorem ipsum dolor. Id eu nisl nunc mi ipsum faucibus. Elit eget gravida cum
sociis natoque penatibus et. Augue interdum velit euismod in pellentesque massa
placerat duis ultricies. Aliquet eget sit amet tellus cras adipiscing enim eu
turpis. Nisl pretium fusce id velit ut tortor. Non enim praesent elementum
facilisis. Libero volutpat sed cras ornare arcu dui vivamus arcu. Molestie nunc
non blandit massa enim. Nam aliquam sem et tortor consequat. Turpis egestas sed
tempus urna et pharetra pharetra. Nisi vitae suscipit tellus mauris a diam
maecenas. Praesent tristique magna sit amet purus gravida quis. Convallis
tellus id interdum velit laoreet.</p>

<p>In hac habitasse platea dictumst vestibulum. Urna neque viverra justo nec
ultrices. Amet nisl purus in mollis. Ut lectus arcu bibendum at varius vel
pharetra vel turpis. Facilisi nullam vehicula ipsum a arcu cursus vitae congue.
Ornare arcu dui vivamus arcu. Volutpat commodo sed egestas egestas fringilla
phasellus faucibus scelerisque eleifend. Et pharetra pharetra massa massa
ultricies mi. At augue eget arcu dictum varius duis at consectetur. Amet massa
vitae tortor condimentum lacinia quis vel eros.</p>

<p>Tellus pellentesque eu tincidunt tortor aliquam nulla facilisi cras fermentum.
Feugiat nisl pretium fusce id velit. Dictum at tempor commodo ullamcorper a.
Quam vulputate dignissim suspendisse in. Massa id neque aliquam vestibulum
morbi blandit cursus risus. Laoreet sit amet cursus sit amet dictum sit amet.
Cursus vitae congue mauris rhoncus aenean vel elit. Phasellus vestibulum lorem
sed risus. Et netus et malesuada fames ac. Pharetra magna ac placerat
vestibulum lectus mauris ultrices eros in. Proin sed libero enim sed faucibus
turpis in. Sed vulputate mi sit amet mauris commodo quis. Egestas tellus rutrum
tellus pellentesque eu tincidunt tortor aliquam. Consectetur purus ut faucibus
pulvinar elementum integer enim. Elementum tempus egestas sed sed risus.
Molestie ac feugiat sed lectus vestibulum mattis ullamcorper. Convallis a cras
semper auctor neque vitae tempus quam pellentesque. Nunc vel risus commodo
viverra. Nam libero justo laoreet sit amet cursus. Elit duis tristique
sollicitudin nibh sit amet commodo nulla.</p>

<p>In ante metus dictum at tempor commodo ullamcorper a lacus. Id eu nisl nunc mi
ipsum faucibus. Semper eget duis at tellus at. Proin sagittis nisl rhoncus
mattis rhoncus. Habitasse platea dictumst vestibulum rhoncus est pellentesque.
Eget felis eget nunc lobortis mattis aliquam. Risus sed vulputate odio ut enim
blandit volutpat maecenas volutpat. Viverra nibh cras pulvinar mattis nunc sed
blandit libero. Ut venenatis tellus in metus vulputate. Aliquam sem et tortor
consequat id. Suspendisse ultrices gravida dictum fusce ut placerat orci nulla.</p>]]></content><author><name>Kunshan Wang</name></author><category term="blog" /><summary type="html"><![CDATA[Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. A erat nam at lectus urna duis convallis convallis. Augue mauris augue neque gravida in fermentum et sollicitudin ac. Ante in nibh mauris cursus mattis molestie a. Cras pulvinar mattis nunc sed blandit libero volutpat sed cras. Duis ultricies lacus sed turpis tincidunt id. Elementum eu facilisis sed odio morbi quis commodo odio. Quisque non tellus orci ac auctor augue mauris. Amet consectetur adipiscing elit pellentesque habitant morbi tristique senectus. Euismod elementum nisi quis eleifend quam adipiscing vitae. Diam maecenas sed enim ut sem viverra aliquet eget. Habitant morbi tristique senectus et netus et. Facilisi nullam vehicula ipsum a. Mi proin sed libero enim sed. Lacus vel facilisis volutpat est.]]></summary></entry></feed>